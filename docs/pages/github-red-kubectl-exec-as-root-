<h2 id="发生什么事了">发生什么事了？</h2>
<p>最近在写集群相关的 Side Project，主要是使用 Kubernetes 的 Go SDK 进行开发。其中有个功能需要在 Pod 启动完成后在 Pod 的容器中执行命令。</p>
<p>但在使用 Go SDK 执行命令这里就有一个坑。你会发现在<code>k8sClient.CoreV1().Pod(namespace)</code> 下居然没有形如 <code>Exec()</code> 这样的方法可以使用，GitHub Copilot 也直接在这里傻掉了不知道如何补全。
通过翻阅 <code>kubectl</code> 源码中关于 <code>exec</code> 子命令实现，我找到了这个：<a href="https://github.com/kubernetes/kubernetes/blob/master/staging/src/k8s.io/kubectl/pkg/cmd/exec/exec.go#L353-L366">src/k8s.io/kubectl/pkg/cmd/exec/exec.go#L353-L366</a></p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// TODO: consider abstracting into a client invocation or client helper</span>
</span></span><span style="display:flex;"><span>req <span style="color:#ff7b72;font-weight:bold">:=</span> restClient.<span style="color:#d2a8ff;font-weight:bold">Post</span>().
</span></span><span style="display:flex;"><span> <span style="color:#d2a8ff;font-weight:bold">Resource</span>(<span style="color:#a5d6ff">&#34;pods&#34;</span>).
</span></span><span style="display:flex;"><span> <span style="color:#d2a8ff;font-weight:bold">Name</span>(pod.Name).
</span></span><span style="display:flex;"><span> <span style="color:#d2a8ff;font-weight:bold">Namespace</span>(pod.Namespace).
</span></span><span style="display:flex;"><span> <span style="color:#d2a8ff;font-weight:bold">SubResource</span>(<span style="color:#a5d6ff">&#34;exec&#34;</span>)
</span></span><span style="display:flex;"><span>req.<span style="color:#d2a8ff;font-weight:bold">VersionedParams</span>(<span style="color:#ff7b72;font-weight:bold">&amp;</span>corev1.PodExecOptions{
</span></span><span style="display:flex;"><span> Container: containerName,
</span></span><span style="display:flex;"><span> Command: p.Command,
</span></span><span style="display:flex;"><span> Stdin: p.Stdin,
</span></span><span style="display:flex;"><span> Stdout: p.Out <span style="color:#ff7b72;font-weight:bold">!=</span> <span style="color:#79c0ff">nil</span>,
</span></span><span style="display:flex;"><span> Stderr: p.ErrOut <span style="color:#ff7b72;font-weight:bold">!=</span> <span style="color:#79c0ff">nil</span>,
</span></span><span style="display:flex;"><span> TTY: t.Raw,
</span></span><span style="display:flex;"><span>}, scheme.ParameterCodec)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff7b72">return</span> p.Executor.<span style="color:#d2a8ff;font-weight:bold">Execute</span>(<span style="color:#a5d6ff">&#34;POST&#34;</span>, req.<span style="color:#d2a8ff;font-weight:bold">URL</span>(), p.Config, p.In, p.Out, p.ErrOut, t.Raw, sizeQueue)
</span></span></code></pre></div><p>我们可以看到这里其实是直接构造 HTTP 请求对着 Kubernetes APIServer 进行请求，Go SDK 里并没有封装。甚至在上方的注释中还留着一则<strong>七年前的“贴心” TODO</strong>，说要考虑将这块抽象成一个 SDK 里的方法。转眼间七年过去了，这坑还是没填。😅
需要注意的是 kubectl 的实现最后是用了它自己的 <code>Execute</code> 方法发送了个 POST 请求，但这里其实是需要流式的去读取命令执行所返回的结果。最后应该使用 <code>Stream()</code>，可以参照我的最终代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>req <span style="color:#ff7b72;font-weight:bold">:=</span> e.k8sClient.<span style="color:#d2a8ff;font-weight:bold">RESTClient</span>().<span style="color:#d2a8ff;font-weight:bold">Post</span>().
</span></span><span style="display:flex;"><span> <span style="color:#d2a8ff;font-weight:bold">Resource</span>(<span style="color:#a5d6ff">&#34;pods&#34;</span>).
</span></span><span style="display:flex;"><span> <span style="color:#d2a8ff;font-weight:bold">Name</span>(pod.Name).
</span></span><span style="display:flex;"><span> <span style="color:#d2a8ff;font-weight:bold">Namespace</span>(pod.Namespace).
</span></span><span style="display:flex;"><span> <span style="color:#d2a8ff;font-weight:bold">SubResource</span>(<span style="color:#a5d6ff">&#34;exec&#34;</span>)
</span></span><span style="display:flex;"><span>req.<span style="color:#d2a8ff;font-weight:bold">VersionedParams</span>(<span style="color:#ff7b72;font-weight:bold">&amp;</span>coreV1.PodExecOptions{
</span></span><span style="display:flex;"><span> Stdout: <span style="color:#79c0ff">true</span>,
</span></span><span style="display:flex;"><span> Stderr: <span style="color:#79c0ff">true</span>,
</span></span><span style="display:flex;"><span> Container: containerName,
</span></span><span style="display:flex;"><span> Command: command,
</span></span><span style="display:flex;"><span> TTY: <span style="color:#79c0ff">true</span>,
</span></span><span style="display:flex;"><span>}, scheme.ParameterCodec)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// Send the request.</span>
</span></span><span style="display:flex;"><span>respBody, err <span style="color:#ff7b72;font-weight:bold">:=</span> e.k8sClient.<span style="color:#d2a8ff;font-weight:bold">RESTClient</span>().<span style="color:#d2a8ff;font-weight:bold">Post</span>().<span style="color:#d2a8ff;font-weight:bold">AbsPath</span>(req.<span style="color:#d2a8ff;font-weight:bold">URL</span>().Path).<span style="color:#d2a8ff;font-weight:bold">Stream</span>(ctx)
</span></span><span style="display:flex;"><span><span style="color:#ff7b72">if</span> err <span style="color:#ff7b72;font-weight:bold">!=</span> <span style="color:#79c0ff">nil</span> {
</span></span><span style="display:flex;"><span> <span style="color:#ff7b72">return</span> <span style="color:#79c0ff">nil</span>, errors.<span style="color:#d2a8ff;font-weight:bold">Wrap</span>(err, <span style="color:#a5d6ff">&#34;post request&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#ff7b72">defer</span> <span style="color:#ff7b72">func</span>() { _ = respBody.<span style="color:#d2a8ff;font-weight:bold">Close</span>() }()
</span></span></code></pre></div><p>然后，我又遇到问题了 —— 有些镜像启动的容器咋 kubectl exec 进去的用户不是 root？同时我也无法使用 <code>su</code> 切换用户。拿着低权用户的 shell 有很多操作都做不了，这该咋办呢？</p>
<p>我便开始在网上搜索 <code>kubectl exec as root</code>，在看了不少官方的 issue 建议和 Stackoverflow 上的奇技淫巧后，我梳理考究了下这个问题的来龙去脉，写下此文来讲述下这个长达六年还未实现的需求背后的故事。</p>
<h2 id="名词辨析">名词辨析</h2>
<p>前方预警！在后文中你可能会遇见 <code>containerd</code>、<code>runc</code>、<code>OCI</code>、<code>CRI</code>、<code>Docker</code> 等等这些名词，在正式开始前我们不妨先梳理下这些名词，至少先弄清楚它们之间的关系。</p>
<p>这里先放一张图，各位可以简单瞄一眼后继续往下看。</p>
<p><img src="https://github.red/images/2022/11/container-family.png" alt=""></p>
<h3 id="是造物者之无尽藏也">是造物者之无尽藏也</h3>
<p>还记得最开始我在大一上学期的时候接触了 Docker，当时给我印象很深的一句话是：“Docker 这玩意就是新瓶装旧酒。” 所谓容器，只不过是封装了 Linux 系统内核提供的功能去实现资源的隔离。本质还是 Linux Container 的 <code>cgroups</code>、<code>namespaces</code>。</p>
<ul>
<li><code>cgroups</code>：用于 CPU、内存、磁盘和网络 IO 物理资源的隔离</li>
<li><code>namespaces</code>：用于 PID、IPC、Network 等系统资源的隔离
以上这些都是 Linux 内核中提供的功能，我们可以看作“是神赐予的”。
我这里想到了苏轼《赤壁赋》里的这句：“是造物者之无尽藏也，而吾与子之所共适。”😋</li>
</ul>
<h3 id="runc">runc</h3>
<p>Docker 开发并使用了一个名为 <code>runc</code> 的程序，用于调用这些神赐予的功能，来创建一个个容器。<code>runc</code> 的功能十分简单，它本身是一个命令行程序，也就只能用来做创建容器（<code>runc create</code>）、开启容器（<code>runc start</code>）、列出容器（<code>runc list</code>）、删除容器（<code>runc delete</code>）这些基础功能。
<code>runc</code> 背后的原理是使用 C 语言编写的代码调用系统的 <code>namespaces</code> 和 <code>cgroups</code> 来创建容器，然后在 Go 层面使用 CGO 调用 C 语言，封装成了 <a href="https://github.com/opencontainers/runc/tree/main/libcontainer"><code>libcontainer</code></a> 这么一个库。
<code>runc</code> 遵循 OCI（Open Container Initiative）规范中的 Runtime-Spec。这个 OCI 是 Docker 当年牵头制定的，分为 Runtime-Spec 和 Image-Spec，分别制定了运行时和镜像的规范。
<strong>我们将 <code>runc</code> 这种只能启停容器的十分底层的容器运行时叫做低级容器运行时（Low-Level Container Runtime）</strong>。这么称呼是为了和后面提到的 containerd 这种**高级容器运行时（High-Level Container Runtime）**区分开来。</p>
<h3 id="containerd">containerd</h3>
<p>那 <code>containerd</code> 又是啥呢？<code>containerd</code> 基于 <code>runc</code> 的实现了启停管理容器的能力，同时自身还支持了对容器镜像的管理，就如我们用的 <code>docker pull</code> <code>docker push</code> 推拉镜像，导出镜像等功能。它这里关于镜像的功能也是遵循着上面提到的 OCI Image-Spec 的规范。</p>
<p>而跟我们日常打交道的 Docker，准确的说是 Docker Engine，其又是在 containerd 上简单套了层壳，我们的拉取镜像、启停容器，其实最后还是落到了 containerd 身上去执行。像 <code>containerd</code> 这样的高级运行时还有 <code>CRI-O</code>。</p>
<h3 id="震惊">震惊！</h3>
<p>好的，如果到这里你还没晕的话，那我们可以插个题外话来讲讲前年 Kubernetes 那条被国内公众号疯狂标题党的新闻了：
前年 Kubernetes 官方宣布将在未来发布的版本中弃用 <code>dockershim</code>，直接在源码中删掉 <code>dockershim</code> 的部分。官方的解释可以看<a href="https://kubernetes.io/zh-cn/blog/2020/12/02/dockershim-faq/">这篇文章</a>。</p>
<p>这事传到国内公众号就变成：“Kubernetes 宣布不再支持 Docker 运行时” 这种标题党文章。我们上面聊到了 Docker Engine -&gt; containerd -&gt; runc 这层关系，而 <code>dockershim</code> 则是用于处理 Kubernetes -&gt; Docker Engine 这层关系的。</p>
<p>由于当年 Docker 刚出来一家独大，野蛮生长的过程中做了很多不是那么规范的事情，Kubernetes 之后才制定了<strong>容器运行时接口 CRI（Container Runtime Interface）</strong> 规范（注意跟上面那个 OCI 是两个东西）来约束容器运行时的行为。但 Docker 这东西毕竟先出来并不遵守 CRI，它出来混的时候还没你 CRI 甚至 Kubernetes 什么事呢！
后面 Kubernetes 想遵守 CRI 规范整合接入各种运行时的时候，就不得不为 Docker Engine 当年的所作所为“买单”，也就是写了 <code>dockershim</code> 这么个东西作为中间层让 Docker Engine 遵循 CRI 规范进行接入。<code>dockershim</code> 这坨“屎山”越来越繁重，后面 Kubernetes 直接开摆不想干了，直接把 Docker Engine 去掉吧，我们直接拥抱遵守 CRI 规范的 <code>containerd</code>！</p>
<p>整个关系也就从：</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-txt" data-lang="txt"><span style="display:flex;"><span>Kubernetes -&gt; Docker Engine -&gt; containerd -&gt; runc
</span></span></code></pre></div><p>变成了</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-txt" data-lang="txt"><span style="display:flex;"><span>Kubernetes -&gt; containerd -&gt; runc
</span></span></code></pre></div><p>确实也没什么问题，你 Docker Engine 不也是 <code>containerd</code> 套壳嘛，这也就是为什么我们现在 <code>docker build</code> 的镜像仍可以在 Kubernetes 正常使用的原因，因为这些都是遵守 <code>OCI Image-Spec</code> 的。唯一的不同只不过是你切到集群节点上，用 <code>docker ps</code> 看不到容器了，而是要用 <code>containerd</code> 的 CLI 命令 <code>ctr --namespace k8s.io containers ls</code> 去查看容器。</p>
<h2 id="问题出在谁身上呢">问题出在谁身上呢？</h2>
<p>理清了上面这些概念后，我们就可以来调查究竟是谁的问题了。还记得我们的问题是什么吗？<code>kubectl exec</code> 怎么不支持指定用户（比如 root）执行命令？
首先，看最终的低层容器运行时 <code>runc</code> 的源码：<a href="https://github.com/opencontainers/runc/blob/main/exec.go#L48-L51">opencontainers/runc exec.go#L48-L51</a>，命令行参数里居然是支持指定 UID 和 GID 的！该参数后面会被传入到 <code>libcontainer</code>，在 cgroups 中 <a href="https://github.com/opencontainers/runc/blob/main/libcontainer/specconv/spec_linux.go#L456-L462">opencontainers/runc libcontainer/specconv/spec_linux.go#L456-L462</a> 最后使用 <code>os.Chown</code> 赋予指定用户操作的权限。</p>
<p>那再往上追到 <code>containerd</code>，找到 <code>containerd</code> 中 <code>ctr task exec</code> 的源码部分，发现使用了 OCI 规范中定义的结构体 <a href="https://github.com/opencontainers/runtime-spec/blob/main/specs-go/config.go#L43"><code>Process</code></a>，该结构体定义了在容器中启动进程需要的信息，其中就有 <code>User</code> 字段用于指定用户！</p>
<p>那&hellip;&hellip; 既然 OCI 规范里都支持了，再往上追就只有一个了：Kubernetes 定义的 CRI 规范。在 <a href="https://github.com/kubernetes/cri-api/blob/c75ef5b/pkg/apis/runtime/v1/api.proto#L1158-L1177">kubernetes/cri-api</a> 中我们找到了 CRI 规范的 Protobuf 定义文件，其中的 <code>ExecRequest</code> 确实不支持指定用户&hellip;&hellip;
同时我还发现有个老哥试图提 PR <a href="https://github.com/kubernetes/kubernetes/pull/59092">#59092</a> 让 CRI 规范支持这个功能，他也是在 Proto 文件里加了这么一个字段。在下面的评论中我们也发现这居然是 Kubernetes TOP3 的期望功能。可惜这个 PR 后面不明不白地就被关了。</p>
<p>在 <code>containerd</code> 中我也看到了有人提出了这个问题 <a href="https://github.com/containerd/containerd/issues/6662">#6662</a>，<code>containerd</code> 的人也表示很无奈，想让 <code>kubectl exec</code> 支持指定用户，那就只能让上层改 CRI 规范，然后它们下层做适配，但是这事现在一直被搁置着，也没个人来推。</p>
<p>一直&hellip;&hellip; 搁置了六年。</p>
<h2 id="代码还是得写的该如何解决呢">代码还是得写的，该如何解决呢？</h2>
<p>日子总是要过的，代码还是得写的，真的就没有办法了吗？
其实不然，在 issue <a href="https://github.com/kubernetes/kubernetes/issues/30656">#30656</a> 里有人提出了一种很蠢的办法：
安装一个 <code>kubectl</code> 插件，使用 <code>kubectl ssh</code> 连上对应的节点宿主机，然后找到容器直接执行命令。这真的真的是太蠢了。</p>
<p>我在这个 issue 下找到了这么一个项目 <a href="https://github.com/ssup2/kpexec">ssup2/kpexec</a>，借鉴其中用到的方法相对优雅的解决了这个问题！这里放一下 kpexec 项目的架构图用于方便说明：</p>
<p><img src="https://github.red/images/2022/11/kpexec_Operation.png" alt=""></p>
<p>我的做法其实比它更简单。我们上面提到了，容器系统资源隔离本质上还是使用了内核中的 <code>namespaces</code>，所有的虚拟化都是在操作系统层面完成的。 而系统中有 <code>nsenter</code> 这个命令，可以帮助我们进入到对应容器的 <code>namespace</code> 命名空间中，在该命名空间中执行命令，默认的用户权限就是 root！
假如我们要在部署于 A 节点的 Pod 的容器 B 下以 root 权限执行命令，步骤如下：</p>
<ol>
<li>在 A 节点下创建一个特权容器，即获得了宿主机节点的操作权限。使用 nsenter 进入 PID = 1 的命名空间执行命令，也就相当于直接在宿主机上执行命令。</li>
<li>在宿主机上调用 crictl inspect 命令查看容器 B 的 PID。</li>
<li>再次在宿主机上使用 nsenter 进入容器 B 的命名空间，以 root 用户执行命令。</li>
</ol>
<p>我的最终代码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// Get the container CRI information by execute the `crictl` command in node, then execute as root with `nsenter`.</span>
</span></span><span style="display:flex;"><span> execCommand <span style="color:#ff7b72;font-weight:bold">:=</span> []<span style="color:#ff7b72">string</span>{
</span></span><span style="display:flex;"><span> <span style="color:#a5d6ff">&#34;sh&#34;</span>, <span style="color:#a5d6ff">&#34;-c&#34;</span>,
</span></span><span style="display:flex;"><span> <span style="color:#a5d6ff">&#34;nsenter -t 1 -m -u -n -i crictl inspect &#34;</span> <span style="color:#ff7b72;font-weight:bold">+</span> hostContainerName <span style="color:#ff7b72;font-weight:bold">+</span>
</span></span><span style="display:flex;"><span> <span style="color:#a5d6ff">&#34; | jq -r .info.pid | xargs -I {} nsenter -t {} -m -u -n -i sh -c &#39;&#34;</span> <span style="color:#ff7b72;font-weight:bold">+</span> strings.<span style="color:#d2a8ff;font-weight:bold">Join</span>(command, <span style="color:#a5d6ff">&#34; &#34;</span>) <span style="color:#ff7b72;font-weight:bold">+</span> <span style="color:#a5d6ff">&#34;&#39; || true&#34;</span>,
</span></span><span style="display:flex;"><span> }
</span></span></code></pre></div><p>满足 CRI 规范的高级运行时均可以使用 <code>crictl</code> 来进行操作。这样我们就不用再傻傻去判断 Docker Engine、containerd、CRI-O 然后再傻傻调各自的 CLI 了。这里使用 <code>crictl inspect</code> 加容器名称查看容器信息，使用 <code>jq</code> 提取出返回 JSON 中记录的容器 PID。最后特权容器进入该进程 PID 所在的 namespace 执行命令。最后还加个 <code>|| true</code> 来确保最后执行的命令一定是正常退出的。
（不要在这里跟我 ky 什么命令注入漏洞啥的，<code>command</code> 是从可信的来源传入的，前面已经做了权限检查）</p>
<p>至于一些细节，比如用 NodeSelector 去将特权容器部署到与执行命令相同的 Node 上，怎么获取 <code>pod.Status.ContainerStatuses</code> 中的 <code>HostContainerName</code> 这些，就不再赘述了。大家自己动手写写就都知道了。</p>
<h2 id="最后说几句">最后说几句</h2>
<p>可能本文前面的篇幅有点长了，最后的 <code>nsenter</code> 反而没有过多着墨。不过确实梳理过这些名词后，我对于以 Docker 为起点的容器这套东西的理解更加透彻了些。
今天也抽时间看了些 Kubernetes 攻防相关的资料，感觉容器逃逸像 runc CVE-2019-5736 这个洞，本质上还是相关的运行时软件在操作不可信的容器环境时，行为上过于“侵入”或者“依赖”容器内的不可信环境从而出了问题。runc 这个是把自己传到了危险重重的容器里，以前的 CVE-2019-14271 <code>docker cp</code> 容器逃逸，是因为使用了容器内的 so 库。容器内的进程本质上只是一个受限的普通 Linux 进程，其对宿主机是完全透明的，我感觉这也使得它与宿主机的界限变得模糊，有种很容易就能被突破的感觉。</p>
<p>大概是一年前，我对 Kubernetes 还是持有一种较为厌恶的情绪的，啥也不懂的我也学着大家当乐子人玩 YAML 工程师的梗。今年三月的 D^3CTF，我用 Kubernetes Go SDK 写了个动态开启靶机的程序。在那之后我对它的印象有了很大的改观。不愧是生产级别的容器调度程序，我想删掉一个 Pod，它就是能给我删掉，不像 Docker 有时候 <code>--force</code> 强制了但是 Docker Engine 会迷之卡顿然后没删掉。Kubernetes 能给我带来一种安心的感觉。</p>
<p>推荐阅读：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/sfOXxBoppV6QZSpblMsMJQ">Docker、Containerd、RunC分别是什么</a>：名词辨析比我上面写的更加详细。</li>
<li><a href="https://fankangbest.github.io/2017/11/24/containerd-containerd-shim%E5%92%8Crunc%E7%9A%84%E4%BE%9D%E5%AD%98%E5%85%B3%E7%B3%BB/">containerd-containerd-shim和runc的依存关系</a>：从源码层面分析了三者的依存关系，很有意思。</li>
<li><a href="https://github.com/neargle/my-re0-k8s-security">从零开始的Kubernetes攻防</a>：除了容器，基于容器的 Serverless 服务也是我很感兴趣的一个方向，我从这里学到很多有趣的攻击方法。</li>
</ul>
<p><figure><img src="https://veekaybee.github.io/images/296615116-a57d4389-445e-4eea-92fe-0ee0320fe498.png" width="600">
</figure>

Image with some help from <a href="https://dingboard.com/">Dingboard.</a></p>
<p>In 2023, I wrote two pieces on machine learning engineering for <a href="https://newsletter.pragmaticengineer.com/">The Pragmatic Programmer</a>. (<a href="https://newsletter.pragmaticengineer.com/p/what-is-ml-engineering">Part 1</a> and <a href="https://newsletter.pragmaticengineer.com/p/the-machine-learning-toolset">Part 2</a>). However, since I started working <a href="https://gist.github.com/veekaybee/be375ab33085102f9027853128dc5f0e">with LLMs recently</a>, neural architectures have changed some of those assumptions.</p>
<p>To be clear, most of machine learning in production is still not related to large language models or generative AI, and even deep learning projects, of which LLMs are a small subset, make up no more than 10% of the market, at most. But it&rsquo;s still helpful to compare and contrast classical ML systems with their LLM counterparts, because this is where we&rsquo;re going in the future.</p>
<h2 id="machine-learning-is-compression">Machine learning is compression</h2>
<p>At its core, a machine learning model is an algorithm that performs compression on a corpus of data.</p>
<figure><img src="https://veekaybee.github.io/images/296805624-608a2fa7-89c2-49a7-ad92-6fe348a3d0b0.png" width="600">
</figure>

<p>In the first half of the 20th century, when digital communication in the then-nascent telephone industry exploded, scientists and engineers <a href="https://www.nature.com/articles/s42254-022-00426-6">at Bell Labs</a> started studying the projection and representation of information. In developing this field, scientists like Harry Nyquist, Ralph Hartley, and Claude Shannon were concerned with irregularities in information transfer, particularly across radio signals . Information theory was developed to solve the problem of transmitting a message, via radio, telephone, or television, with the most accuracy. It turned out that the most efficient way to inspect information was to not look at the actual data, but to analyze the statistical properties of that message. So, much of the science work centered around creating approximate representations of data. For example, Kolmogorov complexity, was developed as an notion that describes how much information is needed to represent something. In the case of a string, it&rsquo;s the shortest program that can generate that string. The more complex that string is, the higher specification a program.</p>
<p>What came out of the early work in information theory was that, in order to efficiently work with large amounts of information, we need to be able to effectively compress it into as little space as we can without losing fidelity of that information.</p>
<p>Given the continued explosion of text, and later multi-modal (voice, video, etc.) information, the algorithms developed around compression continued to stay relevant. Compression is the same fundamental concept underlying both traditional machine learning models and LLMs, although this idea is usually burried under layers of other context.</p>
<figure><img src="https://veekaybee.github.io/images/296808672-33ef2ef7-4461-406f-9d33-8d8e783cea71.png" width="600">
</figure>

<h2 id="gzip-is-compression-is-machine-learning">GZip is compression is machine learning</h2>
<p>Every once in a while, this initial context comes out. For example, a few months ago, a paper came out that took the machine learning world by storm. With the unassuming title, <a href="https://arxiv.org/abs/2212.09410">&ldquo;Less is More: Parameter-Free Text Classification with Gzip&rdquo;</a>, the paper claimed that simply compressing data using gzip and running knn search over the compressed data for classification tasks beats gold-standard neural network-based language models like BERT.</p>
<p>The premise behind the work was that is that in any given collection of objects, we can compare them based on how close they are to each other, and for the downstream task, classify them in categories, in a way that doesn&rsquo;t involve deep learning.</p>
<p>For example, let&rsquo;s say we have a <a href="https://huggingface.co/datasets/ag_news">dataset of news article headlines.</a>, and we have several categories of headlines (business, sports, tech, and more). The data looks like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-json" data-lang="json"><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span> <span style="color:#f92672">&#34;label&#34;</span>: <span style="color:#ae81ff">2</span>,
</span></span><span style="display:flex;"><span> <span style="color:#f92672">&#34;text&#34;</span>: <span style="color:#e6db74">&#34;Stocks End Up, But Near Year Lows (Reuters) Reuters - Stocks ended slightly higher on Friday but stayed near lows for the year as oil prices surged past a barrel, offsetting a positive outlook from computer maker Dell Inc. (DELL.O)&#34;</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Given a new headline, can we learn some kind of model that will accurately match the string to a category? We might want to do this for any number of reasons: assigning trending topics <a href="https://vickiboykis.com/what_are_embeddings/">in a site like Flutter</a>, categorizing items in ecommerce for sale, or knowledge curation within companies, or <a href="https://arxiv.org/abs/2010.04049">within medicine.</a></p>
<p>How might we do this if we have to brute force it? We&rsquo;d take a string and compare it, character by character, to another string. That&rsquo;s the idea behind <a href="https://en.wikibooks.org/wiki/Algorithm_Implementation/Strings/Levenshtein_distance">Levenshtein, or edit, distance.</a>. This approach means you quickly start running into problems where you have to perform <code>O(N)</code> lookups across your entire dataset and have to start keeping track of data in lists or arrays.</p>
<p>We might then use traditional methods <a href="https://github.com/veekaybee/what_are_embeddings/blob/main/notebooks/fig_24_tf_idf_from_scratch.ipynb">like TF-IDF</a> to classify the strings. This also eventually runs into scaling issues as your vocabulary size becomes bigger and bigger. More often recently, neural network and deep learning approaches like <a href="https://github.com/MaartenGr/BERTopic">BERT</a>, and even more recently, autoregressive models <a href="https://arxiv.org/pdf/2310.09810.pdf">like those in the GPT family are being used</a> for classification tasks.</p>
<p>However, once we start using deep learning models, we run into arrays and dictionaries that become larger and larger; i.e. matrix math, which means we need GPUs and extremely large datasets. Is there any way we can work around this to create representations of our strings that are not the actual string that allow us to work with shorthand versions of our original information? For example, it would be great if, instead of having to compare these two strings:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-txt" data-lang="txt"><span style="display:flex;"><span>Stocks End Up, But Near Year Lows (Reuters) Reuters - Stocks ended slightly higher on Friday but stayed near lows for the year as oil prices surged past a barrel, offsetting a positive outlook from computer maker Dell Inc. (DELL.O)
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-txt" data-lang="txt"><span style="display:flex;"><span>Money Funds Fell in Latest Week (AP) AP - Assets of the nation&#39;s retail money market mutual funds fell by #36;1.17 billion in the latest week to $849.98 trillion, the Investment Company Institute said Thursday.
</span></span></code></pre></div><p>We could compare something like a numerical representation of the strings and see if they&rsquo;re similar. We could <a href="https://vickiboykis.com/what_are_embeddings/">learn embeddings</a> which would take time, but what if we go simpler? What&rsquo;s a function that compresses information? <a href="https://en.wikipedia.org/wiki/Gzip">Gzip</a> does. (Code examples duplicated for clarity.)</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> gzip
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> io
</span></span><span style="display:flex;"><span>input_string <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;&#34;Stocks End Up, But Near Year Lows (Reuters) Reuters - 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Stocks ended slightly higher on Friday 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">but stayed near lows for the year as oil prices surged past a barrel, 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">offsetting a positive outlook from computer maker Dell Inc. (DELL.O)&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>input_bytes <span style="color:#f92672">=</span> input_string<span style="color:#f92672">.</span>encode(<span style="color:#e6db74">&#39;utf-8&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>output_buffer <span style="color:#f92672">=</span> io<span style="color:#f92672">.</span>BytesIO()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>compressed_data <span style="color:#f92672">=</span> output_buffer<span style="color:#f92672">.</span>getvalue()
</span></span><span style="display:flex;"><span>print(compressed_data)
</span></span><span style="display:flex;"><span><span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\x1f\x8b\x08\x00\xdd\xaa\x8d</span><span style="color:#e6db74">e</span><span style="color:#ae81ff">\x02\xff</span><span style="color:#e6db74">%</span><span style="color:#ae81ff">\x8d</span><span style="color:#e6db74">M</span><span style="color:#ae81ff">\x0b\x82</span><span style="color:#e6db74">@</span><span style="color:#ae81ff">\x14</span><span style="color:#e6db74">E</span><span style="color:#ae81ff">\xf7\xfe\x8a\xbb\x08</span><span style="color:#e6db74">*(A</span><span style="color:#ae81ff">\x08\xd2\xa5\x04</span><span style="color:#e6db74">BP</span><span style="color:#ae81ff">\xe0</span><span style="color:#e6db74">&#34;h=</span><span style="color:#ae81ff">\xe2\x13\x07\xe7</span><span style="color:#e6db74">#|o</span><span style="color:#ae81ff">\x8a\xf9\xf7</span><span style="color:#e6db74">9</span><span style="color:#ae81ff">\xba\xbd\x9c</span><span style="color:#e6db74">{</span><span style="color:#ae81ff">\xce\xd3</span><span style="color:#e6db74">;</span><span style="color:#ae81ff">\x8a</span><span style="color:#e6db74">h</span><span style="color:#ae81ff">\x82\xeb\x19\r\x19\x03\xed\xf0</span><span style="color:#e6db74">PB,x</span><span style="color:#ae81ff">\x13</span><span style="color:#e6db74">M8</span><span style="color:#ae81ff">\xd4\xed\x11</span><span style="color:#e6db74">u</span><span style="color:#ae81ff">\x8b</span><span style="color:#e6db74">3</span><span style="color:#ae81ff">\xb2\x9a\x99\x84\xe1\x07\xc8</span><span style="color:#e6db74">HpJ</span><span style="color:#ae81ff">\xb4</span><span style="color:#e6db74">w{</span><span style="color:#ae81ff">\xc6</span><span style="color:#e6db74">L</span><span style="color:#ae81ff">\xa2\xb4\x81</span><span style="color:#e6db74">]EV</span><span style="color:#ae81ff">\xcd\x13\t</span><span style="color:#e6db74">l</span><span style="color:#ae81ff">\x90\xa0\x0c\x86</span><span style="color:#e6db74">U;$m</span><span style="color:#ae81ff">\x17\x91\xed\x8a\xbc\xb8\xa2\xd3\xc6</span><span style="color:#e6db74">,</span><span style="color:#ae81ff">\xcf\x14</span><span style="color:#e6db74">J</span><span style="color:#ae81ff">\x1e\xb3\xc5</span><span style="color:#e6db74">~)&amp;</span><span style="color:#ae81ff">\x1e\xbb\xf2</span><span style="color:#e6db74">R</span><span style="color:#ae81ff">\xe5</span><span style="color:#e6db74">U</span><span style="color:#ae81ff">\t\x99</span><span style="color:#e6db74">7</span><span style="color:#ae81ff">\xec\x84</span><span style="color:#e6db74">,Qw</span><span style="color:#ae81ff">\xf7</span><span style="color:#e6db74">](KNp</span><span style="color:#ae81ff">\xf3\xf6\xa3\\\\</span><span style="color:#e6db74">&amp;</span><span style="color:#ae81ff">\x16</span><span style="color:#e6db74">-A</span><span style="color:#ae81ff">\x08\xac</span><span style="color:#e6db74">t</span><span style="color:#ae81ff">\x8f\xd7\x18</span><span style="color:#e6db74">f</span><span style="color:#ae81ff">\xee</span><span style="color:#e6db74">U</span><span style="color:#ae81ff">\xcc\xff\x17\xe6\xe7</span><span style="color:#e6db74">v</span><span style="color:#ae81ff">\xd2\x00\x00\x00</span><span style="color:#e6db74">&#39;</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> gzip
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> io
</span></span><span style="display:flex;"><span>input_string <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;&#34;Money Funds Fell in Latest Week (AP) AP - 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Assets of the nation&#39;s retail money market mutual funds fell by 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">$1.17 billion in the latest week to $849.98 trillion, 
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">the Investment Company Institute said Thursday.&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>input_bytes <span style="color:#f92672">=</span> input_string<span style="color:#f92672">.</span>encode(<span style="color:#e6db74">&#39;utf-8&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>output_buffer <span style="color:#f92672">=</span> io<span style="color:#f92672">.</span>BytesIO()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>compressed_data <span style="color:#f92672">=</span> output_buffer<span style="color:#f92672">.</span>getvalue()
</span></span><span style="display:flex;"><span>print(compressed_data)
</span></span><span style="display:flex;"><span><span style="color:#e6db74">b</span><span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\x1f\x8b\x08\x00\xdd\xaa\x8d</span><span style="color:#e6db74">e</span><span style="color:#ae81ff">\x02\xff</span><span style="color:#e6db74">%</span><span style="color:#ae81ff">\x8d</span><span style="color:#e6db74">M</span><span style="color:#ae81ff">\x0b\x82</span><span style="color:#e6db74">@</span><span style="color:#ae81ff">\x14</span><span style="color:#e6db74">E</span><span style="color:#ae81ff">\xf7\xfe\x8a\xbb\x08</span><span style="color:#e6db74">*(A</span><span style="color:#ae81ff">\x08\xd2\xa5\x04</span><span style="color:#e6db74">BP</span><span style="color:#ae81ff">\xe0</span><span style="color:#e6db74">&#34;h=</span><span style="color:#ae81ff">\xe2\x13\x07\xe7</span><span style="color:#e6db74">#|o</span><span style="color:#ae81ff">\x8a\xf9\xf7</span><span style="color:#e6db74">9</span><span style="color:#ae81ff">\xba\xbd\x9c</span><span style="color:#e6db74">{</span><span style="color:#ae81ff">\xce\xd3</span><span style="color:#e6db74">;</span><span style="color:#ae81ff">\x8a</span><span style="color:#e6db74">h</span><span style="color:#ae81ff">\x82\xeb\x19\r\x19\x03\xed\xf0</span><span style="color:#e6db74">PB,x</span><span style="color:#ae81ff">\x13</span><span style="color:#e6db74">M8</span><span style="color:#ae81ff">\xd4\xed\x11</span><span style="color:#e6db74">u</span><span style="color:#ae81ff">\x8b</span><span style="color:#e6db74">3</span><span style="color:#ae81ff">\xb2\x9a\x99\x84\xe1\x07\xc8</span><span style="color:#e6db74">HpJ</span><span style="color:#ae81ff">\xb4</span><span style="color:#e6db74">w{</span><span style="color:#ae81ff">\xc6</span><span style="color:#e6db74">L</span><span style="color:#ae81ff">\xa2\xb4\x81</span><span style="color:#e6db74">]EV</span><span style="color:#ae81ff">\xcd\x13\t</span><span style="color:#e6db74">l</span><span style="color:#ae81ff">\x90\xa0\x0c\x86</span><span style="color:#e6db74">U;$m</span><span style="color:#ae81ff">\x17\x91\xed\x8a\xbc\xb8\xa2\xd3\xc6</span><span style="color:#e6db74">,</span><span style="color:#ae81ff">\xcf\x14</span><span style="color:#e6db74">J</span><span style="color:#ae81ff">\x1e\xb3\xc5</span><span style="color:#e6db74">~)&amp;</span><span style="color:#ae81ff">\x1e\xbb\xf2</span><span style="color:#e6db74">R</span><span style="color:#ae81ff">\xe5</span><span style="color:#e6db74">U</span><span style="color:#ae81ff">\t\x99</span><span style="color:#e6db74">7</span><span style="color:#ae81ff">\xec\x84</span><span style="color:#e6db74">,Qw</span><span style="color:#ae81ff">\xf7</span><span style="color:#e6db74">](KNp</span><span style="color:#ae81ff">\xf3\xf6\xa3\\\\</span><span style="color:#e6db74">&amp;</span><span style="color:#ae81ff">\x16</span><span style="color:#e6db74">-A</span><span style="color:#ae81ff">\x08\xac</span><span style="color:#e6db74">t</span><span style="color:#ae81ff">\x8f\xd7\x18</span><span style="color:#e6db74">f</span><span style="color:#ae81ff">\xee</span><span style="color:#e6db74">U</span><span style="color:#ae81ff">\xcc\xff\x17\xe6\xe7</span><span style="color:#e6db74">v</span><span style="color:#ae81ff">\xd2\x00\x00\x00</span><span style="color:#e6db74">&#39;</span>
</span></span></code></pre></div><p>Now that we&rsquo;ve compressed the strings into compact representations, we can then compare these representations. (see the <a href="https://github.com/bazingagin/npc_gzip/blob/928659e5f17c872fed96581583dc520ca1fd0769/npc_gzip/compressors/base.py#L59">original paper implementation here</a>) The gzip paper suggested that compressing two pieces of similar text using any given simple compression method, will result in similar pieces of text having more similar size in bytes than dissimilar pieces. This means that we can rank and compare representations by their similarity, as well as label them.</p>
<p>Then, to create the label, <a href="https://liorsinai.github.io/coding/2023/08/13/gzip-knn.html">the most common label among the k reference texts with the lowest normalized compression distance scores is the label of the text.</a></p>
<p>The authors of the paper claimed that this method beat out BERT, mBERT, fastText, and word2vec. Naturally, there was some skepticism around this, and in performing tests, <a href="https://kenschutte.com/gzip-knn-paper/">the community found</a> that the offline evaluation metrics the authors were using to compute accuracy were not standard (i.e. they gave more leniency in selecting either of the top two options rather than making sure that the top option was the best.)</p>
<h2 id="machine-learning-tasks-as-compression">Machine learning tasks as compression</h2>
<p>There was a lot of conversation around this paper, and then everyone forgot it in the breakneck pace of LLM model development that followed. The main takeaway is that compression is the core of machine learning. As long as we want to condense some given state of the world and try to generalize from data, we need to synthesize our input data, simply because we can&rsquo;t include the entire universe in service of our model.</p>
<figure><img src="https://veekaybee.github.io/images/296808672-33ef2ef7-4461-406f-9d33-8d8e783cea71.png" width="600">
</figure>

<p>These compression tasks take on any number of shapes: as <a href="https://www.nvidia.com/en-us/glossary/xgboost/">iterative combinations of trees</a> in gradient boosting, as <a href="https://proceedings.neurips.cc/paper_files/paper/2014/file/feab05aa91085b7a8012516bc3533958-Paper.pdf">user-item matrices in collaborative filtering</a>, or as <a href="https://sebastianraschka.com/blog/2023/self-attention-from-scratch.html">attention mechanisms</a> in deep learning models.</p>
<p>The rest of machine learning is a layer of software engineering around the model artifacts to keep them working in production settings. In other words, we have the <a href="https://www.sh-reya.com/blog/phd-year-one/">Task and the Platform.</a></p>
<h2 id="machine-learning-platforms-as-platforms-to-support-compression">Machine learning platforms as platforms to support compression</h2>
<p>What are the pieces around the model? Machine learning platforms - a collection of software components that create a systematic, automated way to take raw data, transform it, learn a model from it, and show results which support decision-making for internal or external customers.</p>
<p>For example, Netflix’s recommendations are part of ML platform. When you call an Uber or Lyft, or book an Airbnb, the chances are you’re being served software components developed by those companies’ internal ML organizations. These are very visible, consumer end-uses of machine learning, but ML is also used in the less visible parts of ML organizations, such as fraud detection at Stripe and at banks, and in content moderation on social media platforms.</p>
<p>We take some given input data, learn a simplified representation of that data using a given function that we think will model the world appropriately (aka we compress), and hope that it applies to all of the data we pass into the function.</p>
<figure><img src="https://veekaybee.github.io/images/297168465-629fb756-a83e-4b03-a90c-2c198ebe4c0d.png" width="600">
</figure>

<p>In traditional machine learning pipelines we:</p>
<ol>
<li>
<p><strong>ingest data</strong> about our application or its users. That data gets stored in a database or a data lake, where we process and clean it via data engineering so that we can feed it into a model. Before we can pass the data to the model, we need to ensure this data is valid and clean. To do so, we use tools like Jupyter notebooks, or the Python REPL (a command line) to quickly look at our data and iterate through it. The data’s analyzed and cleaned up as needed.</p>
</li>
<li>
<p><strong>select and engineer machine learning features</strong> from that data and learn a model from those features. Features can range from &ldquo;geographical location&rdquo; or &ldquo;number of shows watched this week&rdquo;.</p>
</li>
</ol>
<p>And then we <strong>learn a model and build</strong> the <a href="https://machine-learning.paperspace.com/wiki/artifacts">model artifacts.</a> Model artifacts are data structures typically consisting of:</p>
<pre><code>- Weights and biases. These are numbers known as the model’s parameters. Weights are numbers determining how much input influences the outputs. Biases are additional parameters which are starting points for prediction. They act as offsets and allow the model to make predictions when data is missing 
- Code that describes the structure of the model, including its architecture, such as the decision tree or neural network, and the number of layers
- Dependencies and libraries the code and model use.
- Model metadata: date of training, description of the model, etc. 
</code></pre>
<ol start="3">
<li>
<p>We perform <a href="https://en.wikipedia.org/wiki/Evaluation_measures_%28information_retrieval%29">offline evaluation</a> of the model artifact to see if it&rsquo;s any good inherently as-is. We do this by We need to answer questions like:</p>
<ul>
<li>Do the model’s results make statistical sense?</li>
<li>Have we minimized our loss function, which is the distance between predicted and actual model results (using data we hold out as a test set)?</li>
</ul>
</li>
</ol>
<p>There are a number of different metrics to determine whether a model is “good, ” such as root mean squared error, precision, or recall. Getting these metrics usually involves feeding test data into the model that the model has not been trained on, and observing how far away the predicted value is from the actual value.</p>
<ol start="4">
<li>We deploy that model to <strong>production</strong>. Deployment of those models to production, including all the associated software development components which keep models running, like monitoring, model tracking, feature tracking, dashboards, and tuning of the application’s performance.</li>
</ol>
<p>The running model will look something like this in the context of our application:</p>
<figure><img src="https://veekaybee.github.io/images/293257281-dd53d248-2536-425e-b027-b9433637dbb6.png" width="600">
</figure>

<ol start="5">
<li>We then perform <strong>online evaluation of the models</strong> as we launch A/B tests and finally look at production metrics. We have now developed a <strong>feedback loop</strong> between production and our modeling cycle that enables us to update the model with new data (aka user feedback,clickstream data, changes in trends, cyclical changes) and train updated models, because data is not static, and model data is non-deterministic.</li>
</ol>
<p>Anyone who has worked with ML systems painfully knows this is the case; often you are not only troubleshooting non-working software components: model failures can be anything from unexpected caching issues in production, a “classical” software engineering problem, or data drift which is when the properties of the model used for prediction change.</p>
<p>A common example of data drift is seasonality: you can’t accurately predict the same volume of ice cream sales in summer as in winter. Often, these types of drifts are not very obvious and take a long time to detect. Null or malformed log data is also a cause for “silent” modeling failures.</p>
<p>In addition to those components, Another property of the ML modeling process is that once you have more than one model, you’re responsible for both their input data and metadata, which means setting up additional systems to track assets, as well as changes in the system. Here’s a few examples of components in ML platforms which web apps usually don’t include:</p>
<p><strong>Feature stores:</strong> functionality to pull data specifically formatted for building and serving models from the data warehouse, and do this quickly.</p>
<p><strong>Monitoring data drift.</strong> Data drift occurs when input data change over time. For example, when a customer base ages. It can also happen if a new technology wasn’t included in the model’s original assumptions; for example, cell phones’ rapid spread across a telephony model built on landlines.</p>
<p><strong>Model training monitoring</strong>: the goal of this is to evaluate offline performance metrics to answer questions like how well a model will perform on unseen data.</p>
<p><strong>Model registries.</strong> These allow use of differently versioned model artifacts based on which is preferred for use in production.</p>
<p>As we can see, machine learning systems are already complex. The data-centric nature of ML means that, in addition to the usual things that can go wrong, such as service latency, there are a lot of components needed to keep an ML system running. In the paper, <a href="https://research.google/pubs/machine-learning-the-high-interest-credit-card-of-technical-debt/">Machine Learning: the high-interest credit card of technical debt</a>, its authors at Google point out:</p>
<pre><code>“Machine learning offers a fantastically powerful toolkit for building complex systems quickly. This paper argues that it is dangerous to think of these quick wins as coming for free. Using the framework of technical debt, we note that it is remarkably easy to incur massive ongoing maintenance costs at the system level when applying machine learning.”
</code></pre>
<h2 id="our-current-assumptions-about-ml-models-and-platforms">Our current assumptions about ML models and platforms</h2>
<p>In all of this work, we carry a fundamental assumption, and that assumption is that we, the group of company that is training the model, are in control of the entire process end-to-end, from developing the model, to updating it, to serving it to a front-end.</p>
<p>Here&rsquo;s how &ldquo;traditional&rdquo; machine learning works:</p>
<ul>
<li>
<p><strong>Data: All of our data lives in-house.</strong> We&rsquo;ve created very large data processing pipelines. Our hardwon <a href="https://newsletter.vickiboykis.com/archive/logs-were-our-lifeblood-now-theyre-our-liability/">upstream data collection architectures</a> do the work for us, and we build our models out of our internal user data.</p>
</li>
<li>
<p><strong>We can update the input data, delete it, and we control the filtering mechanisms we apply</strong> We can change feature spaces, change temporal parameters, try different model versions, and test them in-house to get internal metrics. In general, we can &ldquo;easily&rdquo; update the input data, to even the point where we have real-time machine learning pipelines incorporating not only things that happened yesterday, but also things that happened a minute ago as signal into our models.</p>
</li>
<li>
<p><strong>We have live production versions that were A/B tested and that we compare between artifacts</strong> We ship one model, it doesn&rsquo;t work, we roll back to the previous version. We control and have access to both of those versions and can switch between them.</p>
</li>
<li>
<p><strong>We have some level of explainability</strong> We may not be able to say exactly why model X gave recommendation or prediction Y, but we can trace the lineage of the model back to the starting point and run either SHAP or some level experiment to determine why models do what they do. This is even easier when we have <a href="https://christophm.github.io/interpretable-ml-book/simple.html">smaller, simpler models.</a></p>
</li>
</ul>
<h2 id="moving-to-llms">Moving to LLMs</h2>
<p>Large language models are large autoregressive models optimized specifically on the machine learning task of next-token generation. The smallest of these were the transformer introduced in the Google machine translation paper, with 100 million parameters. BERT, the next-largest, had 340 million parameters and a non-autoregressive, bidirectional masked language model that differed from the later GPT-style models in that it predicted missing words in a sentence rather than continuously predicting the next token, as most models today do. Today in addition to being text generation models, the standard size for LLMs seems to be somewhere around 7-13B parameters. (GPT-4 is thought to have over 1 trillion parameters).</p>
<table>
 <thead>
 <tr>
 <th>Model</th>
 <th>Parameter Size (approximate)</th>
 </tr>
 </thead>
 <tbody>
 <tr>
 <td>Transformer</td>
 <td>100 million</td>
 </tr>
 <tr>
 <td>BERT</td>
 <td>110 million</td>
 </tr>
 <tr>
 <td>GPT</td>
 <td>117 million</td>
 </tr>
 <tr>
 <td>GPT-2</td>
 <td>1.5 billion</td>
 </tr>
 <tr>
 <td>GPT-3</td>
 <td>175 billion</td>
 </tr>
 </tbody>
</table>
<p>At their core, LLMs are also massive compression models that try to encode a world, but they have several new assumptions. First, LLM pretraining datasets are MASSIVE. We are no longer working with in-house, specialized data that models our world, i.e. clothes at Stitchfix or driver data at Uber, but from <a href="https://arxiv.org/abs/2310.20707">giant generalized datasets</a> that encompass all of public human activity on the internet. Most of these datasets are not revealed, from proprietary models like OpenAI&rsquo;s, but for similar, open datasets that are, we can see they encompass an <a href="https://arxiv.org/abs/2101.00027">enormous swath of human activity.</a></p>
<p>Second, whereas traditional machine learning focused on hand-curating features, either through manual heuristics and knowledge of our product and line of business, <em>LLMs work best when we dump all our text data</em>, often unformatted although how unformatted it should be is a source of debate, into the model and let the layers sort it out.</p>
<figure><img src="https://veekaybee.github.io/images/297174071-272734c1-8471-4e8d-995c-ce222a5c77a7.png" width="600">
</figure>

<p>From: <a href="https://www.manning.com/books/deep-learning-with-pytorch">Deep Learning with PyTorch</a></p>
<p>Third, because they are so huge and architecturally complex, LLMs are extremely compute-intensive to train (or pre-train), and because they&rsquo;re very good at transfer learning (i.e. between machine learning tasks), they&rsquo;re fairly easy to fine-tune.</p>
<p>So, what are the implications in how we compress now?</p>
<h3 id="weve-lost-fine-grained-control-over-the-input-data">We&rsquo;ve lost fine-grained control over the input data</h3>
<p>All of this has had implications for machine learning architectures and economics, the first being that our control of the model has shifted. In order to understand this cycle, we need to understand a bit about internet history.</p>
<p>The early history of computing – and machine learning as a subset – was built on mainframes, which are enormous data servers that processed and kept track of data they generated in isolation from each other. In the 1970s, university researchers started configuring these standalone machines to talk to one another. ARPANET could be seen as the predecessor of the Internet. Here’s what researchers at the University of Utah wrote in 1970, after connecting the university’s computers to ARPANET:</p>
<pre><code>&quot;We have found that, in the process of connecting machines and operating systems together, a great deal of rapport has been established between personnel at the various network node sites. The resulting mixture of ideas, discussions, disagreements and resolutions, has been highly refreshing and beneficial to all involved, and we regard human interaction as a valuable by-product of the main effect.&quot;
</code></pre>
<p>When compute moved from machines to the network, the creators of these systems started keeping track of data movement and logging it, to get a consolidated view of data flows across their systems. Companies were already retaining analytical data needed to run critical business operations in relational databases, but access to that data was structured and processed in batch increments on a daily or weekly basis. This new logfile data moved quickly, and with a level of variety absent from traditional databases.</p>
<p>Capturing log data at scale began the rise of the Big Data era, which resulted in a great deal of variety, velocity, and volume of data movements. The Apache Webserver logfile was one of the greatest enablers of Big Data. The rise in data volumes coincided with data storage becoming much cheaper, enabling companies to store everything they collected on racks of commodity hardware.</p>
<p>When the data science boom hit in the early 2010s, the initial focus was on collecting as much data as possible, understanding a company’s datasets and creating models from them.</p>
<p>Once companies realized they sat on potential goldmines of unstructured data – none of which were actionable – they started hiring data scientists to make sense of it all. The practice of modern data science arose from statisticians who observed the amount of data being generated and processed required methods beyond the scope of academic statistics and processing methods on single machines.</p>
<p>At the same time, model artifacts and deliverables moved from pure one-off analyses that lived on individuals’ laptops, to production software such as the services powering web applications like Amazon and Netflix’s recommendations, risk scoring for fraud, and medical diagnostic tools. This software required models be portable, low-latency, and be managed in a central place, which meant building systems and platforms on which to manage them. The term “MLOps” arose to define the boundaries of model management and operationalization.</p>
<p>As Marianne Bellotti describes in <a href="https://nostarch.com/kill-it-fire">“Kill It With Fire, ”</a> software development paradigms are a cycle, a continuous tradeoff between how cheap it is to process data on a single machine versus sending it over the network.</p>
<pre><code>“Technology is, and probably always will be, an expensive element of any organization’s operational model. A great deal of advancement and market co-creation in technology can be understood as the interplay between hardware costs and network costs. Computers are data processors. They move data around and rearrange it into different formats and displays for us. All advancements with data processors come down to one of two things: either you make the machine faster or you make the pipes delivering data faster.”
</code></pre>
<p>We started with mainframe processing. Once we broke apart the mainframe into personal computers that were cheaper, we could write code locally. Then, our computers became even smaller and internet bandwidth became cheap, it made more sense to process and develop over the wire, particularly since much of our code was now tied up in web applications that lived in server farms. So, we sent everything to the cloud and started bundling development there.</p>
<p>Now that training is the bottleneck and bandwidth is cheap, we rely on external LLM artifacts that create generalized paradigms of compression not specific to our busines use-cases. We&rsquo;ve outsourced the model creation to a few large companies (OpenAI, Meta, Mistral, etc.) and these base model artifacts now live either behind an API or are available somewhere like the HuggingFace model hub.</p>
<p>LLM <a href="https://www.artfintel.com/p/the-evolution-of-the-llm-api-market-dcf">model artifacts right now come in two-ish flavors</a>:</p>
<ol>
<li>API-based calls to models hosted with proprietary vendors, most likely OpenAI these days, and with <a href="https://docs.together.ai/docs/openai-api-compatibility">OpenAI-interfacing APIs like Together</a> or using model artifacts hosted on model hubs like HuggingFace</li>
<li>Using your own trained, or more likely, fine-tuned model artifacts starting with a base model as an API or model hub model on your own public cloud GPU-based instances or in an HPC Slurm-style cluster. This is only now starting to pick up steam in 2024, but I expect it will grow, a lot.</li>
</ol>
<p>So what we&rsquo;ve done is changed the amount of the model we have agency over in the tradeoff for more generalizable compression. All of our data now does not live in-house, it only does in the case that we&rsquo;re fine-tuning it, and even then, we are likely using also at least some public datasets that have been put together specifically for the purporses for fine-tuning.<br>
<figure><img src="https://veekaybee.github.io/images/297181157-ce90319f-f17b-4b0b-8eac-c3a8880be4ef.png" width="600">
</figure>
</p>
<p>In each of the cases, in gaining a larger amount of compressed data, we give up some degree of internal control over our model state. This is also the reason why <a href="https://arxiv.org/abs/2312.10997">RAG as an architecture</a> is so popular. At least 50% of LLM use-cases are straight-up search, because web search (except for Kagi, <a href="https://kagi.com/">everyone should use Kagi</a> it&rsquo;s great) is in a very bad state.</p>
<figure><img src="https://veekaybee.github.io/images/297777441-99a28ef1-aaa3-4fb9-ab9b-676bafcd3252.png" width="600">
</figure>

<p>RAG gives us back some control because it allows us to perform the data updates and search fine-tuning we used to in traditional architectures but also combine the strength of the generalist model. In a lot of ways, we are just going back to Learn to Rank, but with less control over the first-pass model.</p>
<figure><img src="https://veekaybee.github.io/images/297777914-3d36a3e1-4267-4406-8ae3-b5183efacccb.png" width="600">
</figure>

<h3 id="textual-features-and-metrics-and-evaluation">Textual Features and Metrics and Evaluation</h3>
<p>When we evaluated traditional models running either online or offline, we often cared about the traditional metrics: for offline, precision, recall, F1, ROC/AUC. For online, clickthrough rate. For operational, i/o, model artifact response time in milliseconds, and service uptime. As second-level metrics, we often cared about the size of the model artifact in GB, the size of the input data, how long it took to train and re-train the model, and feature completeness (i.e. missing values, imputation, etc.)</p>
<p>Because we are now mostly compressing text rather than numerical or heterogenous features, we suddenly care about also the things above, but a <a href="https://github.com/ray-project/llm-numbers">lot of new text-based metrics</a> specific to models whose goal is to complete strings of text. We are now extremely concerned with how strings perform at scale, reading strings, writing strings, and calculating probabilities of returning specific strings from the model.</p>
<p>Specific examples include <a href="https://vgel.me/posts/faster-inference/#Metrics">&ldquo;time to first token&rdquo;</a>, <a href="https://www.reddit.com/r/LocalLLaMA/comments/162pgx9/what_do_yall_consider_acceptable_tokens_per/">tokens per second (the ultimate metric)</a>, and understanding and evaluating <a href="https://community.openai.com/t/logprobs-in-chatcompletion/329471">logprobs.</a></p>
<h3 id="gpu-architectures">GPU Architectures</h3>
<p>Finally, this entire new landscape necessitates new training and serving frameworks. The size of the models and the specific computational power they need mean suddenly <a href="https://github.com/ray-project/llm-numbers#gpu-memory">GPUs come into the mix.</a> GPUs are, needless to say, different beasts. In many of our earlier architectures we spent a lot of time in the in/out of our preprocessing data pipelines. To solve the complex problems of coordination, analysis, and engineering that machine learning in production involves, many companies and teams worked on in-house platform approaches which were open-sourced as top-level Apache projects, or turned into tools built by vendors.</p>
<p>Examples in the ML ecosystem are:</p>
<pre><code>Apache Spark: a distributed batch computational platform processing large quantities of data that’s still widely used today

Apache Airflow: a scheduler for data engineering pipelines and data orchestration

Apache Lucene: a search engine. Elasticsearch is one of the most popular distributed and horizontally scalable search frameworks built on top of Apache Lucene.
</code></pre>
<p>Many of these tools were built under the assumptions of: we need to coordinate <a href="https://newsletter.vickiboykis.com/archive/logs-were-our-lifeblood-now-theyre-our-liability/">lots of small pieces of log data</a> flowing from our app&rsquo;s usage servers into a place where it can be aggregated for modeling, so we care about coordination of distributed systems.</p>
<p>In the world of GPU training and serving, we now have a different problem. We need to get everything onto the GPU as fast as possible so we can process it, because <a href="https://horace.io/brrr_intro.html">it&rsquo;s inefficient to have the GPU idling</a>, waiting for more data operations.</p>
<p>As a result, it makes sense to have special GPU clusters that we now need to manage <a href="https://github.com/stas00/ml-engineering/blob/master/insights/ai-battlefield.md#ml-engineers-hell">with specific considerations.</a></p>
<p><figure><img src="https://veekaybee.github.io/images/297787748-1c2a48a7-de84-4ce7-a05c-5587615042cc.png" width="600">
</figure>

from <a href="https://horace.io/brrr_intro.html">Making GPUs go BRRR</a></p>
<h1 id="tl-dr">TL; DR</h1>
<p>There is a lot more we can write for each of these categories and I hope to dive deeper on some of them in future posts. The bottom line is that a lot has changed in leading-edge ML applications over the past year as we&rsquo;ve moved compression from inside our enterprises to the internet at large.</p>
<p>We&rsquo;ve moved from smaller, business-specific models that perform specific tasks, to very large, generalist models that do one thing: text completion. Around these new models, we have a new set of metrics and operational and infrastructure concerns, particularly if we are using them as model artifacts (versus APIs). The interesting thing is that, now that we&rsquo;ve shifted from small to big, <a href="https://www.interconnects.ai/p/they-want-to-learn">the pendulum is again shifting</a> to smaller models that people are starting to fine-tune and run on their own, which will likely make everything I&rsquo;ve written here out of date in a month or two. One thing that remains constant is that we are still performing compression. The question is, where, and how much do we control it.</p>
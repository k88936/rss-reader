<div id="notion-article" class="mx-auto overflow-hidden "><main class="notion light-mode notion-page notion-block-a805bfb9820d435198709479a87c1f47"><div class="notion-viewport"></div><div class="notion-collection-page-properties"></div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-899e9a3059754756a7ea10c4046d6786" data-id="899e9a3059754756a7ea10c4046d6786"><span><div id="899e9a3059754756a7ea10c4046d6786" class="notion-header-anchor"></div><a class="notion-hash-link" href="#899e9a3059754756a7ea10c4046d6786" title="参考资料致谢"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">参考资料致谢</span></span></h2><div class="notion-text notion-block-18b64d79d21a4dc38cecbfe125e95d61">该文仅作学习目的，绝大部分的内容都从 <a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://lctt.github.io/translating">Linux.cn Translation Team (lctt.github.io)</a> 及 <a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://lfs.xry111.site/zh_CN/development/chapter03/introduction.html">3.1. 概述 (xry111.site)</a> 中摘抄复现，再次感谢 <a target="_blank" rel="noopener noreferrer" class="notion-link" href="http://LINUX.CN">LINUX.CN</a> TRANSLATION TEAM 对社区做的贡献。</div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-8ec190e2ea8f4a2e83901ff7d9ec4fef" data-id="8ec190e2ea8f4a2e83901ff7d9ec4fef"><span><div id="8ec190e2ea8f4a2e83901ff7d9ec4fef" class="notion-header-anchor"></div><a class="notion-hash-link" href="#8ec190e2ea8f4a2e83901ff7d9ec4fef" title="学习时间"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">学习时间</span></span></h2><div class="notion-text notion-block-016d83b714e9460ea3376c1de71acbcb">Jun 20, 2023<!-- --> - <!-- -->Jun 23, 2023<!-- --> </div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-f236c397ffb3414f94a7b4b3404772b7" data-id="f236c397ffb3414f94a7b4b3404772b7"><span><div id="f236c397ffb3414f94a7b4b3404772b7" class="notion-header-anchor"></div><a class="notion-hash-link" href="#f236c397ffb3414f94a7b4b3404772b7" title="目前进度"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">目前进度</span></span></h2><div class="notion-text notion-block-9377a345a1184e0cb5c8a1bd710c217c">Jun 20, 2023<!-- -->: 构建 LFS 至 GCC 部分</div><div class="notion-text notion-block-d6c57637d9b84ee58199818f1259714e">Jun 21, 2023<!-- -->: 发现所使用的 LFS Book 有点老，过时了，所以更换至新版的重新做一遍进度至第六章交叉编译临时工具</div><div class="notion-text notion-block-8190254fe56a47f9b11629686a0b158a">Jun 22, 2023<!-- -->: 到其他临时工具Gettext第一个（7.7）</div><div class="notion-text notion-block-41839f55d9af40c189a22ad1b56ecc0a">Jun 23, 2023<!-- -->: 跳过了一些软件包的编译安装，成功开机！</div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-854fa09d8d1247dc913ad8d5306c4667" data-id="854fa09d8d1247dc913ad8d5306c4667"><span><div id="854fa09d8d1247dc913ad8d5306c4667" class="notion-header-anchor"></div><a class="notion-hash-link" href="#854fa09d8d1247dc913ad8d5306c4667" title="主机环境准备"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">主机环境准备</span></span></h2><div class="notion-text notion-block-07387c3e612c418a9fd17cfa53733e6b">本次还没深入到后面，根据U2说明，这里可以先不分区，并且先使用lxc来进行实验。为了实验可中断与恢复，这里使用 tmux 来进行管理，按下Ctrl+b，d即可暂时退出，使用 tmux attach 即可恢复。</div><div class="notion-text notion-block-2d3d128f91cb4adf852799c63df53728">lxc 这里使用了 Tari 的 arch-playground 来进行实验，感谢 U2 和 Tari 的支持。</div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-81830da860b44504b892ecbf9911b941" data-id="81830da860b44504b892ecbf9911b941"><span><div id="81830da860b44504b892ecbf9911b941" class="notion-header-anchor"></div><a class="notion-hash-link" href="#81830da860b44504b892ecbf9911b941" title="LFS环境准备"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">LFS环境准备</span></span></h2><div class="notion-text notion-block-680bc39583dc449eb06be2acbd950a7a">这里的LFS使用的是Tari家的 Arch-Playground，暂时不创建新分区，将目录放到 /mnt/lfs，并新建环境变量 LFS=/mnt/lfs</div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-e171f2d9eeda4b41875eeed1a307654d" data-id="e171f2d9eeda4b41875eeed1a307654d"><span><div id="e171f2d9eeda4b41875eeed1a307654d" class="notion-header-anchor"></div><a class="notion-hash-link" href="#e171f2d9eeda4b41875eeed1a307654d" title="创建目录环境准备"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">创建目录环境准备</span></span></h3><div class="notion-text notion-block-919b2ab762024874ba5e89d5c03fb4f9">下载之前先创建目录 mkdir -v $LFS/sources ，并且开启目录的写权限和粘滞模式 <code class="notion-inline-code">chmod -v a+wt $LFS/sources</code> 。这里使用粘滞模式是为了确保在构建过程中所需的临时文件和目录不会被意外删除或更改，多个用户都对某个目录有写权限，但只有文件的所有者能够删除文件。</div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-162e5d3b9c9f4a9fb9d6847ae6b9d740" data-id="162e5d3b9c9f4a9fb9d6847ae6b9d740"><span><div id="162e5d3b9c9f4a9fb9d6847ae6b9d740" class="notion-header-anchor"></div><a class="notion-hash-link" href="#162e5d3b9c9f4a9fb9d6847ae6b9d740" title="下载wget列表"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">下载wget列表</span></span></h3><div class="notion-text notion-block-60cbb38bd748469aa94bd5e59ebe4a08">执行 <code class="notion-inline-code">wget </code><code class="notion-inline-code"><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://lfs.xry111.site/zh_CN/development/wget-list-sysv">https://lfs.xry111.site/zh_CN/development/wget-list-sysv</a></code> 下载LFS所需的文件列表，然后执行 <code class="notion-inline-code">wget --input-file=wget-list-sysv --continue --directory-prefix=$LFS/sources</code> 来下载这些文件。</div><h4 class="notion-h notion-h3 notion-h-indent-2 notion-block-a4e5fe45d9204a45b33a0312b62a1a2f" data-id="a4e5fe45d9204a45b33a0312b62a1a2f"><span><div id="a4e5fe45d9204a45b33a0312b62a1a2f" class="notion-header-anchor"></div><a class="notion-hash-link" href="#a4e5fe45d9204a45b33a0312b62a1a2f" title="校验md5"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">校验md5</span></span></h4><div class="notion-text notion-block-d70f315d863147f78528bc29df9eca79">下载md5sums文件  ，执行</div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-5b59f5fdfbd74e298eadfedd54e8a072" data-id="5b59f5fdfbd74e298eadfedd54e8a072"><span><div id="5b59f5fdfbd74e298eadfedd54e8a072" class="notion-header-anchor"></div><a class="notion-hash-link" href="#5b59f5fdfbd74e298eadfedd54e8a072" title="创建目录布局"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">创建目录布局</span></span></h3><div class="notion-text notion-block-7667dc85efa5482daca83db30f35b298">为 LFS 分区创建 /etc, /var, /usr/bin, /usr/lib, /usr/sbin</div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-fe9407a98f7f468b941bed562664022d" data-id="fe9407a98f7f468b941bed562664022d"><span><div id="fe9407a98f7f468b941bed562664022d" class="notion-header-anchor"></div><a class="notion-hash-link" href="#fe9407a98f7f468b941bed562664022d" title="创建编译后安装的软件目录"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">创建编译后安装的软件目录</span></span></h3><div class="notion-text notion-block-ace7ee4dc3594e94a506f6598404b9ee">运行 <code class="notion-inline-code">mkdir -v $LFS/tools</code> ，执行 <code class="notion-inline-code">ln -sv $LFS/tools /</code> 将这个目录创建为根目录的符号链接</div><div class="notion-text notion-block-6cca01785db34f2c9199af204bd22b91">这使得宿主机根目录下的工具链总是指向 /tools 。可以确保在 LFS 构建过程中，系统能够正确地找到并使用所需的构建工具，从而顺利进行构建操作。</div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-e2a9ca0c706640c5ab9725930427c51a" data-id="e2a9ca0c706640c5ab9725930427c51a"><span><div id="e2a9ca0c706640c5ab9725930427c51a" class="notion-header-anchor"></div><a class="notion-hash-link" href="#e2a9ca0c706640c5ab9725930427c51a" title="添加LFS用户"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">添加LFS用户</span></span></h3><div class="notion-text notion-block-dd6f9e53615b425c883ce036da71d47a">为了防止清理大师，这里添加一个lfs用户组/用户。在LFS书本上使用的方法是</div><div class="notion-text notion-block-c1f4162ad01a4dab9ed61ec8ffeda588">-k /dev/null 是为了使用户目录不包含任何默认配置文件，确保用户目录干净、空白</div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-54b163d5e121494ca4b4569542c1004a" data-id="54b163d5e121494ca4b4569542c1004a"><span><div id="54b163d5e121494ca4b4569542c1004a" class="notion-header-anchor"></div><a class="notion-hash-link" href="#54b163d5e121494ca4b4569542c1004a" title="设置LFS用户下的环境"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">设置LFS用户下的环境</span></span></h3><div class="notion-text notion-block-a3245c6a6f3e4e9fb0db234f42b9be9e">运行</div><div class="notion-text notion-block-49e4c20035df467ea9e2a9c8dc0f85d0">为lfs用户创建 bash_profile ，排除其他不安全的因素。</div><div class="notion-text notion-block-a542baca4e184d9b8271e265e64cdc33">运行</div><div class="notion-text notion-block-0a508f4ae7a74cceb1868c37a543680c">我在使用的 Arch 环境有 /etc/bash.bashrc ，有可能会干扰LFS软件包的构建，可以先移到一边。</div><div class="notion-text notion-block-ffcf3e05f12f49cfb855d8b2c739c0d2">执行 source ~/.bash_profile 准备环境</div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-74c2cebfb9664b278e5e22e4111f14da" data-id="74c2cebfb9664b278e5e22e4111f14da"><span><div id="74c2cebfb9664b278e5e22e4111f14da" class="notion-header-anchor"></div><a class="notion-hash-link" href="#74c2cebfb9664b278e5e22e4111f14da" title="设置并行构建减少时间"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">设置并行构建减少时间</span></span></h3><div class="notion-text notion-block-f7c8f081736f41ef9d55011e531f08dc">TARI 所使用的环境是一颗 Intel(R) Core(TM) i7-10700F ，它拥有十六颗核心，所以可以设定16个同时运行的进程来减少构建时间。</div><div class="notion-text notion-block-1a0003eefd7f465ca007f446aa5473eb">可设置 <code class="notion-inline-code"><b>export MAKEFLAGS=&#x27;-j16&#x27;</b></code><b> 或 </b><code class="notion-inline-code"><b>make -j16</b></code></div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-fdd02d160e134401a9d915939ed19914" data-id="fdd02d160e134401a9d915939ed19914"><span><div id="fdd02d160e134401a9d915939ed19914" class="notion-header-anchor"></div><a class="notion-hash-link" href="#fdd02d160e134401a9d915939ed19914" title="构建临时系统"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">构建临时系统</span></span></h2><div class="notion-text notion-block-5b04a25dca8340a9b78280316a859c7e">在这一章节中，编译出来的文件都将放在 $LFS/tools ，因为不想让它影响 $LFS/sources</div><div class="notion-text notion-block-fd6f6e1c43814719aa23e30a175951d2">这里要求先安装Binutils，能获得必要的二进制工具，例如汇编器（as）和链接器（ld），来支持后面的编译过程。然后安装GCC编译器，GCC的构建过程将使用Binutils提供的工具来生成可执行程序。经过第一次gcc的configure，我们能看到gcc配置文件所使用的是/tools下的工具链。</div><div class="notion-text notion-block-fdcace8560bf485ba31f8512368df39e">然后安装净化的Linux API头文件和Glibc</div><div class="notion-text notion-block-bd83d95377f44a608eaff925f2877731"><a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://lctt.github.io/LFS-BOOK/lfs-sysv/chapter05/generalinstructions.html">5.3. 通用编译指南 (lctt.github.io)</a></div><div class="notion-text notion-block-60b2ec09084d4aa4ab8f1879031395e3">这里是相关的一些注意事项，包括正确设置LFS环境变量，查看sh、awk、yacc（yacc这里有可能是一个脚本，grep一下bison看看有没有就行）是否为指定符号链接，刚刚下的源文件是不是在 /mnt/lfs/sources 并且cd过去，而且在lfs用户中</div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-ebfdd14498074ae4bf88ccb8a40b2eb8" data-id="ebfdd14498074ae4bf88ccb8a40b2eb8"><span><div id="ebfdd14498074ae4bf88ccb8a40b2eb8" class="notion-header-anchor"></div><a class="notion-hash-link" href="#ebfdd14498074ae4bf88ccb8a40b2eb8" title="安装编译Binutils"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">安装编译Binutils</span></span></h3><div class="notion-text notion-block-6e4bea0f051a4b71baf26c8b6f50a84c">解压Binutils tar -xvf binutils-2.40.tar.xz ，切换进解压目录后创建一个build文件夹并切换进去，执行configure生成makefile</div><div class="notion-text notion-block-c63a92ef6e604466bd0a0b2028b50fa0">然后继续执行 make 来编译软件包</div><div class="notion-text notion-block-c3d60c54770a49fd844cdce2425eb11c">安装软件包 make install</div><div class="notion-text notion-block-0f7f223f9057463bace632e7281202bd">删除解压出来的目录 rm -rf binutils-2.40</div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-549cb884ee464eda8695551520cdb231" data-id="549cb884ee464eda8695551520cdb231"><span><div id="549cb884ee464eda8695551520cdb231" class="notion-header-anchor"></div><a class="notion-hash-link" href="#549cb884ee464eda8695551520cdb231" title="安装编译gcc"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">安装编译gcc</span></span></h3><div class="notion-text notion-block-8fdb54a1976c46bdab873a8e3d9798cd">首先先解压gcc目录，顺便需要先安装编译GMP、MPFR、MPC<a class="notion-link" href="/a805bfb9820d435198709479a87c1f47#9f4e4278c0c1476a85f6b03d899a90db">[?]</a></div><details class="notion-toggle notion-block-a4167f06cd474111916675921eb8a0eb"><summary>更新后删除</summary><div><div class="notion-text notion-block-082c22af9efa42ca8f1329a9f6e0d9d3">根据原文描述，这段代码的作用时为了确保GCC编译器使用 /tools 目录中的工具链而不是宿主机上的工具链，以便在构建LFS系统时正确地编译和链接软件包。</div><div class="notion-text notion-block-caba84c941e14e44acf99f725270c032">执行后会进行以下几个操作</div></div></details><div class="notion-text notion-block-ed65a6f786854de2900d87fbc4d95838">然后执行下面这个（虽然本机本来就是在x86_64上跑的，case了好像也没啥用，估计是从原来的代码上摘下来的？）</div><div class="notion-text notion-block-ff0e521cf77142fc910a6adda8525203">新建一个目录build编译gcc，然后切换进去，配置选项</div><div class="notion-text notion-block-29166c42548c4e0988f53ca2f10e90fa">然后进行 make 和 make install，首次编译不需要进行测试，因为第一遍编译的程序很快就会被取代。(第一次更新也就是所谓的，Host是本机，但是生成的玩意是给LFS用的）</div><div class="notion-text notion-block-b53b2403e4904e3992d6851dd24dd91e">这里我第一次make有一个卡了很久，不知道原因，删掉重新编译就好了</div><div class="notion-text notion-block-cdcd3c3a57514757945dc15210c6b712">然后合并 limitx.h glimits.h limity.h 创建一个完整的limits.h内部头文件(这个文件定义了一些基本的系统限制，如整数类型的最大值和最小值，字符类型的位数，指针类型的大小等等)，具体原因见<a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://lfs.xry111.site/zh_CN/development/chapter05/gcc-pass1.html">[?]</a></div><div class="notion-text notion-block-a8bb3f6abfc441d0b51a23b1fba5df3b">删除 gcc 文件夹</div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-22b4d6fe557c41b59bc362995d11db9b" data-id="22b4d6fe557c41b59bc362995d11db9b"><span><div id="22b4d6fe557c41b59bc362995d11db9b" class="notion-header-anchor"></div><a class="notion-hash-link" href="#22b4d6fe557c41b59bc362995d11db9b" title="安装 Linux API 头文件"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">安装 Linux API 头文件</span></span></h3><blockquote class="notion-quote notion-block-c5466465828d4b2097c539cbe13f0476"><div>Linux API 是操作系统提供的一组编程接口，它包含了许多与操作系统相关的函数、变量和宏等，可以帮助程序员编写能够与操作系统交互的程序。例如，Linux API 中包含了许多文件操作函数，如 open()、read()、write() 等等，可以帮助程序员在程序中进行文件的读写操作。在 Linux 系统上进行 C 语言编程时，需要使用 Linux API 头文件，以便在程序中调用操作系统提供的接口。</div></blockquote><div class="notion-text notion-block-d61128a367ca4a88a288c066530b37e2">解压 linux-6.3.8.tar.xz，切换目录。</div><div class="notion-text notion-block-049576a41a5c426d9758fb0a361ab99b">执行 make mrproper，删除所有生成的目标文件和中间文件、内核镜像文件、配置文件、标签文件和依赖关系文件，确保没有遗留的陈旧文件</div><div class="notion-text notion-block-9f6794c2adec45af8d13adf93cd85f87">执行 make headers，在交叉编译工具链中生成一些头文件，之后会复制到LFS系统中</div><div class="notion-text notion-block-82665d7a6afd482b8dfffe3e587ec251">删除linux-6.3.8文件夹</div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-787fa50c75934f8bbf05c3a909f6531e" data-id="787fa50c75934f8bbf05c3a909f6531e"><span><div id="787fa50c75934f8bbf05c3a909f6531e" class="notion-header-anchor"></div><a class="notion-hash-link" href="#787fa50c75934f8bbf05c3a909f6531e" title="安装 Glibc"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">安装 Glibc</span></span></h3><blockquote class="notion-quote notion-block-e3ce1499ad9c424e8c052f7b46b1143f"><div>Glibc 是 GNU C 库的缩写，是一组与 C 语言编程相关的库函数和头文件。它提供了许多常用的函数和数据结构，如字符串操作函数、数学函数、进程管理函数等等，可以帮助程序员编写更加高效、可靠的程序。在 Linux 系统上进行 C 语言编程时，需要安装 Glibc 库和头文件，以便在程序中使用这些库函数。</div></blockquote><div class="notion-text notion-block-13c64cae06314b47b723be74f170963d">哇，是熟悉的老爹（ld），之前在尝试LD_PRELOAD的时候就见过这玩意，它包含了一些共享库的东西，比如我们常用的printf都得从这拿，现在我们要将它编译出来。</div><div class="notion-text notion-block-d2cd76e431b745a7b724157aa5e032e5">执行以下内容，使ld链接到 $LFS/lib64 ，同时链接到文件 <code class="notion-inline-code"><b>$LFS/lib64/ld-lsb-x86-64.so.3</b></code><b> </b></div><div class="notion-text notion-block-2137ad690eb74f20a0325c34976c6b93">应用一个补丁到Glibc源代码中，以使得Glibc程序在FHS（Filesystem Hierarchy Standard，Linux文件系统层次结构标准）兼容的位置存放运行时数据。</div><div class="notion-text notion-block-2ac2cccc429e48118f3ee91fd0163440">在一些旧版的Glibc程序中，会使用与FHS不兼容的/var/db目录存放它们的运行时数据，这违反了FHS的规范。为了解决这个问题，需要应用一个名为&quot;glibc-2.37-fhs-1.patch&quot;的补丁，该补丁会修改Glibc源代码中的一些文件，以使得Glibc程序可以在FHS标准中定义的位置存放运行时数据。</div><div class="notion-text notion-block-a097e603bc4c4ff0a99118195c39cc81">这个patch是给源代码patch的。</div><div class="notion-text notion-block-efd3659e077142b88f4282c8bd1e0ff4">然后新建一个build文件夹，再cd进去</div><div class="notion-text notion-block-6f5cd0a769104032b76a300af00e9bb9">设置，使 ldconfig 和 sln 安装到 /usr/sbin</div><div class="notion-text notion-block-b42cd6fe419f4b9aa22133b997e93b10">准备安装 glibc</div><div class="notion-text notion-block-0d4fde3e88c142a8b00e73babe0901b4">然后编译出错，因为没有 Python （阿哲，编译glibc竟然会用到python？？）</div><div class="notion-text notion-block-99d19720b527416991b49acd238a4249">然后make，make完以后 <code class="notion-inline-code"><b>make DESTDIR=$LFS install</b></code></div><div class="notion-text notion-block-c57cc9b8f8ba4c70a1a0e037d0bd9bca">(这里知识点来了，为什么 DESTDIR 会和 prefix 不一样？可以见问题9）</div><div class="notion-text notion-block-c225256742cc4895894d9c46cac73d4f">执行<code class="notion-inline-code"><b>sed &#x27;/RTLDLIST=/s@/usr@@g&#x27; -i $LFS/usr/bin/ldd</b></code><b> </b>，替换掉 RTLDLIST 的 /usr </div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-9642a5a1c2404337921194ffec9e0e68" data-id="9642a5a1c2404337921194ffec9e0e68"><span><div id="9642a5a1c2404337921194ffec9e0e68" class="notion-header-anchor"></div><a class="notion-hash-link" href="#9642a5a1c2404337921194ffec9e0e68" title="确认新工具链工作正常"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">确认新工具链工作正常</span></span></h3><div class="notion-text notion-block-e069be8275eb485b906773d77ec72e8b">按照 LFS Book 的流程，编写一个简单的C语言程序，编译并查看其编译使用的解释器</div><div class="notion-text notion-block-998c0337e20442babff2e50c170fdd1e">这里 $LFS_TGT-gcc 经过环境变量替换后实际上是 x86_64-lfs-linux-gnu-gcc ，可以直接执行，因为之前修改过PATH指向tools上，然后会吐出一个 a.out ，用readelf 读取一下看看正不正常就行了</div><div class="notion-text notion-block-3c34540b53d746ab8d38f2c8a5823b7e">完事删除一下生成的文件</div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-3001a24528f34d91b14506ae9d7e2f0f" data-id="3001a24528f34d91b14506ae9d7e2f0f"><span><div id="3001a24528f34d91b14506ae9d7e2f0f" class="notion-header-anchor"></div><a class="notion-hash-link" href="#3001a24528f34d91b14506ae9d7e2f0f" title="安装Libstdc++"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">安装Libstdc++</span></span></h3><blockquote class="notion-quote notion-block-400ddb9c26d64ae4b2cb7ff3f256fb8b"><div>Libstdc++ 是 GNU C++ 标准库，它包含了一系列的 C++ 标准库函数和类。在 LFS 中，Libstdc++ 主要作用是提供 C++ 标准库的支持，使得 LFS 系统能够编译和运行 C++ 程序。
在编译 C++ 程序时，编译器会使用 C++ 标准库中的一些函数和类。如果没有正确的 C++ 标准库支持，就会导致编译错误或运行时错误。因此，在构建 LFS 系统时，需要安装 Libstdc++ 库，以便提供 C++ 标准库的支持。同时，还需要在交叉编译器中设置正确的 Libstdc++ 路径，以便在编译 C++ 程序时正确地链接标准库。</div></blockquote><div class="notion-text notion-block-c8571caab48748f189458085de7d214c">解压 gcc 压缩包（对，这里是gcc，不是单独的 libstdc++），然后创建构建目录build并切换，执行 configure 准备编译</div><div class="notion-text notion-block-40932a78aa084c8c941a58838f4b948f">然后就是经典的 make 和 make DESTDIR=$LFS install</div><div class="notion-text notion-block-6b3efcd007a8478a886dd3d41068113b">这里需要移除对交叉编译有害的libtool文档文件，也不算有害吧，就是用不到，原因见问题15</div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-5fbbea44bf6c4c559c20ba7eb1b71601" data-id="5fbbea44bf6c4c559c20ba7eb1b71601"><span><div id="5fbbea44bf6c4c559c20ba7eb1b71601" class="notion-header-anchor"></div><a class="notion-hash-link" href="#5fbbea44bf6c4c559c20ba7eb1b71601" title="交叉编译临时工具"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">交叉编译临时工具</span></span></h2><div class="notion-text notion-block-9cbaca73ee1f4de5a27c87a9a3fe86af">这里安装一些工具，比如M4，bash之类的，这里就按照LFS Book的教程一个个安装就行了。</div><div class="notion-text notion-block-2f899a98914543f4aa856ad10b376f74">coreutils - 安装类似 ls if echo mv cp这种常见指令</div><div class="notion-text notion-block-36e020f4244d43e1987a6a45042974fb">findutils - find 指令</div><div class="notion-text notion-block-7fd06614ebb94d4ba100e1c2fea7daf0">file - 用于确定文件类型，比如确定是一个普通的文本文件，还是一个shell文件，还是一个elf文件</div><div class="notion-text notion-block-b6f2c1211b1c491b8a4af33ccc6d84ee">同时还要二次安装 binutils和gcc，这里注意参数的变化，包括prefix的变化以及with-sysroot的变化，一开始都是 $LFS 目录下的，后面直接不设置了。容易产生误解的是gcc的 with-build-sysroot 的变化，注意这个参数虽然还是 $LFS 下的，但是它代表的是编译时使用的目录，编译后我也不会硬编码进gcc，也就是编译后到底读哪就跟这个参数没有关系了。</div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-5ff147e4f6d7464b92f32304e5bef869" data-id="5ff147e4f6d7464b92f32304e5bef869"><span><div id="5ff147e4f6d7464b92f32304e5bef869" class="notion-header-anchor"></div><a class="notion-hash-link" href="#5ff147e4f6d7464b92f32304e5bef869" title="进入chroot并构建其他工具"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">进入chroot并构建其他工具</span></span></h2><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-614db2d27e2540e0a5a75816deec7c77" data-id="614db2d27e2540e0a5a75816deec7c77"><span><div id="614db2d27e2540e0a5a75816deec7c77" class="notion-header-anchor"></div><a class="notion-hash-link" href="#614db2d27e2540e0a5a75816deec7c77" title="将文件夹权限从lfs给回root"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">将文件夹权限从lfs给回root</span></span></h3><div class="notion-text notion-block-32f99b901b174d38b2e3cc3a755b34d2">具体原因见 问题20</div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-158cebf5c2e944d398d14b849d66378d" data-id="158cebf5c2e944d398d14b849d66378d"><span><div id="158cebf5c2e944d398d14b849d66378d" class="notion-header-anchor"></div><a class="notion-hash-link" href="#158cebf5c2e944d398d14b849d66378d" title="准备虚拟内核文件系统"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">准备虚拟内核文件系统</span></span></h3><div class="notion-text notion-block-a4c5bb8b23674338a9e6ef6382540322">目前我们构建的LFS系统的目录是这样的</div><div class="notion-text notion-block-c686aa2e5c004f7381a802019ca278ad">可以发现，我们使用的什么 /dev /proc 之类的文件夹都还没有呢，所以我们要先创建并挂载</div><div class="notion-text notion-block-c2d77941779b42d69a2d75e0ebfcd6f5">还要瞅瞅 /dev/shm ，挂载一个tmpfs。我这里shm不是一个符号链接，只是一个普通的文件夹</div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-4b8dc8ffcc004ab898e176d353d2c709" data-id="4b8dc8ffcc004ab898e176d353d2c709"><span><div id="4b8dc8ffcc004ab898e176d353d2c709" class="notion-header-anchor"></div><a class="notion-hash-link" href="#4b8dc8ffcc004ab898e176d353d2c709" title="进入 chroot 环境"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">进入 chroot 环境</span></span></h3><div class="notion-text notion-block-c68929c230404e2a920c1238eb0b6367">进来以后发现 UID 为0，但是提示 (lfs chroot) I have no name!:/ ，且运行 whoami 会有 whoami: cannot find name for user ID 0: No such file or directory ，这是因为 /etc/passwd 还没创建 </div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-f4970a3e789547b282dab8af1388c00e" data-id="f4970a3e789547b282dab8af1388c00e"><span><div id="f4970a3e789547b282dab8af1388c00e" class="notion-header-anchor"></div><a class="notion-hash-link" href="#f4970a3e789547b282dab8af1388c00e" title="创建必要的目录"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">创建必要的目录</span></span></h3><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-24098860df3741c69e16af7a878f1a69" data-id="24098860df3741c69e16af7a878f1a69"><span><div id="24098860df3741c69e16af7a878f1a69" class="notion-header-anchor"></div><a class="notion-hash-link" href="#24098860df3741c69e16af7a878f1a69" title="创建必要的文件和符号链接"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">创建必要的文件和符号链接</span></span></h3><div class="notion-text notion-block-9b67fec2ab3c48369bd48d95929a0ff7">这里 /proc/self/mounts 查看了一下，发现没有根目录选项，应该按照官方教程是有的，但是由于我是直接在lxc上，也没有分区，但是U2说不影响.jpg</div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-7c798cfc8e4b49c3b9f0ae4c97684ae5" data-id="7c798cfc8e4b49c3b9f0ae4c97684ae5"><span><div id="7c798cfc8e4b49c3b9f0ae4c97684ae5" class="notion-header-anchor"></div><a class="notion-hash-link" href="#7c798cfc8e4b49c3b9f0ae4c97684ae5" title="构建一些其他工具"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">构建一些其他工具</span></span></h3><div class="notion-text notion-block-13c689fb1569473a8008f7d3797f314b">从这里开始，编译一些工具就不再需要在外面用lfs来编译了，而只需要chroot进去用lfs的环境来编译即可。由于软件包太多了，下面直接看教程，写得写死人。</div><div class="notion-text notion-block-49bac33aba11419c974ab980c0de6e4a">cd到/sources，然后解压，按照configure后make的流程来走。</div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-64784836286b44e8bbf235f8d1131f11" data-id="64784836286b44e8bbf235f8d1131f11"><span><div id="64784836286b44e8bbf235f8d1131f11" class="notion-header-anchor"></div><a class="notion-hash-link" href="#64784836286b44e8bbf235f8d1131f11" title="清理并备份系统"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">清理并备份系统</span></span></h3><div class="notion-text notion-block-bc7665f5a9dc423cab5c1c303aa5f501">删除临时的工具和文档</div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-5e9b393481e243238b0e439fddf8308a" data-id="5e9b393481e243238b0e439fddf8308a"><span><div id="5e9b393481e243238b0e439fddf8308a" class="notion-header-anchor"></div><a class="notion-hash-link" href="#5e9b393481e243238b0e439fddf8308a" title="迁移环境"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">迁移环境</span></span></h2><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-742993e722574373bd099191ee5f9ae7" data-id="742993e722574373bd099191ee5f9ae7"><span><div id="742993e722574373bd099191ee5f9ae7" class="notion-header-anchor"></div><a class="notion-hash-link" href="#742993e722574373bd099191ee5f9ae7" title="转移目录"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">转移目录</span></span></h3><div class="notion-text notion-block-7c4457b862d04fef8b805156113f6d26">由于后面越用越发现 LXC 已经无法满足需求了，所以决定迁移到正常的虚拟机上石笋</div><div class="notion-text notion-block-54cde2b0a3584a6c95c479ff1762cc68">搭建一个 ubuntu-playground，然后</div><div class="notion-row"><a target="_blank" rel="noopener noreferrer" class="notion-bookmark notion-block-04e5319b886f4da1b5943de1abef9f85" href="https://pages.gp.idealisan.com/post/shi-yong-tar-da-bao-bei-fen-linux-xi-tong/"><div><div class="notion-bookmark-title">使用tar打包备份linux系统 | Idealisan Pages of Tech</div><div class="notion-bookmark-description">使用tar打包备份linux系统 为什么使用tar 注意，使用tar而不要使用zip打包，因为tar可以选择保留linux的文件属性，包括用户权限信息等，这对于系统备份来讲很重要。 四个必备参数和一个可选参数 使用tar打包备份linux系...</div><div class="notion-bookmark-link"><div class="notion-bookmark-link-icon"><img src="https://www.notion.so/image/https%3A%2F%2Fpages.gp.idealisan.com%2Ffavicon.ico%3Fv%3D1670083680323?table=block&amp;id=04e5319b-886f-4da1-b594-3de1abef9f85&amp;t=04e5319b-886f-4da1-b594-3de1abef9f85" alt="使用tar打包备份linux系统 | Idealisan Pages of Tech" loading="lazy" decoding="async"/></div><div class="notion-bookmark-link-text">https://pages.gp.idealisan.com/post/shi-yong-tar-da-bao-bei-fen-linux-xi-tong/</div></div></div></a></div><div class="notion-text notion-block-fa543302bc324ce997a35c24fd653a72">将刚才的lfs系统打包</div><div class="notion-text notion-block-181283bb442f464faae0ea5e9a07ae83">chroot 进去以后</div><div class="notion-text notion-block-b91d353de69e43fbb744982e1672ead1">转移文件后在目标系统</div><div class="notion-text notion-block-359772ab49174b8d92c6dbccca31835d">tar -xvpzf system_backup.tar.gz -C /mnt/lfs</div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-bb1641c6845e40b5a3d2cc1086058529" data-id="bb1641c6845e40b5a3d2cc1086058529"><span><div id="bb1641c6845e40b5a3d2cc1086058529" class="notion-header-anchor"></div><a class="notion-hash-link" href="#bb1641c6845e40b5a3d2cc1086058529" title="重新分区"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">重新分区</span></span></h3><div class="notion-text notion-block-92a23c1ab5ea4433b8099e76f5308a19">新的硬盘在 /dev/sdb ，使用fdisk重新分区，之前是给 /boot/efi 200M，剩下的容量给根目录，这里也这么办。然后使用 mkfs.fat -F32 /dev/sdb1 格式化EFI分区，使用 mkfs.ext4 /dev/sdb2 格式化根目录分区</div><div class="notion-text notion-block-bb547908d44648fa91b34d1d7347264b">重新创建 /mnt/lfs，然后挂载 </div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-b5058f06e8cf43a6b12a081b63dbbe63" data-id="b5058f06e8cf43a6b12a081b63dbbe63"><span><div id="b5058f06e8cf43a6b12a081b63dbbe63" class="notion-header-anchor"></div><a class="notion-hash-link" href="#b5058f06e8cf43a6b12a081b63dbbe63" title="使LFS系统可引导"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">使LFS系统可引导</span></span></h2><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-e8c78f7bfb2d4bd2aa1dd4a053bc095e" data-id="e8c78f7bfb2d4bd2aa1dd4a053bc095e"><span><div id="e8c78f7bfb2d4bd2aa1dd4a053bc095e" class="notion-header-anchor"></div><a class="notion-hash-link" href="#e8c78f7bfb2d4bd2aa1dd4a053bc095e" title="确定 /etc/fstab"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">确定 /etc/fstab</span></span></h3><div class="notion-text notion-block-186fd5ffa54344bbb04d09e9bee448dc">由于在上面分好区了，直接写入 /etc/fstab 就行了</div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-e96f26a9fb2d4224bda34cfbc9619200" data-id="e96f26a9fb2d4224bda34cfbc9619200"><span><div id="e96f26a9fb2d4224bda34cfbc9619200" class="notion-header-anchor"></div><a class="notion-hash-link" href="#e96f26a9fb2d4224bda34cfbc9619200" title="安装内核"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">安装内核</span></span></h3><div class="notion-text notion-block-fffb2a04cedc47afbbb7f25885644738">切换到 linux-6.3.8 文件夹，必须先安装 Flex, bc, libelf(→zlib),openssl 。执行 make mrproper 清除不必要文件，然后通过界面 make menuconfig 来设置界面（很人性化了可以说是）</div><div class="notion-text notion-block-b8db427ca42c4ee8be625d2ff5015eff">grub(→e2fsprogs→pkg-config→texinfo→xorriso</div><div class="notion-text notion-block-9c4acc9512814f02b8c6d30750a345e8">root密码（expect→tcl→shadow)</div><div class="notion-text notion-block-f269dbee9de0493d88a80f08f1019965">其实东西也不用全部构建，只要关键部分构建了就行了，就是找关键部分有点折磨</div><div class="notion-text notion-block-143c11a1c1954fab8b5d8117810a3246">下面是根据grub教程修改的部分，主要修改了uuid和partuuid</div><h3 class="notion-h notion-h2 notion-h-indent-1 notion-block-e13263fb86824eca9853febc81250e71" data-id="e13263fb86824eca9853febc81250e71"><span><div id="e13263fb86824eca9853febc81250e71" class="notion-header-anchor"></div><a class="notion-hash-link" href="#e13263fb86824eca9853febc81250e71" title="LFS，启动！"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">LFS，启动！</span></span></h3><div class="notion-text notion-block-16eb0e5bbca14061b84bb35d296b3164">开放世界（指自己下载源码编译），烧鸡（指编译CPU爆棚），椅子可以坐（指编译这玩意一坐就是一天）</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-bd151e9019cc48f19ec75095cb864345"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:cover" src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F17cdca24-6b95-4c05-9322-6dbec8a9044d%2FUntitled.png?table=block&amp;id=bd151e90-19cc-48f1-9ec7-5095cb864345&amp;t=bd151e90-19cc-48f1-9ec7-5095cb864345&amp;width=1280&amp;cache=v2" alt="notion image" loading="lazy" decoding="async"/></div></figure><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-cf46096a72174c8faf445b5da9537f43"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:cover" src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F564cffbb-2a8d-46b0-bef2-27e74ae30b3c%2FUntitled.png?table=block&amp;id=cf46096a-7217-4c8f-af44-5b5da9537f43&amp;t=cf46096a-7217-4c8f-af44-5b5da9537f43&amp;width=1280&amp;cache=v2" alt="notion image" loading="lazy" decoding="async"/></div></figure><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-ed9977052606428387483b064bbd6045" data-id="ed9977052606428387483b064bbd6045"><span><div id="ed9977052606428387483b064bbd6045" class="notion-header-anchor"></div><a class="notion-hash-link" href="#ed9977052606428387483b064bbd6045" title="自问自答"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">自问自答</span></span></h2><div class="notion-text notion-block-f8c50e3b4b3244a0ba3287d7f7be6734">以下问题为进行实验的时候提出的，有些答案通过 ChatGPT 总结后贴上。</div><ol start="1" class="notion-list notion-list-numbered notion-block-7de4d1f2a54748a38a1a6d0ba7e59f1f"><li>问：一个纯64位的系统是不能运行32位应用程序的吗？为什么现代化的系统都可以在64位系统运行32位程序？</li><ol class="notion-list notion-list-numbered notion-block-7de4d1f2a54748a38a1a6d0ba7e59f1f"><div class="notion-text notion-block-5ca860b7116d4322af188483e650d94b">答：因为有兼容层。比如装扩展的时候，有一些是x  xx-32bit或者xxx-i386</div></ol></ol><ol start="2" class="notion-list notion-list-numbered notion-block-3407bf07621a412fa0280460b0eb6784"><li>问：设置LFS用户下的环境章节下，<b>LFS_TGT=$(uname -m)-lfs-linux-gnu 的作用是什么？</b></li><ol class="notion-list notion-list-numbered notion-block-3407bf07621a412fa0280460b0eb6784"><div class="notion-text notion-block-03d86bdafed14f9191af8cfd6e3010fe">答：为主机设置编译三元组，什么是编译三元组下面会解释。</div></ol></ol><ol start="3" class="notion-list notion-list-numbered notion-block-e598ea448d2e477789cbd1f3667b760d"><li>问：为什么Binutils和GCC需要经过两次编译？</li><ol class="notion-list notion-list-numbered notion-block-e598ea448d2e477789cbd1f3667b760d"><div class="notion-text notion-block-6c67009571724ddcbc730032f8926994">答：为了创建一个独立的、自包含的工具链环境。在开始构建LFS系统时，已经有了一个主机系统作为基础，它安装了自己的Bintuils和GCC。但是，构建LFS时，需要一个全新的系统，包括Binutils和GCC，二次编译是为了确保LFS系统中使用的Binutils和GCC是专门为了LFS构建的，与主机系统的工具链相互独立，<span class="notion-red"><span class="notion-inline-underscore"><b>可以确保LFS系统的构建过程和最终生成的软件包与主机系统的环境无关</b></span></span>，避免因主机系统的配置和版本差异而导致的不一致性或问题。</div><div class="notion-text notion-block-0d7ec66d0d6248a7a29813641eedef3a">这里假设说，目标lfs是 aarch64 架构的，假设我自己的机器上本身只有一个 host=x86_64, target=x86_64 ，那我就没办法生成一个 aarch64 架构的编译器，所谓的编译器就是：我跑在host上，我要生成target的目标程序，所以我的<span class="notion-red"><span class="notion-inline-underscore"><b>第一步工作就是要生成一个能跑在 x86_64 上，但是生成的目标程序是给 aarch64 用的</b></span></span>。</div><div class="notion-text notion-block-1accb92044a7463999d2c787e7a160d4">这么理解以后，如果我要生成一个跑在 aarch64 上的程序，且未来我自己也有能力再编译源码继续跑在 aarch64 上，我就需要生成一个跑在 aarch64 上，目标程序也在 aarch64 上的GCC程序。</div><div class="notion-text notion-block-515c33fc71904169be770b2f7d390541">所以一开始要用 host=x86_64,target=x86_64 的编译器生成出来一个host=x86_64,target=aarch64 ，然后再通过这个编译器生成出来一个host=aarch64,target=aarch64。</div><div class="notion-text notion-block-9e446422ba3e448e9550e506836c2d08">LFS构建阶段分为三个阶段<a target="_blank" rel="noopener noreferrer" class="notion-link" href="https://lfs.xry111.site/zh_CN/development/partintro/toolchaintechnotes.html">[?]</a>，第一阶段是在PC（已构建好的发行版）上使用cc-pc（PC上的编译器）构建cc1（中间编译器），此时构建程序使用的（Build）、将来会运行被构建程序的（Host）是已构建的发行版，而为lfs产生代码。也就是我一开始只能生成能跑在PC上的编译器，但是我可以将目标产物换成能跑在LTS上的了。</div><div class="notion-text notion-block-f8ec8ba5deeb4b97a772ab53dc3d27dd">那只能由PC生成不够啊，我LFS也想自己生成，所以第二阶段则是将中间编译器换成刚刚构建好的cc1（中间编译器），目标产物是要使编译器能够在LFS上生成，也能在LFS自己编译后跑得动。</div><div class="notion-text notion-block-a72d3914211b42b680d48b5f2b8f20d5">第三阶段，那就是全部在LFS上跑，只要都能跑过，那就成功了。</div></ol></ol><ol start="4" class="notion-list notion-list-numbered notion-block-efd920d81f9a4913b2165530aad31a59"><li>问：GLIBC和GCC分别是什么？</li><ol class="notion-list notion-list-numbered notion-block-efd920d81f9a4913b2165530aad31a59"><div class="notion-text notion-block-4f2b7109a4a0451e8440477647dafe1c">答：glibc 是 C 库，<span class="notion-red"><span class="notion-inline-underscore"><b>提供了基本的系统功能和接口</b></span></span>，用于支持程序的运行。它是 Linux 系统中的默认 C 库。提供了一些常见的，比如printf, scanf等函数。</div><div class="notion-text notion-block-f4987ffd5afb454eaf190195d078c27d">GCC 是<span class="notion-red"><span class="notion-inline-underscore"><b>编译器套件</b></span></span>，支持多种编程语言，<span class="notion-red"><span class="notion-inline-underscore"><b>用于将源代码编译为可执行程序或库</b></span></span>。它提供了编译器和相关工具，帮助开发者编写高效的代码。</div></ol></ol><ol start="5" class="notion-list notion-list-numbered notion-block-b98766c3db0644ac8f1a74e7876429f0"><li>问：configure 文件是用来干嘛的</li><ol class="notion-list notion-list-numbered notion-block-b98766c3db0644ac8f1a74e7876429f0"><div class="notion-text notion-block-193f8dc5296b483985524e36b1aed4de">答：通常用来生成makefile，通常会使用autoconf工具链来自动生成可移植的构建系统</div></ol></ol><ol start="6" class="notion-list notion-list-numbered notion-block-9f4e4278c0c1476a85f6b03d899a90db"><li>问：为什么GCC需要GMP、MPFR和MPC软件包？GCC本来没有吗？</li><ol class="notion-list notion-list-numbered notion-block-9f4e4278c0c1476a85f6b03d899a90db"><div class="notion-text notion-block-b18e18734d9c4a08b84a2c42f5ffeb68">答：GMP是一个用于高精度整数运算的库，提供了高效可移植的多精度算数操作。MPFR则是用于高精度浮点数，MPC用于高精度复数，这三个库能够使GCC处理高精度整数、浮点数和附属运算。</div><div class="notion-text notion-block-3a0abbcc7f384b7491142a642e7d8b40">GCC原本也不包含这三个库，而将这三个库独立作为GCC外部依赖项，可以让其独立维护和发展，同时提高可配置性和可移植性。</div></ol></ol><ol start="7" class="notion-list notion-list-numbered notion-block-56fe9d839da64f3e8bd62bdfc0729867"><li>问：什么是编译三元组/目标三元组？</li><ol class="notion-list notion-list-numbered notion-block-56fe9d839da64f3e8bd62bdfc0729867"><div class="notion-text notion-block-a2fec52484c94160ab90196bf9e5085b">答：编译三元组（Compile Triple）是一个由三个部分组成的标识符，用于唯一标识一个特定的目标体系（target system）。它通常用于交叉编译的环境中，表示编译器和生成的可执行程序所针对的目标平台。</div><div class="notion-text notion-block-babead3bc5374c1a998963aaa796f1cf">三元组由 Architecture-Vendor-(-Kernel-Operating System) 组成</div><div class="notion-text notion-block-13665e2f5c054d45b26af2292a67faa4">常见的编译三元组比如有：x86_64-pc-linux-gnu, x86_64-apple-darwin</div><div class="notion-text notion-block-a0245d16155644fa8bed39c75afc4453">还有一些编译三元组中间还会跟一个 -Kernel-，比如 aarch64-unknown—linux-android 表示运行在 ARM64 智能手机上的 Android， aarch64-unknown-linux-gnu 则可被表示用于 ARM64 服务器上的Ubuntu，它们的区别仅在于后面的系统，如果三元组只有三个部分则无法正确表示。</div><div class="notion-text notion-block-128a2d822fdf4c54ab8e8b6f2b67c20d">还有一些比如有 riscv32-unknown-windows-msvc （实际上并不存在，因为压根没有 risc-v 的 Windows），用于标识 RISC-V 32 位架构在 Windows 操作系统上使用 MSVC（Microsoft Visual C++）编译器的目标平台。</div></ol></ol><ol start="8" class="notion-list notion-list-numbered notion-block-9783896e6a044bd4b6f4f59fc3247a10"><li>问：第一次安装交叉编译的GCC时，为什么要重新定义默认的 STARTFILE 前缀？</li><ol class="notion-list notion-list-numbered notion-block-9783896e6a044bd4b6f4f59fc3247a10"><div class="notion-text notion-block-11ae64ae362444eebf6950bd54d38a45">答：重新定义默认的startfile前缀是为了解决交叉编译器（cross-compiler）的问题。交叉编译器是一种在一种操作系统或体系结构上生成另一种操作系统或体系结构的可执行文件的编译器。<span class="notion-red"><span class="notion-inline-underscore"><b>由于编译器本身是在宿主系统上编译的，因此它们默认会使用宿主系统的标准启动文件路径</b></span></span>。但是，当我们使用交叉编译器时，需要使用目标系统的启动文件，而这些启动文件在宿主系统上是不可用的。
通过重新定义默认的startfile前缀，我们可以<span class="notion-red"><span class="notion-inline-underscore"><b>告诉编译器在寻找启动文件时搜索目标系统的启动文件路径而不是宿主系统的启动文件路径</b></span></span>。这样，我们就可以在宿主系统上使用交叉编译器来生成目标系统的可执行文件。</div></ol></ol><ol start="9" class="notion-list notion-list-numbered notion-block-20b06034eb3c4dd79f599c88b2bbf572"><li>问：gcc 里面编译的 --prefix 和 DESTDIR 有什么区别？分开写有什么作用？</li><ol class="notion-list notion-list-numbered notion-block-20b06034eb3c4dd79f599c88b2bbf572"><div class="notion-text notion-block-edc9829475bc4f72be06e9d33f7c1479">答：prefix是硬编码安装的路径（也就是编译后的程序认为自己所在的位置），而DESTDIR是暂时安装的路径（也就是编译后的程序实际被存放的位置）。</div><div class="notion-text notion-block-283b2b8cda544005890eeb7a9b9bf49a">对于挂载 /mnt/lfs 的系统，实际上就是想让它生成到 /mnt/lfs/usr，然后让lfs跑起来的时候认为自己是放到了 /usr</div><div class="notion-text notion-block-ce48fdf903244dc7aca94d4e9b2981f6">所以，--prefix 应该被设为 /usr （让以后使用的lfs知道编译后的程序被放到了 /usr），而 DESTDIR 应该被设成 /mnt/lfs （让现在的程序存放到这个地址，实际路径=DESTDIR+prefix）</div></ol></ol><ol start="10" class="notion-list notion-list-numbered notion-block-72fcb07472c645d2bd8d3c7e6d78a23c"><li>问：第一次安装交叉编译的GCC时，为什么要将 /lib64 替换为传统的 /lib 目录？</li><ol class="notion-list notion-list-numbered notion-block-72fcb07472c645d2bd8d3c7e6d78a23c"><div class="notion-text notion-block-932cd97074494806be587d1809ff5814">答：在一些 x86_64 架构的 Linux 系统上，库文件默认安装在 /lib64 目录下，而不是传统的 /lib 目录下。而 <span class="notion-red"><span class="notion-inline-underscore"><b>GCC 编译器默认情况下会去 /lib 目录下查找库文件</b></span></span>，这可能会导致编译器无法找到所需的库文件而无法正常工作。
因此，这段代码的作用是<span class="notion-red"><span class="notion-inline-underscore"><b>修改 GCC 编译器的配置文件，以便在 x86_64 架构的系统上使用 /lib 路径来查找库文件而不是 /lib64 路径</b></span></span>，从而确保编译器能够正确地链接库文件。这样做可以解决编译器找不到库文件的问题，使编译器在 x86_64 架构的系统上正常工作。</div></ol></ol><ol start="11" class="notion-list notion-list-numbered notion-block-7a9e41ee04344ae6b5073a720fbc40f2"><li>问：ln -sv usr/$i $LFS/$i 的时候，我本地工作目录是 /root ，会不会将 /root/bin 映射过去？</li><ol class="notion-list notion-list-numbered notion-block-7a9e41ee04344ae6b5073a720fbc40f2"><div class="notion-text notion-block-36a0ad4421ee45f7bc19c35ceaa14646">答：不会。符号链接进行链接的时候，使用的是相对路径的链接方式，这里的相对路径并不会使用目前的工作目录，而是相对于后面路径。在填充变量的时候，比如此时 $i=bin，实际的路径是 ln -sv usr/bin $LFS/bin（注意这里bin后面没有/），那么前面的是源链接，后面的是目的链接，就是 $LFS/bin 指向了 $LFS/usr/bin ，即</div><figure class="notion-asset-wrapper notion-asset-wrapper-image notion-block-665d93bbf18b4cdbb131718510c1af94"><div style="position:relative;display:flex;justify-content:center;align-self:center;width:100%;max-width:100%;flex-direction:column;height:100%"><img style="object-fit:cover" src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F819c9296-fe5a-43e1-85c3-97b94a360709%2FUntitled.png?table=block&amp;id=665d93bb-f18b-4cdb-b131-718510c1af94&amp;t=665d93bb-f18b-4cdb-b131-718510c1af94&amp;width=1012&amp;cache=v2" alt="notion image" loading="lazy" decoding="async"/></div></figure></ol></ol><ol start="12" class="notion-list notion-list-numbered notion-block-3865ff94159c48acbff25bf2413c3bf6"><li>问：.patch 文件是给源代码 patch 的还是给系统 patch的</li><ol class="notion-list notion-list-numbered notion-block-3865ff94159c48acbff25bf2413c3bf6"><div class="notion-text notion-block-6ec62ddcae6c4e9b978234a577240690">答：是给源代码patch的，我们查看其部分代码就知道</div><div class="notion-text notion-block-2bfae375667944469f56c62e2167858b">从这个源码我们可以轻松看出，这里的patch修改了 a/sysdeps/unix/sysv/linux/paths.h ，对 VARDB 的路径进行了修改，改为了 /var/lib/nss_db/</div></ol></ol><ol start="13" class="notion-list notion-list-numbered notion-block-2783bf500dd34af893c8cfa2e46f9873"><li>问：为什么编译 glibc 会依赖 python？</li><ol class="notion-list notion-list-numbered notion-block-2783bf500dd34af893c8cfa2e46f9873"><div class="notion-text notion-block-d56a13e6d94b4860b31405590bef5712">答：编译 Glibc 时需要使用 Python 脚本来自动生成一些文件。这些文件包括一些内部头文件和一些符号表，它们是 Glibc 编译和链接的必要组成部分。这些脚本可以在 ./scripts 里面看到，有一大堆的 *.py</div></ol></ol><ol start="14" class="notion-list notion-list-numbered notion-block-986896819c244e1082d32bf1a5704949"><li>问：（?）为什么需要修改ldd脚本中硬编码的可执行文件加载器路径</li><ol class="notion-list notion-list-numbered notion-block-986896819c244e1082d32bf1a5704949"><div class="notion-text notion-block-394ef34149674632973fa42d37ad0283">答：我们打开 /mnt/lfs/usr/bin/ldd，可以发现 RTLDLIST 行内容是 </div><div class="notion-text notion-block-617c54b69e624470b3fa1298a0ee7525"><code class="notion-inline-code">RTLDLIST=&quot;/usr/lib/ld-linux.so.2 /usr/lib64/ld-linux-x86-64.so.2 /usr/libx32/ld-linux-x32.so.2&quot;</code></div><div class="notion-text notion-block-d3ab6593e0a748af9c057f4c8032cd5e">而我们在之前已经将 /lib /lib64 链接过去/usr/lib了，推测是为了统一管理？而且我们也不存在 /usr/lib64 这个文件夹，替换一下刚好能使 <code class="notion-inline-code">/lib64/ld-linux-x86-64.so.2</code> 生效，否则就没一个能生效了</div></ol></ol><ol start="15" class="notion-list notion-list-numbered notion-block-eb987bff757143f0ba641abe5b14e181"><li>问：为什么要移除对交叉编译有害的 libtool 文档文件</li><ol class="notion-list notion-list-numbered notion-block-eb987bff757143f0ba641abe5b14e181"><div class="notion-text notion-block-e90c17912e4d4c889ba0ec1338227bc6">答：libtools 是 GNU Libtool 工具的一部分，它用于管理库文件的编译和链接过程。在构建 LFS 系统时，由于需要进行交叉编译，因此需要使用交叉编译工具链，<span class="notion-red"><span class="notion-inline-underscore"><b>而 libtools 本身并不支持交叉编译，所以需要进行一些特殊的处理。</b></span></span></div><div class="notion-text notion-block-6bf8bf89db9c46fea37658946df27307">其中，rm -v $LFS/usr/lib/lib{stdc++,stdc++fs,supc++}.la 命令的作用是删除 Libstdc++ 库中的一些不必要的文件，即 .la 文件。这些文件是由 Libtool 工具生成的，用于在编译时链接库文件。但是，<span class="notion-red"><span class="notion-inline-underscore"><b>在交叉编译环境下，这些文件并不是必需的，因为它们只包含本地系统的配置信息，而不包含交叉编译目标系统的信息</b></span></span>。因此，这些文件可以删除，以减小库文件的大小，同时也可以避免在链接时出现错误。</div></ol></ol><ol start="16" class="notion-list notion-list-numbered notion-block-3f12e1c650f145e5b32d8f4558d35ebc"><li>问：为什么gcc在第二次编译的时候还要使用 with-build-sysroot 参数并指向 $LFS？</li><ol class="notion-list notion-list-numbered notion-block-3f12e1c650f145e5b32d8f4558d35ebc"><div class="notion-text notion-block-e8c324dca8d14a08a38b2635884b6f49">答：仅仅是因为编译的时候所使用的目录是 $LFS 的目录，和编译后硬编码的程序没有关系，所以不用担心二次编译的时候指向 $LFS 这个问题</div></ol></ol><ol start="17" class="notion-list notion-list-numbered notion-block-7aef6417608b41bd8106ce1b91204da5"><li>问：gcc参数的 -lxxx 代表什么？</li><ol class="notion-list notion-list-numbered notion-block-7aef6417608b41bd8106ce1b91204da5"><div class="notion-text notion-block-1638152b4ae443cfb9f315c8b171432f">答：代表指定的库文件。一般来说，使用-lxxx代表使用的是libxxx.so库文件，也就是如果编译的时候发现 -ltinfo 找不到，那就是系统里没有 <a target="_blank" rel="noopener noreferrer" class="notion-link" href="http://libtinfo.so">libtinfo.so</a> 这个文件，查询发现是 ncurses 的东西，那么就可以先装 ncurses</div></ol></ol><ol start="18" class="notion-list notion-list-numbered notion-block-a8e2e89f75e34184b7cea9e04980004d"><li>问：musl和glibc的区别是什么？</li><ol class="notion-list notion-list-numbered notion-block-a8e2e89f75e34184b7cea9e04980004d"><div class="notion-text notion-block-b900fca8746b4f4fac9261c6934116cb">答：Musl和Glibc是两个不同的C标准库，它们的主要区别在于以下几个方面：</div><ul class="notion-list notion-list-disc notion-block-311b7b074cbf45ef9bf80548cd776837"><li>大小和性能：Musl库相对于Glibc库来说，体积更小、启动速度更快、内存占用更小，因此在嵌入式设备和轻量级系统中使用更为普遍。</li></ul><ul class="notion-list notion-list-disc notion-block-5e75d5d563374dc391c7b6ced0c11e6f"><li>兼容性：Musl库相对于Glibc库来说，对POSIX标准和C标准的实现更为严格，因此在某些情况下可能会与一些应用程序不兼容，需要进行代码修改或兼容性设置。</li></ul><ul class="notion-list notion-list-disc notion-block-e8e94f1afa624538a8b65fee45ceaabf"><li>功能支持：Glibc库相对于Musl库来说，支持的功能更为丰富，例如支持多线程、多语言、动态链接等，因此在一些高级应用程序中使用更为普遍。</li></ul><ul class="notion-list notion-list-disc notion-block-c4e5cfea5fa74f43b7347d70018483d0"><li>许可证：Musl库使用的是MIT许可证，而Glibc库使用的是GNU通用公共许可证（GPL），因此在一些商业应用中，使用Musl库可能更为方便。</li></ul><div class="notion-text notion-block-462384e07b2c489bb07f5b02542f6cae">需要注意的是，Musl和Glibc虽然是两个不同的C标准库，但都是符合POSIX和C标准的，因此在大部分情况下，它们的使用方式和API是相似的，只是在一些细节上可能会有所不同。</div></ol></ol><ol start="19" class="notion-list notion-list-numbered notion-block-27be9c2786d94008923f3012e3b11d12"><li>问：Busybox和Coreutils的区别是什么？</li><ol class="notion-list notion-list-numbered notion-block-27be9c2786d94008923f3012e3b11d12"><div class="notion-text notion-block-df52b1c4e95a44a0a1ff1fd797b31664">答：BusyBox和Coreutils都是常用的Linux工具集，它们都包含了许多基本的UNIX命令，例如ls、cp、mv、rm等。它们的主要区别在于以下几个方面：</div><ul class="notion-list notion-list-disc notion-block-3090bf82a0534cf08a45df84797a6cc1"><li>大小和功能：BusyBox相对于Coreutils来说，体积更小、功能更少，因此在嵌入式设备和轻量级系统中使用更为普遍。BusyBox使用了一个可配置的单一二进制文件，以替代许多独立的UNIX工具程序。而Coreutils则是一个完整的工具集，包含了大部分基本的UNIX命令。</li></ul><ul class="notion-list notion-list-disc notion-block-27874489086b4c37b232a61214cc0e23"><li>兼容性：BusyBox相对于Coreutils来说，对POSIX标准的实现更为严格，因此在一些情况下可能会与一些应用程序不兼容，需要进行代码修改或兼容性设置。而Coreutils则更为符合GNU和Linux标准。</li></ul><ul class="notion-list notion-list-disc notion-block-0d97baa3d3844898a2b79bcdbc437122"><li>许可证：BusyBox使用的是GPL许可证，而Coreutils使用的是GPL或LGPL许可证，因此在一些商业应用中，使用Coreutils可能更为方便。</li></ul><div class="notion-text notion-block-5a1c54c016e9491e9ac1c491f37b17a7">需要注意的是，BusyBox和Coreutils虽然在体积和功能上有所不同，但它们的使用方式和命令参数基本上是相同的。在Linux系统中，可以根据具体的需求选择使用它们中的任何一个，或者同时使用它们。</div></ol></ol><ol start="20" class="notion-list notion-list-numbered notion-block-6ab0c394559f47938ac1d4ee55253d78"><li>问：为什么一开始要用 lfs 用户来搞前面的操作，后面又要用root？</li><ol class="notion-list notion-list-numbered notion-block-6ab0c394559f47938ac1d4ee55253d78"><div class="notion-text notion-block-a79c3885ad3b4812aaf5f9f7b02df464">答：单纯是为了防止你乱搞的时候伤到原来的系统而已。lfs用户可以极大地限制权限，你编译的时候都可以不用root。但是后面要chroot进去了，如果你系统里面不存在同UID的，可能后面新增用户的时候就会一下子获得了这些文件的权限，这十分危险。</div></ol></ol><ol start="21" class="notion-list notion-list-numbered notion-block-b78e6f0ae7dc46f283ca2237b20d10f9"><li>问：挂载虚拟内核文件系统的时候，使用的proc sysfs似乎都不是直接指代根目录的文件夹，是系统预置的关键字吗？</li><ol class="notion-list notion-list-numbered notion-block-b78e6f0ae7dc46f283ca2237b20d10f9"><div class="notion-text notion-block-ddff152143624108ade480ae24f62c95">答：是的。包括 sys proc dev tmpfs 这几个都是特殊挂载点，是预留关键词，所以可以通过类似 </div><div class="notion-text notion-block-e1a2ecd7888b4a50b6ec531de047395b">的方式来挂载，</div><div class="notion-text notion-block-6625667e51a24f5bba777079d1bd7f9c">/proc是一个虚拟的文件系统，它提供了<span class="notion-red"><span class="notion-inline-underscore"><b>进程、系统和硬件设备信息的访问接口</b></span></span>。在Linux中，/proc目录下的文件和目录都是虚拟的，它们并不对应任何物理设备，而是由内核动态生成的。例如，/proc/cpuinfo文件提供了CPU的信息，/proc/meminfo文件提供了内存的信息，/proc/net目录提供了网络的信息，等等。</div><div class="notion-text notion-block-a1c6f2d7aadd425c91558df3ecab5bbc">/sys也是一个虚拟的文件系统，它提供了<span class="notion-red"><span class="notion-inline-underscore"><b>系统设备和驱动的信息</b></span></span>。与/proc不同的是，/sys是一个标准的文件系统，它的内容和结构是由内核和驱动程序开发者共同定义的。在/sys目录下，每个设备都有一个对应的目录，包含了该设备的属性、状态和配置信息。</div><div class="notion-text notion-block-cebbf0f906174455ae61cfe351221a4b">/dev目录是Linux系统中的设备文件目录，它包含了<span class="notion-red"><span class="notion-inline-underscore"><b>系统中所有的设备文件</b></span></span>。在Linux系统中，设备文件是一种特殊的文件，用于访问硬件设备、伪设备和虚拟设备等。例如，/dev/sda是一个硬盘设备文件，/dev/tty是一个终端设备文件，/dev/random是一个随机数发生器设备文件，等等。</div><div class="notion-text notion-block-f45fbb5f0e044f38812c60fd877056bf">tmpfs是一个临时文件系统，它通常用于<span class="notion-red"><span class="notion-inline-underscore"><b>存储临时文件或运行时数据</b></span></span>。与硬盘文件系统不同的是，tmpfs是一个基于内存的文件系统，它的数据存储在系统的内存中，而不是硬盘上。在Linux系统中，tmpfs通常被挂载到/tmp目录或其他临时目录中，用于存储临时文件、网络文件系统的缓存等。由于tmpfs存储在内存中，因此它的读写速度非常快，但是它的容量受到系统内存的限制。tmpfs可以有多个。</div></ol></ol><ol start="22" class="notion-list notion-list-numbered notion-block-7106adab45bd40ea9355d9b6f5e932a2"><li>问：/dev/shm 目录是干嘛的</li><ol class="notion-list notion-list-numbered notion-block-7106adab45bd40ea9355d9b6f5e932a2"><div class="notion-text notion-block-03b3fac7a362482b86d290f64e6db7a2">答：/dev/shm 目录是用于在进程之间共享数据的，程序运行时，会将一些数据存放在 /dev/shm 目录中。</div><div class="notion-text notion-block-47f9ad19803a45b982c01ca3a221df02">C语言程序共享数据时，会使用 shm.h 头</div></ol></ol><ol start="23" class="notion-list notion-list-numbered notion-block-9d1f8880f650419fa10391ff7a7d6b3b"><li>问：install命令是啥？</li><ol class="notion-list notion-list-numbered notion-block-9d1f8880f650419fa10391ff7a7d6b3b"><div class="notion-text notion-block-ee9a020450da4af19c41a2e25ccfa8e3">答：install 可以新建目录，在后面跟 -m 权限 可以设定改目录的权限。例如</div><div class="notion-text notion-block-c276fbc236d24658a1dd08c940ebfae0">就新建了 /root 并设定权限为0750，并且新建了 /tmp 和 /var/tmp 并设定权限为777且有粘滞位（不允许从中删除其他用户的文件）</div></ol></ol><div class="notion-blank notion-block-92405581238d45db90f00b7f724d901c"> </div><h2 class="notion-h notion-h1 notion-h-indent-0 notion-block-5d4689c70cb841b5b4fe4a15abf05b9a" data-id="5d4689c70cb841b5b4fe4a15abf05b9a"><span><div id="5d4689c70cb841b5b4fe4a15abf05b9a" class="notion-header-anchor"></div><a class="notion-hash-link" href="#5d4689c70cb841b5b4fe4a15abf05b9a" title="参考文章"><svg viewBox="0 0 16 16" width="16" height="16"><path fill-rule="evenodd" d="M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z"></path></svg></a><span class="notion-h-title">参考文章</span></span></h2><div class="notion-row"><a target="_blank" rel="noopener noreferrer" class="notion-bookmark notion-block-c545a17244844f92964eba6b169c3ce6" href="https://lctt.github.io/LFS-BOOK/lfs-sysv/chapter03/introduction.html"><div><div class="notion-bookmark-title">3.1. 简介</div><div class="notion-bookmark-link"><div class="notion-bookmark-link-icon"><img src="https://www.notion.so/image/https%3A%2F%2Flctt.github.io%2Ffavicon.ico?table=block&amp;id=c545a172-4484-4f92-964e-ba6b169c3ce6&amp;t=c545a172-4484-4f92-964e-ba6b169c3ce6" alt="3.1. 简介" loading="lazy" decoding="async"/></div><div class="notion-bookmark-link-text">https://lctt.github.io/LFS-BOOK/lfs-sysv/chapter03/introduction.html</div></div></div></a></div><div class="notion-row"><a target="_blank" rel="noopener noreferrer" class="notion-bookmark notion-block-ca13278ecf3644c982cf8827385627d5" href="https://lfs.xry111.site/zh_CN/development/partintro/toolchaintechnotes.html"><div><div class="notion-bookmark-title">工具链技术说明</div><div class="notion-bookmark-link"><div class="notion-bookmark-link-text">https://lfs.xry111.site/zh_CN/development/partintro/toolchaintechnotes.html</div></div></div></a></div><div class="notion-blank notion-block-593fb7477ac34f3285d7f20ebe51f872"> </div></main></div>
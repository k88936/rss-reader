<p>One of my favorite AI dev products today is <a href="https://plugins.jetbrains.com/plugin/14823-full-line-code-completion">Full Line Code Completion</a> in PyCharm (bundled with the IDE since late 2023). It’s extremely well-thought out, unintrusive, and makes me a more effective developer. Most importantly, it still keeps me mostly in control of my code. I’ve now used it in <a href="https://vickiboykis.com/2025/01/23/you-can-just-hack-on-atproto/">GoLand</a> as well. I’ve been a happy JetBrains customer for a long time now, and it’s because they ship features like this.</p>
<figure><img src="https://veekaybee.github.io/images/inline_completion.png" width="400">
</figure>

<p>I frequently work with code that involves sequential data processing, computations, and async API calls across multiple services. I also deal with a lot of precise vector operations in PyTorch that <a href="https://medium.com/@NoamShazeer/shape-suffixes-good-coding-style-f836e72e24fd">shape suffixes</a> don’t always illuminate. So, print statement debugging and writing good logs has been a critical part of my workflows for years.</p>
<p>As Kerningan and Pike say in <em>The Practice of Programming</em> about preferring print to debugging,</p>
<blockquote>
<p>…[W]e find stepping through a program less productive than thinking harder and adding output statements and self-checking code at critical places. Clicking over statements takes longer than scanning the output of judiciously-placed displays. It takes less time to decide where to put print statements than to single-step to the critical section of code, even assuming we know where that is.</p>
</blockquote>
<p>One thing that is annoying about logging is that <a href="https://docs.python.org/3/tutorial/inputoutput.html#formatted-string-literals">f-strings</a> are great but become repetitive to write if you have to write them over and over, particularly if you’re formatting values or accessing elements of data frames, lists, and nested structures, and particularly if you have to scan your codebase to find those variables. Writing good logs is important but also breaks up a debugging flow.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> loguru <span style="color:#f92672">import</span> logger
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>logger<span style="color:#f92672">.</span>info(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;Adding a log for </span><span style="color:#e6db74">{</span>your_variable<span style="color:#e6db74">}</span><span style="color:#e6db74"> and </span><span style="color:#e6db74">{</span>len(my_list)<span style="color:#e6db74">}</span><span style="color:#e6db74"> and </span><span style="color:#e6db74">{</span>df<span style="color:#f92672">.</span>head(<span style="color:#ae81ff">0</span>)<span style="color:#e6db74">}</span><span style="color:#e6db74">&#39;</span>)
</span></span></code></pre></div><p>The amount of cognitive overhead in this deceptively simple log is several levels deep: you have to first stop to type <a href="logger.info">logger.info</a> (or is it <a href="logging.info">logging.info</a>? I use both loguru and logger depending on the codebase and end up always getting the two confused.) Then, the parentheses, the f-string itself, and then the variables in brackets. Now, was it <code>your_variable</code> or <code>your_variable_with_edits</code> from five lines up? And what’s the syntax for accessing a subset of <code>df.head</code> again?</p>
<p>With full-line-code completion, JetBrains’ model auto-infers the log completion from the surrounding text, with a limit of 384 characters. Inference starts by taking the file extension as input, combined with the filepath, and then the part of the code above the input cursor, so that all of the tokens in the file extension, plus path, plus code above the caret, fit. Everything is combined and sent to the model in the prompt.</p>
<p>The constrained output good enough most of the time that it speeds up my workflow a lot. An added bonus is that it often writes a much clearer log than I, a lazy human, would write, logs. Because they’re so concise, I often don’t even remove when I’m done debugging because they’re now valuable in prod.</p>
<p>Here’s an example from a side project I’m working on. In the first case, the is autocomplete inferring that I actually want to check the Redis URL, a logical conclusion here.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>redis <span style="color:#f92672">=</span> aioredis<span style="color:#f92672">.</span>from_url(settings<span style="color:#f92672">.</span>redis_url, decode_responses<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>)
</span></span></code></pre></div><figure><img src="https://veekaybee.github.io/images/redis_completion.png" width="400">
</figure>

<p>In this second case, it assumes I’d like the shape of the dataframe, also a logical conclusion because the profiling dataframes is a very popular use-case for logs.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">from</span> pandas <span style="color:#f92672">import</span> DataFrame
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>data <span style="color:#f92672">=</span> [[<span style="color:#e6db74">&#39;apples&#39;</span>, <span style="color:#e6db74">&#39;2.5&#39;</span>], [<span style="color:#e6db74">&#39;oranges&#39;</span>, <span style="color:#e6db74">&#39;3.0&#39;</span>], [<span style="color:#e6db74">&#39;bananas&#39;</span>, <span style="color:#e6db74">&#39;4.0&#39;</span>]]
</span></span><span style="display:flex;"><span>column_names <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#39;Fruit&#39;</span>, <span style="color:#e6db74">&#39;Quantity&#39;</span>]
</span></span><span style="display:flex;"><span>df <span style="color:#f92672">=</span> pd<span style="color:#f92672">.</span>DataFrame(data, columns<span style="color:#f92672">=</span>column_names)
</span></span></code></pre></div><figure><img src="https://veekaybee.github.io/images/df_completion.png" width="400">
</figure>

<p><strong>Implementation</strong></p>
<p>The coolest part of this feature is that the inference model is entirely local to your machine.</p>
<p>This enforces a few very important requirements on the development team, namely compression and speed.</p>
<ul>
<li>The model has to be small enough to bundle with the IDE for desktop memory footprints (already coming in at around ~1GB for the MacOS binary), which eliminates 99% of current LLMs</li>
<li>And yet, the model has to be smart enough to interpolate lines of code from its small context window</li>
<li>The local requirement eliminates any model inference engines like vLLM, SGLM, or Ray which implement KV cache optimization like <a href="https://huggingface.co/docs/text-generation-inference/conceptual/paged_attention">PagedAttention</a></li>
<li>It has to be a model that’s fast enough to produce <a href="https://bentoml.com/llm/inference-optimization/llm-inference-metrics#latency">its first token</a> (and all subsequent tokens) extremely quickly,</li>
<li>Finally, it has to be optimized for Python specifically since this model is only available in PyCharm</li>
</ul>
<p>This is drastically different from the current assumptions around how we build and ship LLMs: that they need to be extremely large, general-purpose models served over proprietary APIs. we We find ourselves in a very constrained solution space because we no longer have to do all this other stuff that generalized LLMs have to do: write poetry, reason through math problems, act as OCR, offer code canvas templating, write marketing emails, and generate Studio Ghibli memes.</p>
<p>All we have to do is train a model to complete a single line of code with a context of 384 characters! And then compress the crap out of that model so that it can fit on-device and perform inference.</p>
<p>So how did they do it? Luckily, JetBrains <a href="https://arxiv.org/abs/2405.08704v1">published a paper on this</a>, and there are a bunch of interesting notes. The work is split into two parts, model training, and then the integration of the plugin itself.</p>
<figure><img src="https://veekaybee.github.io/images/jetbrains_model.png" width="400">
</figure>

<p>The <strong>model is trained</strong> is done in PyTorch and then quantized.</p>
<ul>
<li>First, they train a GPT-2 style Transformer <a href="https://cameronrwolfe.substack.com/p/decoder-only-transformers-the-workhorse">decoder-only</a> model of 100 million parameters, including a tokenizer (aka autoregressive text completion like you’d get from Claude, OpenAI, Gemini, and friends these days). They later changed this architecture to Llama2 after the success of the growing llama.cpp and <a href="https://vickiboykis.com/2024/02/28/gguf-the-long-way-around/">GGUF community</a>, as well as the better performance of the newer architecture.</li>
<li>The original dataset they used to train the model was a subset of <a href="https://huggingface.co/datasets/bigcode/the-stack">The Stack</a>, a code dataset across permissive licenses with 6TB of code in 30 programming languages
<ul>
<li>The initial training set was “just” 45 GB and in preparing the data for training, in data cleaning, for space constraints, they remove all code comments in the training data specifically to focus on code generation</li>
<li>They do a neat trick for tokenizing Python (using a <a href="https://huggingface.co/learn/llm-course/en/chapter6/5">BPE-style tokenizer</a> optimized for character pairs rather than bytes, since code is made up of smaller snippets and idioms than natural language text) which is indentation-sensitive, by converting spaces and tabs to start-end <code>&lt;SCOPE_IN&gt;&lt;SCOPE_OUT&gt;</code> tokens, to remove tokens that might be different only because they have different whitespacing. They ended up going with a tokenizer vocab size of 16,384.</li>
<li>They do another very cool step in training which is to remove imports because they find that developers usually add imports in after writing the actual code, a fact that the model needs to anticipate</li>
</ul>
</li>
<li>They then split into train/test for evaluation and trained for several days on 8 NVidia A100 GPU with a<a href="https://docs.pytorch.org/docs/stable/generated/torch.nn.CrossEntropyLoss.html"> cross-entropy loss objective function</a></li>
</ul>
<p>Because they were able to so clearly focus on the domain and understanding of how code inference works, focus on a single programming languages with its own nuances, they were able to make the training data set smaller, make the output more exact, and spend much less time and money training the model.</p>
<p>The <strong>actual plugin</strong> that’s included in PyCharm “is implemented in Kotlin, however, it utilizes an additional native server that is run locally and is implemented in C++” for serving the inference tokens.</p>
<p>In order to prepare the model for serving, they:</p>
<ul>
<li>
<p>Quantized it from <a href="https://developer.nvidia.com/blog/achieving-fp32-accuracy-for-int8-inference-using-quantization-aware-training-with-tensorrt/">FP32 to INT8</a> which compressed the model from 400 MB to 100 MB</p>
</li>
<li>
<p>Prepared as a served ONNX RT artifact, which allowed them to use CPU inference, which removed the CUDA overhead tax(later, they switched to using llama.cpp to serve the llama model architecture for the server.</p>
</li>
<li>
<p>Finally, in order to perform inference on a sequence of tokens, they use <a href="https://d2l.ai/chapter_recurrent-modern/beam-search.html">beam search. </a>Generally, Transformer-decoders are trained on predicting the next token in any given sequence so any individual step will give you a list of tokens along with their ranked probabilities (cementing my long-running theory that everything is a search problem).</p>
<p>Since this is computationally impossible at large numbers of tokens, a number of solutions exist to solve the problem of decoding optimally. Beam search creates a graph of all possible returned token sequences and expands at each node with the highest potential probability, limiting to <code>k</code> possible beams. In FLCC, the max number of beams, k, is 20, and they chose to limit generation to collect only those hypotheses that end with a newline character.</p>
<p>Additionally they made use of a number of caching strategies, including initializing the model at 50% of total context - i.e. it starts by preloading ~192 characters of previous code, to give you space to either go back and edit old code, which now no longer has to be put into context, or to add new code, which is then added to the context. That way, if your cursor clicks on code you&rsquo;ve already written, the model doesn&rsquo;t need to re-infer.</p>
</li>
</ul>
<p>There are a number of other very cool architecture and model decisions from the paper that are very worth reading and that show the level of care put into the input data, the modeling, and the inference architecture.</p>
<p>The bottom line is that, for me as a user, this experience is extremely thoughtful. It has saved me countless times both in print log debugging and in the logs I ship to prod.</p>
<p>In LLM land, there’s both a place for large, generalist models, and there’s a place for small models, and while much of the rest of the world writes about the former, I’m excited to also find more applications built with the latter.</p>
<h2 id="introduction">Introduction<a class="zola-anchor" href="#introduction" aria-label="Anchor link for: introduction" style="visibility: hidden;"></a>
</h2>
<p><img src="https://jms55.github.io/posts/2024-11-14-virtual-geometry-bevy-0-15/cover.png" alt="Screenshot of some megascans in Bevy 0.15" /></p>
<center>
<p><em>Original scene by <a rel="nofollow noreferrer" href="https://discord.com/channels/691052431525675048/1302853333387575340/1302853473997422623">Griffin</a>. Slightly broken due to lack of double-sided material support.</em></p>
</center>
<p>It's been a little over 5 months <a href="https://jms55.github.io/posts/2024-06-09-virtual-geometry-bevy-0-14/">since my last post</a> where I talked about the very early prototype of virtual geometry I wrote for Bevy 0.14.</p>
<p>While it's still not production ready, the improved version of virtual geometry that will ship in Bevy 0.15 (which is releasing soon) is a very large step in the right direction!</p>
<p>In this blog post I'll be going over all the virtual geometry PRs merged since my last post, in chronological order. At the end, I'll do a performance comparison of Bevy 0.15 vs 0.14, and finally discuss my roadmap for what I'm planning to work on in Bevy 0.16 and beyond.</p>
<p>Like last time, a lot of the larger architectural changes are copied from Nanite based on the SIGGRAPH presentation, which you should watch if you want to learn more.</p>
<p>It's going to be another super long read, so grab some snacks and strap in!</p>
<h2 id="arseny-kapoulkine-s-contributions">Arseny Kapoulkine's Contributions<a class="zola-anchor" href="#arseny-kapoulkine-s-contributions" aria-label="Anchor link for: arseny-kapoulkine-s-contributions" style="visibility: hidden;"></a>
</h2>
<p>PRs <a rel="nofollow noreferrer" href="https://github.com/bevyengine/bevy/pull/13904">#13904</a>, <a rel="nofollow noreferrer" href="https://github.com/bevyengine/bevy/pull/13913">#13913</a>, and <a rel="nofollow noreferrer" href="https://github.com/bevyengine/bevy/pull/14038">#14038</a> improve the performance of the Mesh to MeshletMesh converter, and makes it more deterministic. These were written by Arseny Kapoulkine (author of meshoptimizer, the library I use for mesh simplification and meshlet building). Thanks for the contributions!</p>
<p>PR <a rel="nofollow noreferrer" href="https://github.com/bevyengine/bevy/pull/14042">#14042</a>, also by Kapoulkine, fixed a bug with how we calculate the depth pyramid mip level to sample at for occlusion culling.</p>
<p>These PRs were actually shipped in Bevy 0.14, but were opened after I published my last post, hence why I'm covering them now.</p>
<h2 id="faster-meshletmesh-loading">Faster MeshletMesh Loading<a class="zola-anchor" href="#faster-meshletmesh-loading" aria-label="Anchor link for: faster-meshletmesh-loading" style="visibility: hidden;"></a>
</h2>
<p>PR <a rel="nofollow noreferrer" href="https://github.com/bevyengine/bevy/pull/14193">#14193</a> improves performance when loading MeshletMesh assets from disk.</p>
<p>Previously I was using the <code>bincode</code> and <code>serde</code> crates to serialize and deserialize MeshletMeshes. All I had to do was slap <code>#[derive(Serialize, Deserialize)]</code> on the type, and then I could use <code>bincode::serialize_into()</code> to turn my asset into a slice of bytes for writing to disk, and <code>bincode::deserialize_from()</code> in order to turn a slice of bytes loaded from disk back into my asset type. Easy.</p>
<p>Unfortunately, that ease of use came with a good bit of performance overhead. Specifically in the deserializing step, where bytes get turned into the asset type. Deserializing the 5mb Stanford Bunny asset I was using for testing took a depressingly long 77ms on my Ryzen 5 2600 CPU.</p>
<p>Thinking about the code flow more, we <em>already</em> have an asset -&gt; bytes step. After the asset is loaded into CPU memory, we serialize it <em>back</em> into bytes so that we can upload it to GPU memory. For this, we use the <code>bytemuck</code> crate which provides functions for casting slices of data that are <code>Pod</code> (plain-old-data, i.e. just numbers, which all of our asset data is) to slices of bytes, without any real overhead.</p>
<p>Why not simply use bytemuck to cast our asset data to slices of bytes, and write that? Similarly for reading from disk, we can simply cast the slice of bytes back to our asset type.</p>
<pre data-lang="rust" style="background-color:#002b36;color:#839496;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#268bd2;">fn </span><span style="color:#b58900;">write_slice</span><span>&lt;T: Pod&gt;</span><span style="color:#657b83;">(
</span><span>    </span><span style="color:#268bd2;">field</span><span>: </span><span style="color:#859900;">&amp;</span><span>[T],
</span><span>    </span><span style="color:#268bd2;">writer</span><span>: </span><span style="color:#859900;">&amp;</span><span style="color:#93a1a1;">mut</span><span> dyn Write,
</span><span style="color:#657b83;">) </span><span>-&gt; </span><span style="color:#859900;">Result</span><span>&lt;</span><span style="color:#657b83;">()</span><span>, MeshletMeshSaveOrLoadError&gt; </span><span style="color:#657b83;">{
</span><span>    writer.</span><span style="color:#859900;">write_all</span><span style="color:#657b83;">(</span><span style="color:#859900;">&amp;</span><span style="color:#657b83;">(</span><span>field.</span><span style="color:#859900;">len</span><span style="color:#657b83;">() </span><span style="color:#859900;">as </span><span style="color:#268bd2;">u64</span><span style="color:#657b83;">)</span><span>.</span><span style="color:#859900;">to_le_bytes</span><span style="color:#657b83;">())</span><span style="color:#859900;">?</span><span>;
</span><span>    writer.</span><span style="color:#859900;">write_all</span><span style="color:#657b83;">(</span><span>bytemuck::cast_slice</span><span style="color:#657b83;">(</span><span>field</span><span style="color:#657b83;">))</span><span style="color:#859900;">?</span><span>;
</span><span>    </span><span style="color:#859900;">Ok</span><span style="color:#657b83;">(())
</span><span style="color:#657b83;">}
</span><span>
</span><span style="color:#268bd2;">fn </span><span style="color:#b58900;">read_slice</span><span>&lt;T: Pod&gt;</span><span style="color:#657b83;">(</span><span style="color:#268bd2;">reader</span><span>: </span><span style="color:#859900;">&amp;</span><span style="color:#93a1a1;">mut</span><span> dyn Read</span><span style="color:#657b83;">) </span><span>-&gt; </span><span style="color:#859900;">Result</span><span>&lt;Arc&lt;</span><span style="color:#657b83;">[</span><span>T</span><span style="color:#657b83;">]</span><span>&gt;, std::io::Error&gt; </span><span style="color:#657b83;">{
</span><span>    </span><span style="color:#268bd2;">let</span><span> len </span><span style="color:#657b83;">= </span><span style="color:#859900;">read_u64</span><span style="color:#657b83;">(</span><span>reader</span><span style="color:#657b83;">)</span><span style="color:#859900;">? as </span><span style="color:#268bd2;">usize</span><span>;
</span><span>
</span><span>    </span><span style="color:#268bd2;">let </span><span style="color:#93a1a1;">mut</span><span> data: Arc&lt;</span><span style="color:#657b83;">[</span><span>T</span><span style="color:#657b83;">]</span><span>&gt; </span><span style="color:#657b83;">= </span><span>std::iter::repeat_with</span><span style="color:#657b83;">(</span><span>T::zeroed</span><span style="color:#657b83;">)</span><span>.</span><span style="color:#859900;">take</span><span style="color:#657b83;">(</span><span>len</span><span style="color:#657b83;">)</span><span>.</span><span style="color:#859900;">collect</span><span style="color:#657b83;">()</span><span>;
</span><span>    </span><span style="color:#268bd2;">let</span><span> slice </span><span style="color:#657b83;">= </span><span>Arc::get_mut</span><span style="color:#657b83;">(</span><span style="color:#859900;">&amp;</span><span style="color:#93a1a1;">mut</span><span> data</span><span style="color:#657b83;">)</span><span>.</span><span style="color:#859900;">unwrap</span><span style="color:#657b83;">()</span><span>;
</span><span>    reader.</span><span style="color:#859900;">read_exact</span><span style="color:#657b83;">(</span><span>bytemuck::cast_slice_mut</span><span style="color:#657b83;">(</span><span>slice</span><span style="color:#657b83;">))</span><span style="color:#859900;">?</span><span>;
</span><span>
</span><span>    </span><span style="color:#859900;">Ok</span><span style="color:#657b83;">(</span><span>data</span><span style="color:#657b83;">)
</span><span style="color:#657b83;">}
</span></code></pre>
<p>These two functions are all we need to read and write asset data. <code>write_slice()</code> takes a slice of asset data, writes the length of the slice, and then casts the slice to bytes and writes it to disk. <code>read_slice()</code> reads the length of the slice from disk, allocates an atomically reference counted buffer of that size, and then reads from disk to fill the buffer, casting it back into the asset data type.</p>
<p>Writing the entire asset to disk now looks like this:</p>
<pre data-lang="rust" style="background-color:#002b36;color:#839496;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#859900;">write_slice</span><span style="color:#657b83;">(</span><span style="color:#859900;">&amp;</span><span>asset.vertex_data, </span><span style="color:#859900;">&amp;</span><span style="color:#93a1a1;">mut</span><span> writer</span><span style="color:#657b83;">)</span><span style="color:#859900;">?</span><span>;
</span><span style="color:#859900;">write_slice</span><span style="color:#657b83;">(</span><span style="color:#859900;">&amp;</span><span>asset.vertex_ids, </span><span style="color:#859900;">&amp;</span><span style="color:#93a1a1;">mut</span><span> writer</span><span style="color:#657b83;">)</span><span style="color:#859900;">?</span><span>;
</span><span style="color:#859900;">write_slice</span><span style="color:#657b83;">(</span><span style="color:#859900;">&amp;</span><span>asset.indices, </span><span style="color:#859900;">&amp;</span><span style="color:#93a1a1;">mut</span><span> writer</span><span style="color:#657b83;">)</span><span style="color:#859900;">?</span><span>;
</span><span style="color:#859900;">write_slice</span><span style="color:#657b83;">(</span><span style="color:#859900;">&amp;</span><span>asset.meshlets, </span><span style="color:#859900;">&amp;</span><span style="color:#93a1a1;">mut</span><span> writer</span><span style="color:#657b83;">)</span><span style="color:#859900;">?</span><span>;
</span><span style="color:#859900;">write_slice</span><span style="color:#657b83;">(</span><span style="color:#859900;">&amp;</span><span>asset.bounding_spheres, </span><span style="color:#859900;">&amp;</span><span style="color:#93a1a1;">mut</span><span> writer</span><span style="color:#657b83;">)</span><span style="color:#859900;">?</span><span>;
</span></code></pre>
<p>And reading it back from disk looks like this:</p>
<pre data-lang="rust" style="background-color:#002b36;color:#839496;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#268bd2;">let</span><span> vertex_data </span><span style="color:#657b83;">= </span><span style="color:#859900;">read_slice</span><span style="color:#657b83;">(</span><span>reader</span><span style="color:#657b83;">)</span><span style="color:#859900;">?</span><span>;
</span><span style="color:#268bd2;">let</span><span> vertex_ids </span><span style="color:#657b83;">= </span><span style="color:#859900;">read_slice</span><span style="color:#657b83;">(</span><span>reader</span><span style="color:#657b83;">)</span><span style="color:#859900;">?</span><span>;
</span><span style="color:#268bd2;">let</span><span> indices </span><span style="color:#657b83;">= </span><span style="color:#859900;">read_slice</span><span style="color:#657b83;">(</span><span>reader</span><span style="color:#657b83;">)</span><span style="color:#859900;">?</span><span>;
</span><span style="color:#268bd2;">let</span><span> meshlets </span><span style="color:#657b83;">= </span><span style="color:#859900;">read_slice</span><span style="color:#657b83;">(</span><span>reader</span><span style="color:#657b83;">)</span><span style="color:#859900;">?</span><span>;
</span><span style="color:#268bd2;">let</span><span> bounding_spheres </span><span style="color:#657b83;">= </span><span style="color:#859900;">read_slice</span><span style="color:#657b83;">(</span><span>reader</span><span style="color:#657b83;">)</span><span style="color:#859900;">?</span><span>;
</span><span>
</span><span style="color:#859900;">Ok</span><span style="color:#657b83;">(</span><span>MeshletMesh </span><span style="color:#657b83;">{
</span><span>    vertex_data,
</span><span>    vertex_ids,
</span><span>    indices,
</span><span>    meshlets,
</span><span>    bounding_spheres,
</span><span style="color:#657b83;">})
</span></code></pre>
<p>Total load time from disk to CPU memory for our 5mb MeshletMesh went from 102ms down to 12ms, an 8.5x speedup.</p>
<h2 id="software-rasterization">Software Rasterization<a class="zola-anchor" href="#software-rasterization" aria-label="Anchor link for: software-rasterization" style="visibility: hidden;"></a>
</h2>
<p>PR <a rel="nofollow noreferrer" href="https://github.com/bevyengine/bevy/pull/14623">#14623</a> improves our visbuffer rasterization performance for clusters that appear small on screen (i.e. almost all of them). I rewrote pretty much the entire virtual geometry codebase in this PR, so this is going to be a really long section.</p>
<h3 id="motivation">Motivation<a class="zola-anchor" href="#motivation" aria-label="Anchor link for: motivation" style="visibility: hidden;"></a>
</h3>
<p>If you remember the frame breakdown from the last post, visbuffer rasterization took the largest chunk of our frame time. Writing out a buffer of cluster + triangle IDs to render in the culling pass, and then doing a single indirect draw over the total count of triangles does not scale very well.</p>
<p>The buffer used a lot of memory (4 bytes per non-culled triangle). The GPU's primitive assembler can't keep up with the sheer number of vertices we're sending it as we're not using indexed triangles (to save extra memory and time spent writing out an index buffer), and therefore lack a vertex cache. And finally the GPU's rasterizer just performs poorly with small triangles, and we have a <em>lot</em> of small triangles.</p>
<p>Current GPU rasterizers expect comparatively few triangles that each cover many pixels. They have performance optimizations aimed at that kind of workload like shading 2x2 quads of pixels at a time and tile binning of triangles. Meanwhile, our virtual geometry renderer is aimed at millions of tiny triangles that only cover a pixel each. We need a rasterizer aimed at being efficient over the number of triangles; not the number of covered pixels per triangle.</p>
<p>We need a custom rasterizer algorithm, written in a compute shader, that does everything the GPU's hardware rasterizer does, but with the extra optimizations stripped out.</p>
<h3 id="preparation">Preparation<a class="zola-anchor" href="#preparation" aria-label="Anchor link for: preparation" style="visibility: hidden;"></a>
</h3>
<p>Before we get to the actual software rasterizer, there's a bunch of prep work we need to do first. Namely, redoing our entire hardware rasterizer setup.</p>
<p>In Bevy 0.14, we were writing out a buffer of triangles from the culling pass, and issuing a single indirect draw to rasterize every triangle in the buffer. We're going to throw all that out, and go with a completely new scheme.</p>
<p>First, we need a buffer for to store a bunch of cluster IDs (the ones we want to rasterize). We'll have users give a fixed size for this buffer on startup, based on the maximum number of clusters they expect to have visible in a frame in any given scene (not the amount pre-culling and LOD selection).</p>
<pre data-lang="rust" style="background-color:#002b36;color:#839496;" class="language-rust "><code class="language-rust" data-lang="rust"><span>MeshletPlugin </span><span style="color:#657b83;">{</span><span> cluster_buffer_slots: </span><span style="color:#6c71c4;">8192 </span><span style="color:#657b83;">}
</span><span>
</span><span>render_device.</span><span style="color:#859900;">create_buffer</span><span style="color:#657b83;">(</span><span style="color:#859900;">&amp;</span><span>BufferDescriptor </span><span style="color:#657b83;">{
</span><span>    label: </span><span style="color:#859900;">Some</span><span style="color:#657b83;">(</span><span>&quot;</span><span style="color:#2aa198;">meshlet_raster_clusters</span><span>&quot;</span><span style="color:#657b83;">)</span><span>,
</span><span>    size: cluster_buffer_slots </span><span style="color:#859900;">as </span><span style="color:#268bd2;">u64 </span><span style="color:#657b83;">* </span><span>size_of::&lt;</span><span style="color:#268bd2;">u32</span><span>&gt;</span><span style="color:#657b83;">() </span><span style="color:#859900;">as </span><span style="color:#268bd2;">u64</span><span>,
</span><span>    usage: BufferUsages::</span><span style="color:#cb4b16;">STORAGE</span><span>,
</span><span>    mapped_at_creation: </span><span style="color:#b58900;">false</span><span>,
</span><span style="color:#657b83;">})</span><span>;
</span></code></pre>
<p>Next, we'll setup two indirect commands in some buffers. One for hardware raster, one for software raster. For hardware raster, we're going to hardcode the vertex count to 64 (the maximum number of triangles per meshlet) times 3 (vertices per triangle) total vertices. We'll also initialize the instance count to zero.</p>
<p>This was a sceme I described in my last post, but purposefully avoided due to the lackluster performance. However, now that we're adding a software rasterizer, I expect that almost all clusters will be software rasterized. Therefore some performance loss for the hardware raster is acceptable, as it should be rarely used. In return, we'll get to use a nice trick in the next step.</p>
<pre data-lang="rust" style="background-color:#002b36;color:#839496;" class="language-rust "><code class="language-rust" data-lang="rust"><span>render_device.</span><span style="color:#859900;">create_buffer_with_data</span><span style="color:#657b83;">(</span><span style="color:#859900;">&amp;</span><span>BufferInitDescriptor </span><span style="color:#657b83;">{
</span><span>    label: </span><span style="color:#859900;">Some</span><span style="color:#657b83;">(</span><span>&quot;</span><span style="color:#2aa198;">meshlet_hardware_raster_indirect_args</span><span>&quot;</span><span style="color:#657b83;">)</span><span>,
</span><span>    contents: DrawIndirectArgs </span><span style="color:#657b83;">{
</span><span>        vertex_count: </span><span style="color:#6c71c4;">64 </span><span style="color:#657b83;">* </span><span style="color:#6c71c4;">3</span><span>,
</span><span>        instance_count: </span><span style="color:#6c71c4;">0</span><span>,
</span><span>        first_vertex: </span><span style="color:#6c71c4;">0</span><span>,
</span><span>        first_instance: </span><span style="color:#6c71c4;">0</span><span>,
</span><span>    </span><span style="color:#657b83;">}
</span><span>    .</span><span style="color:#859900;">as_bytes</span><span style="color:#657b83;">()</span><span>,
</span><span>    usage: BufferUsages::</span><span style="color:#cb4b16;">STORAGE </span><span style="color:#859900;">| </span><span>BufferUsages::</span><span style="color:#cb4b16;">INDIRECT</span><span>,
</span><span style="color:#657b83;">})</span><span>;
</span><span>
</span><span>render_device.</span><span style="color:#859900;">create_buffer_with_data</span><span style="color:#657b83;">(</span><span style="color:#859900;">&amp;</span><span>BufferInitDescriptor </span><span style="color:#657b83;">{
</span><span>    label: </span><span style="color:#859900;">Some</span><span style="color:#657b83;">(</span><span>&quot;</span><span style="color:#2aa198;">meshlet_software_raster_indirect_args</span><span>&quot;</span><span style="color:#657b83;">)</span><span>,
</span><span>    contents: DispatchIndirectArgs </span><span style="color:#657b83;">{</span><span> x: </span><span style="color:#6c71c4;">0</span><span>, y: </span><span style="color:#6c71c4;">1</span><span>, z: </span><span style="color:#6c71c4;">1 </span><span style="color:#657b83;">}</span><span>.</span><span style="color:#859900;">as_bytes</span><span style="color:#657b83;">()</span><span>,
</span><span>    usage: BufferUsages::</span><span style="color:#cb4b16;">STORAGE </span><span style="color:#859900;">| </span><span>BufferUsages::</span><span style="color:#cb4b16;">INDIRECT</span><span>,
</span><span style="color:#657b83;">})</span><span>;
</span></code></pre>
<p>In the culling pass, after LOD selection and culling, we're going to replace the the triangle buffer writeout code with something new.</p>
<p>First we need to decide if the cluster is going to be software rasterized, or hardware rasterized. For this, my current heuristic is to take the cluster's screen-space AABB size we already calculated for occlusion culling, and check how big it is. If it's small (currently &lt; 64 pixels on both axis), then it should be software rasterized. If it's large, then it gets hardware rasterized.</p>
<p>At some point, when I have some better test scenes setup, I'll need to experiment with this parameter and see if I get better results with a different number.</p>
<pre data-lang="rust" style="background-color:#002b36;color:#839496;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#268bd2;">let</span><span> cluster_is_small </span><span style="color:#657b83;">= </span><span style="color:#859900;">all</span><span style="color:#657b83;">(</span><span style="color:#859900;">vec2</span><span style="color:#657b83;">(</span><span>aabb_width_pixels, aabb_height_pixels</span><span style="color:#657b83;">) &lt; </span><span style="color:#859900;">vec2</span><span style="color:#657b83;">(</span><span style="color:#6c71c4;">64.0</span><span style="color:#657b83;">))</span><span>;
</span></code></pre>
<p>Finally, the culling pass needs to output a list of clusters for both software and hardware rasterization. For this, I'm going to borrow a trick from Unreal's Nanite I learned from this <a rel="nofollow noreferrer" href="https://www.elopezr.com/a-macro-view-of-nanite">frame breakdown</a>.</p>
<p>Instead of allocating two buffers (one for SW raster, one for HW raster), we have the one <code>meshlet_raster_clusters</code> buffer that we'll share between them, saving memory. Software rasterized clusters will be added starting from the left side of the buffer, while hardware rasterized clusters will be added from the right side of the buffer. As long as the buffer is big enough, they'll never overlap.</p>
<p>Software rasterized clusters will increment the previously created indirect dispatch (1 workgroup per cluster), while hardware rasterized clusters will increment the previously created indirect draw (one draw instance per cluster).</p>
<pre data-lang="rust" style="background-color:#002b36;color:#839496;" class="language-rust "><code class="language-rust" data-lang="rust"><span>var buffer_slot: </span><span style="color:#268bd2;">u32</span><span>;
</span><span style="color:#859900;">if</span><span> cluster_is_small </span><span style="color:#859900;">&amp;&amp;</span><span> not_intersects_near_plane </span><span style="color:#657b83;">{
</span><span>    </span><span style="color:#586e75;">// Append this cluster to the list for software rasterization
</span><span>    buffer_slot </span><span style="color:#657b83;">=</span><span> atomicAdd</span><span style="color:#657b83;">(</span><span style="color:#859900;">&amp;</span><span>meshlet_software_raster_indirect_args.x, 1u</span><span style="color:#657b83;">)</span><span>;
</span><span style="color:#657b83;">} </span><span style="color:#859900;">else </span><span style="color:#657b83;">{
</span><span>    </span><span style="color:#586e75;">// Append this cluster to the list for hardware rasterization
</span><span>    buffer_slot </span><span style="color:#657b83;">=</span><span> atomicAdd</span><span style="color:#657b83;">(</span><span style="color:#859900;">&amp;</span><span>meshlet_hardware_raster_indirect_args.instance_count, 1u</span><span style="color:#657b83;">)</span><span>;
</span><span>    buffer_slot </span><span style="color:#657b83;">=</span><span> constants.meshlet_raster_cluster_rightmost_slot </span><span style="color:#657b83;">-</span><span> buffer_slot;
</span><span style="color:#657b83;">}
</span><span>meshlet_raster_clusters</span><span style="color:#657b83;">[</span><span>buffer_slot</span><span style="color:#657b83;">] =</span><span> cluster_id;
</span></code></pre>
<h3 id="hardware-rasterization-and-atomicmax">Hardware Rasterization and atomicMax<a class="zola-anchor" href="#hardware-rasterization-and-atomicmax" aria-label="Anchor link for: hardware-rasterization-and-atomicmax" style="visibility: hidden;"></a>
</h3>
<p>We can now perform the indirect draw for hardware rasterization, and an indirect dispatch for software rasterization.</p>
<p>In the hardware rasterization pass, since we're now spawning <code>MESHLET_MAX_TRIANGLES * 3</code> vertices per cluster, we now need extra vertex shader invocations to write NaN triangle positions to ensure the extra triangles gets discarded.</p>
<pre data-lang="rust" style="background-color:#002b36;color:#839496;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#859900;">@</span><span>vertex
</span><span style="color:#268bd2;">fn </span><span style="color:#b58900;">vertex</span><span style="color:#657b83;">(</span><span>@builtin</span><span style="color:#657b83;">(</span><span style="color:#268bd2;">instance_index</span><span style="color:#657b83;">) </span><span style="color:#268bd2;">instance_index</span><span>: </span><span style="color:#268bd2;">u32</span><span>, @builtin</span><span style="color:#657b83;">(</span><span style="color:#268bd2;">vertex_index</span><span style="color:#657b83;">) </span><span style="color:#268bd2;">vertex_index</span><span>: </span><span style="color:#268bd2;">u32</span><span style="color:#657b83;">) </span><span>-&gt; VertexOutput </span><span style="color:#657b83;">{
</span><span>    </span><span style="color:#268bd2;">let</span><span> cluster_id </span><span style="color:#657b83;">=</span><span> meshlet_raster_clusters</span><span style="color:#657b83;">[</span><span>meshlet_raster_cluster_rightmost_slot </span><span style="color:#657b83;">-</span><span> instance_index</span><span style="color:#657b83;">]</span><span>;
</span><span>    </span><span style="color:#268bd2;">let</span><span> meshlet_id </span><span style="color:#657b83;">=</span><span> meshlet_cluster_meshlet_ids</span><span style="color:#657b83;">[</span><span>cluster_id</span><span style="color:#657b83;">]</span><span>;
</span><span>    var meshlet </span><span style="color:#657b83;">=</span><span> meshlets</span><span style="color:#657b83;">[</span><span>meshlet_id</span><span style="color:#657b83;">]</span><span>;
</span><span>
</span><span>    </span><span style="color:#268bd2;">let</span><span> triangle_id </span><span style="color:#657b83;">=</span><span> vertex_index </span><span style="color:#657b83;">/</span><span> 3u;
</span><span>    </span><span style="color:#859900;">if</span><span> triangle_id </span><span style="color:#657b83;">&gt;= </span><span style="color:#859900;">get_meshlet_triangle_count</span><span style="color:#657b83;">(</span><span style="color:#859900;">&amp;</span><span>meshlet</span><span style="color:#657b83;">) { </span><span style="color:#859900;">return dummy_vertex</span><span style="color:#657b83;">()</span><span>; </span><span style="color:#657b83;">}
</span><span>
</span><span>    </span><span style="color:#586e75;">// ...
</span><span style="color:#657b83;">}
</span></code></pre>
<p>In the fragment shader, instead of writing to a bound render target, we're now going to do an <code>atomicMax()</code> on a storage buffer to store the rasterized visbuffer result. The reason is that we'll need to do the same for the software rasterization pass (because compute shaders don't have access to render targets), so to keep things simple and reuse the same bind group and underlying texture state between the rasterization passes, we're going to stick to using the atomicMax trick for the hardware rasterization pass as well. The Nanite slides describe this in more detail if you want to learn more.</p>
<pre data-lang="rust" style="background-color:#002b36;color:#839496;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#859900;">@</span><span>fragment
</span><span style="color:#268bd2;">fn </span><span style="color:#b58900;">fragment</span><span style="color:#657b83;">(</span><span style="color:#268bd2;">vertex_output</span><span>: VertexOutput</span><span style="color:#657b83;">) {
</span><span>    </span><span style="color:#268bd2;">let</span><span> frag_coord_1d </span><span style="color:#657b83;">= </span><span style="color:#268bd2;">u32</span><span style="color:#657b83;">(</span><span>vertex_output.position.y</span><span style="color:#657b83;">) * </span><span style="color:#268bd2;">u32</span><span style="color:#657b83;">(</span><span>view.viewport.z</span><span style="color:#657b83;">) + </span><span style="color:#268bd2;">u32</span><span style="color:#657b83;">(</span><span>vertex_output.position.x</span><span style="color:#657b83;">)</span><span>;
</span><span>
</span><span>    </span><span style="color:#268bd2;">let</span><span> depth </span><span style="color:#657b83;">= </span><span>bitcast&lt;</span><span style="color:#268bd2;">u32</span><span>&gt;</span><span style="color:#657b83;">(</span><span>vertex_output.position.z</span><span style="color:#657b83;">)</span><span>;
</span><span>    </span><span style="color:#268bd2;">let</span><span> visibility </span><span style="color:#657b83;">= (</span><span style="color:#268bd2;">u64</span><span style="color:#657b83;">(</span><span>depth</span><span style="color:#657b83;">) &lt;&lt;</span><span> 32u</span><span style="color:#657b83;">) </span><span style="color:#859900;">| </span><span style="color:#268bd2;">u64</span><span style="color:#657b83;">(</span><span>vertex_output.packed_ids</span><span style="color:#657b83;">)</span><span>;
</span><span>    atomicMax</span><span style="color:#657b83;">(</span><span style="color:#859900;">&amp;</span><span>meshlet_visibility_buffer</span><span style="color:#657b83;">[</span><span>frag_coord_1d</span><span style="color:#657b83;">]</span><span>, visibility</span><span style="color:#657b83;">)</span><span>;
</span><span style="color:#657b83;">}
</span></code></pre>
<p>Special thanks to <a rel="nofollow noreferrer" href="https://github.com/atlv24">@atlv24</a> for adding 64-bit integers and atomic u64 support in wgpu 22, specifically so that I could use it here.</p>
<p>Note that there's a couple of improvements we could make here still, pending on support in wgpu and naga for some missing features:</p>
<ul>
<li>R64Uint texture atomics would both be faster than using buffers, and a bit more ergonomic to sample from and debug. This is hopefully coming in wgpu 24, again thanks to @atlv24.</li>
<li>Async compute would let us overlap the hardware and software rasterization passes, which would be safe since they're both writing to the same texture/buffer using atomics, which is another reason to stick with atomics for hardware raster.</li>
<li>Wgpu currently requires us to bind an empty render target for the hardware raster, even though we don't ever write to it, which is a waste of VRAM. Ideally we wouldn't need any bound render target.</li>
<li>And of course if we had mesh shaders, I wouldn't use a regular draw at all.</li>
</ul>
<h3 id="rewriting-the-indirect-dispatch">Rewriting the Indirect Dispatch<a class="zola-anchor" href="#rewriting-the-indirect-dispatch" aria-label="Anchor link for: rewriting-the-indirect-dispatch" style="visibility: hidden;"></a>
</h3>
<p>Before we get to software rasterization (soon, I promise!), we first have to deal with one final problem.</p>
<p>We're expecting to deal with a <em>lot</em> of visible clusters. For each software rasterized cluster, we're going to increment the X dimension of an indirect dispatch, with 1 workgroup per cluster. On some GPUs (mainly AMD), you're limited to 65536 workgroups per dispatch dimension, which is too low. We need to do the same trick we've done in the past of turning a 1d dispatch into a higher dimension dispatch (in this case 2d), and then reinterpreting it back as a 1d dispatch ID in the shader.</p>
<p>Since this is an indirect dispatch, we'll need to run a single-thread shader after the culling pass and before software rasterization, to do the 1d -&gt; 2d remap of the indirect dispatch arguments on the GPU.</p>
<pre data-lang="rust" style="background-color:#002b36;color:#839496;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#859900;">@</span><span>compute
</span><span style="color:#859900;">@workgroup_size</span><span style="color:#657b83;">(</span><span style="color:#6c71c4;">1</span><span>, </span><span style="color:#6c71c4;">1</span><span>, </span><span style="color:#6c71c4;">1</span><span style="color:#657b83;">)
</span><span style="color:#268bd2;">fn </span><span style="color:#b58900;">remap_dispatch</span><span style="color:#657b83;">() {
</span><span>    meshlet_software_raster_cluster_count </span><span style="color:#657b83;">=</span><span> meshlet_software_raster_indirect_args.x;
</span><span>
</span><span>    </span><span style="color:#859900;">if</span><span> meshlet_software_raster_cluster_count </span><span style="color:#657b83;">&gt;</span><span> max_compute_workgroups_per_dimension </span><span style="color:#657b83;">{
</span><span>        </span><span style="color:#268bd2;">let</span><span> n </span><span style="color:#657b83;">= </span><span style="color:#268bd2;">u32</span><span style="color:#657b83;">(</span><span style="color:#859900;">ceil</span><span style="color:#657b83;">(</span><span style="color:#859900;">sqrt</span><span style="color:#657b83;">(</span><span style="color:#268bd2;">f32</span><span style="color:#657b83;">(</span><span>meshlet_software_raster_cluster_count</span><span style="color:#657b83;">))))</span><span>;
</span><span>        meshlet_software_raster_indirect_args.x </span><span style="color:#657b83;">=</span><span> n;
</span><span>        meshlet_software_raster_indirect_args.y </span><span style="color:#657b83;">=</span><span> n;
</span><span>    </span><span style="color:#657b83;">}
</span><span style="color:#657b83;">}
</span></code></pre>
<h3 id="the-software-rasterizer">The Software Rasterizer<a class="zola-anchor" href="#the-software-rasterizer" aria-label="Anchor link for: the-software-rasterizer" style="visibility: hidden;"></a>
</h3>
<p>Finally, we can do software rasterization.</p>
<p>The basic idea is to have a compute shader workgroup with size equal to the max triangles per meshlet.</p>
<p>Each thread within the workgroup will load 1 vertex of the meshlet, transform it to screen-space, and then write it to workgroup shared memory and issue a barrier.</p>
<p>After the barrier, the workgroup will switch to handling triangles, with one thread per triangle. First each thread will load the 3 indices for its triangle, and then load the 3 vertices from workgroup shared memory based on the indices.</p>
<p>Once each thread has the 3 vertices for its triangle, it can compute the position/depth gradients across the triangle, and screen-space bounding box around the triangle.</p>
<p>Each thread can then iterate the bounding box (Like Nanite does, choosing to either iterate each pixel or iterate scanlines, based on the bounding box sizes across the subgroup), writing pixels to the visbuffer as it goes using the same atomicMax() method that we used for hardware rasterization.</p>
<p>One notable difference to the Nanite slides is that for the scanline variant, I needed to check if the pixel center was within the triangle for each pixel in the scanline, which the slides don't show. Not sure if the slides just omitted it for brevity or what, but I got artifacts if I left the check out.</p>
<p>There's also some slight differences between my shader and the GPU rasterizer - I didn't implement absolutely every detail. Notably I skipped fixed-point math and the top-left rule. I should implement these in the future, but for now I haven't seen any issues from skipping them.</p>
<h3 id="material-and-depth-resolve">Material and Depth Resolve<a class="zola-anchor" href="#material-and-depth-resolve" aria-label="Anchor link for: material-and-depth-resolve" style="visibility: hidden;"></a>
</h3>
<p>In Bevy 0.15, after the visbuffer rasterization, we have two final steps.</p>
<p>The resolve depth pass reads the visbuffer (which contains packed depth), and writes the depth to the actual depth texture of the camera.</p>
<pre data-lang="rust" style="background-color:#002b36;color:#839496;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#586e75;">/// This pass writes out the depth texture.
</span><span style="color:#859900;">@</span><span>fragment
</span><span style="color:#268bd2;">fn </span><span style="color:#b58900;">resolve_depth</span><span style="color:#657b83;">(</span><span style="color:#268bd2;">in</span><span>: FullscreenVertexOutput</span><span style="color:#657b83;">) </span><span>-&gt; </span><span style="color:#859900;">@builtin</span><span style="color:#657b83;">(</span><span>frag_depth</span><span style="color:#657b83;">) </span><span style="color:#268bd2;">f32 </span><span style="color:#657b83;">{
</span><span>    </span><span style="color:#268bd2;">let</span><span> frag_coord_1d </span><span style="color:#657b83;">= </span><span style="color:#268bd2;">u32</span><span style="color:#657b83;">(</span><span style="color:#859900;">in</span><span>.position.y</span><span style="color:#657b83;">) *</span><span> view_width </span><span style="color:#657b83;">+ </span><span style="color:#268bd2;">u32</span><span style="color:#657b83;">(</span><span style="color:#859900;">in</span><span>.position.x</span><span style="color:#657b83;">)</span><span>;
</span><span>    </span><span style="color:#268bd2;">let</span><span> visibility </span><span style="color:#657b83;">=</span><span> meshlet_visibility_buffer</span><span style="color:#657b83;">[</span><span>frag_coord_1d</span><span style="color:#657b83;">]</span><span>;
</span><span>    </span><span style="color:#859900;">return </span><span>bitcast&lt;</span><span style="color:#268bd2;">f32</span><span>&gt;</span><span style="color:#657b83;">(</span><span style="color:#268bd2;">u32</span><span style="color:#657b83;">(</span><span>visibility </span><span style="color:#657b83;">&gt;&gt;</span><span> 32u</span><span style="color:#657b83;">))</span><span>;
</span><span style="color:#657b83;">}
</span></code></pre>
<p>The resolve material depth pass has the same role in Bevy 0.15 that it did in Bevy 0.14, where it writes the material ID of each pixel to a depth texture, so that we can later abuse depth testing to ensure we shade the correct pixels during each material draw in the material shading pass.</p>
<p>However, you may have noticed that unlike the rasterization pass in Bevy 0.14, the new rasterization passes write only depth and cluster + triangle IDs, and not material IDs. During the rasterization pass, where we want to write only the absolute minimum amount of information per pixel (cluster ID, triangle ID, and depth) that we have to.</p>
<p>Because of this, the resolve material depth pass can no longer read the material ID texture and copy it directly to the material depth texture. There's now a new step at the start to first load the material ID based on the visbuffer.</p>
<pre data-lang="rust" style="background-color:#002b36;color:#839496;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#586e75;">/// This pass writes out the material depth texture.
</span><span style="color:#859900;">@</span><span>fragment
</span><span style="color:#268bd2;">fn </span><span style="color:#b58900;">resolve_material_depth</span><span style="color:#657b83;">(</span><span style="color:#268bd2;">in</span><span>: FullscreenVertexOutput</span><span style="color:#657b83;">) </span><span>-&gt; </span><span style="color:#859900;">@builtin</span><span style="color:#657b83;">(</span><span>frag_depth</span><span style="color:#657b83;">) </span><span style="color:#268bd2;">f32 </span><span style="color:#657b83;">{
</span><span>    </span><span style="color:#268bd2;">let</span><span> frag_coord_1d </span><span style="color:#657b83;">= </span><span style="color:#268bd2;">u32</span><span style="color:#657b83;">(</span><span style="color:#859900;">in</span><span>.position.y</span><span style="color:#657b83;">) *</span><span> view_width </span><span style="color:#657b83;">+ </span><span style="color:#268bd2;">u32</span><span style="color:#657b83;">(</span><span style="color:#859900;">in</span><span>.position.x</span><span style="color:#657b83;">)</span><span>;
</span><span>    </span><span style="color:#268bd2;">let</span><span> visibility </span><span style="color:#657b83;">=</span><span> meshlet_visibility_buffer</span><span style="color:#657b83;">[</span><span>frag_coord_1d</span><span style="color:#657b83;">]</span><span>;
</span><span>
</span><span>    </span><span style="color:#268bd2;">let</span><span> depth </span><span style="color:#657b83;">=</span><span> visibility </span><span style="color:#657b83;">&gt;&gt;</span><span> 32u;
</span><span>    </span><span style="color:#859900;">if</span><span> depth </span><span style="color:#657b83;">==</span><span> 0lu </span><span style="color:#657b83;">{ </span><span style="color:#859900;">return </span><span style="color:#6c71c4;">0.0</span><span>; </span><span style="color:#657b83;">}
</span><span>
</span><span>    </span><span style="color:#268bd2;">let</span><span> cluster_id </span><span style="color:#657b83;">= </span><span style="color:#268bd2;">u32</span><span style="color:#657b83;">(</span><span>visibility</span><span style="color:#657b83;">) &gt;&gt;</span><span> 7u;
</span><span>    </span><span style="color:#268bd2;">let</span><span> instance_id </span><span style="color:#657b83;">=</span><span> meshlet_cluster_instance_ids</span><span style="color:#657b83;">[</span><span>cluster_id</span><span style="color:#657b83;">]</span><span>;
</span><span>    </span><span style="color:#268bd2;">let</span><span> material_id </span><span style="color:#657b83;">=</span><span> meshlet_instance_material_ids</span><span style="color:#657b83;">[</span><span>instance_id</span><span style="color:#657b83;">]</span><span>;
</span><span>
</span><span>    </span><span style="color:#586e75;">// Everything above this line is new - the shader used to just load the
</span><span>    </span><span style="color:#586e75;">// material_id from another texture
</span><span>
</span><span>    </span><span style="color:#859900;">return </span><span style="color:#268bd2;">f32</span><span style="color:#657b83;">(</span><span>material_id</span><span style="color:#657b83;">) / </span><span style="color:#6c71c4;">65535.0</span><span>;
</span><span style="color:#657b83;">}
</span></code></pre>
<h3 id="retrospect">Retrospect<a class="zola-anchor" href="#retrospect" aria-label="Anchor link for: retrospect" style="visibility: hidden;"></a>
</h3>
<p>Software rasterization is a lot of complexity, learning, and work - I spent a lot of time researching how the GPU rasterizer works, rewrote a <em>lot</em> of code, and just writing the software rasterization shader itself and getting it bug-free took a week or two of effort. As you'll see later, I missed a couple of (severe) bugs, which will need correcting.</p>
<p>The upside is that performance is a <em>lot</em> better than my previous method (I'll show some numbers at the end of this post), and we can have thousands of tiny triangles on screen without hurting performance.</p>
<p>My advice to others working on virtual geometry is to skip software raster until close to the end. If you have mesh shaders, stick with those. From what I've heard from other projects, software raster is only a 10-20% performance improvement over mesh shaders in most scenes, unless you really crank the tiny triangle count (which is admittedly a goal, but not an immediate priority).</p>
<p>If like me, you don't have mesh shaders, then I would still probably stick with only hardware rasterization until you've exhausted other, more fundamental areas to work on, like culling and DAG building. However, I would learn from my mistakes, and not spend so much time trying to get hardware rasterization to be fast. Just stick to writing out a list of visible cluster IDs in the culling shader and have the vertex shader ignore extra triangles, instead of trying to get clever with writing out a buffer of visible triangles and drawing the minimum number of vertices. You'll eventually add software rasterization, and then the hardware rasterization performance won't be so important.</p>
<p>If you do want to implement a rasterizer in software (for virtual geometry, or otherwise), check out the below resources that were a big help for me in learning rasterization and the related math.</p>
<ul>
<li><a rel="nofollow noreferrer" href="https://kristoffer-dyrkorn.github.io/triangle-rasterizer">A fast and precise triangle rasterizer, by Kristoffer Dyrkorn</a></li>
<li><a rel="nofollow noreferrer" href="https://fgiesen.wordpress.com/2013/02/06/the-barycentric-conspirac">The barycentric conspiracy, by Fabian Giesen</a></li>
<li><a rel="nofollow noreferrer" href="https://www.youtube.com/watch?v=k5wtuKWmV48">Triangle Rasterization, by pikuma</a></li>
</ul>
<h2 id="larger-meshlet-sizes">Larger Meshlet Sizes<a class="zola-anchor" href="#larger-meshlet-sizes" aria-label="Anchor link for: larger-meshlet-sizes" style="visibility: hidden;"></a>
</h2>
<p>PR <a rel="nofollow noreferrer" href="https://github.com/bevyengine/bevy/pull/15023">#15023</a> has a bunch of small improvements to virtual geometry.</p>
<p>The main change is switching from a maximum 64 vertices and 64 triangles (<code>64v:64t</code>) to 255 vertices and 128 triangles per meshlet (<code>255v:128t</code>). I found that having a less than or equal <code>v:t</code> ratio leads to most meshlets having less than <code>t</code> triangles, which we don't want. Having a <code>2v:t</code> ratio leads to more fully-filled meshlets, and I went with <code>255v:128t</code> (which is nearly the same as Nanite, minus the fact that meshoptimizer only supports meshlets with up to 255 vertices) over <code>128v:64t</code> after some performance testing.</p>
<p>Note that this change involved some other work, such as adjusting software and hardware raster to work with more triangles, software rasterization looping if needed to load 2 vertices per thread instead of 1, using another bit per triangle ID when packing cluster + triangle IDs to accomodate triangles up to 127, etc.</p>
<p>The other changes I made were:</p>
<ul>
<li>Setting the target error when simplifying triangles to <code>f32::MAX</code> (no point in capping it for continuous LOD, gives better simplification results)</li>
<li>Adjusting the threshold to allow less-simplified meshes to still count as having been simplified enough (gets us closer to <code>log2(lod_0_meshlet_count)</code> total LOD levels)</li>
<li>Setting <code>group_error = max(group_error, all_child_errors)</code> instead of <code>group_error += max(all_child_errors)</code> (not really sure if this is more or less correct)</li>
</ul>
<h2 id="screenspace-derived-tangents">Screenspace-derived Tangents<a class="zola-anchor" href="#screenspace-derived-tangents" aria-label="Anchor link for: screenspace-derived-tangents" style="visibility: hidden;"></a>
</h2>
<p>PR <a rel="nofollow noreferrer" href="https://github.com/bevyengine/bevy/pull/15084">#15084</a> calculates tangents at runtime, instead of precomputing them and storing them as part of the MeshletMesh asset.</p>
<p>Virtual geometry isn't just about rasterizing huge amounts of high-poly meshes - asset size is also a <em>big</em> factor. GPUs only have so much memory, disks only have so much space, and transfer speeds from disk to RAM and RAM to VRAM are only so fast (as we discovered in the last post).</p>
<p>Looking at our asset data, right now we're storing 48 bytes per vertex, with a single set of vertices shared across all meshlets in a meshlet mesh.</p>
<pre data-lang="rust" style="background-color:#002b36;color:#839496;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#268bd2;">struct </span><span style="color:#b58900;">MeshletVertex </span><span style="color:#657b83;">{
</span><span>    </span><span style="color:#268bd2;">position</span><span>: vec3&lt;</span><span style="color:#268bd2;">f32</span><span>&gt;,
</span><span>    </span><span style="color:#268bd2;">normal</span><span>: vec3&lt;</span><span style="color:#268bd2;">f32</span><span>&gt;,
</span><span>    </span><span style="color:#268bd2;">uv</span><span>: vec2&lt;</span><span style="color:#268bd2;">f32</span><span>&gt;,
</span><span>    </span><span style="color:#268bd2;">tangent</span><span>: vec4&lt;</span><span style="color:#268bd2;">f32</span><span>&gt;,
</span><span style="color:#657b83;">}
</span></code></pre>
<p>An easy way to reduce the amount of data per asset is to just remove the explicitly-stored tangents, and instead calculate them at runtime. In the visbuffer resolve shader function, rather then loading 3 vertex tangents and interpolating across the triangle, we can instead calculate the tangent based on UV derivatives across the triangle.</p>
<p>The tangent derivation I used was <a rel="nofollow noreferrer" href="https://jcgt.org/published/0009/03/04">"Surface Gradient–Based Bump Mapping Framework"</a> from Morten S. Mikkelsen (author of the <a rel="nofollow noreferrer" href="http://www.metalliandy.com/mikktspace/tangent_space_normal_maps.html">mikktspace</a> standard). It's a really cool paper that provides a framework for using normal maps in many more scenarios than just screen-space based tangents. Definitely give it a further read.</p>
<p>I used the code from this <a rel="nofollow noreferrer" href="https://www.jeremyong.com/graphics/2023/12/16/surface-gradient-bump-mapping">blog post</a> by Jeremy Ong, which also does a great job motivating and explaining the paper.</p>
<p>The only issue I ran into is that the <code>tangent.w</code> always came out with the wrong sign compared to the existing mikktspace-tangents I had as a reference. I double checked my math and coordinate space handiness a couple of times, but could never figure out what was wrong. I ended up just inverting the sign after calculating the tangent. If anyone knows what I did wrong, please open an <a rel="nofollow noreferrer" href="https://github.com/bevyengine/bevy/issues">issue</a>!</p>
<pre data-lang="rust" style="background-color:#002b36;color:#839496;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#586e75;">// https://www.jeremyong.com/graphics/2023/12/16/surface-gradient-bump-mapping/#surface-gradient-from-a-tangent-space-normal-vector-without-an-explicit-tangent-basis
</span><span style="color:#268bd2;">fn </span><span style="color:#b58900;">calculate_world_tangent</span><span style="color:#657b83;">(
</span><span>    </span><span style="color:#268bd2;">world_normal</span><span>: vec3&lt;</span><span style="color:#268bd2;">f32</span><span>&gt;,
</span><span>    </span><span style="color:#268bd2;">ddx_world_position</span><span>: vec3&lt;</span><span style="color:#268bd2;">f32</span><span>&gt;,
</span><span>    </span><span style="color:#268bd2;">ddy_world_position</span><span>: vec3&lt;</span><span style="color:#268bd2;">f32</span><span>&gt;,
</span><span>    </span><span style="color:#268bd2;">ddx_uv</span><span>: vec2&lt;</span><span style="color:#268bd2;">f32</span><span>&gt;,
</span><span>    </span><span style="color:#268bd2;">ddy_uv</span><span>: vec2&lt;</span><span style="color:#268bd2;">f32</span><span>&gt;,
</span><span style="color:#657b83;">) </span><span>-&gt; vec4&lt;</span><span style="color:#268bd2;">f32</span><span>&gt; </span><span style="color:#657b83;">{
</span><span>    </span><span style="color:#586e75;">// Project the position gradients onto the tangent plane
</span><span>    </span><span style="color:#268bd2;">let</span><span> ddx_world_position_s </span><span style="color:#657b83;">=</span><span> ddx_world_position </span><span style="color:#657b83;">- </span><span style="color:#859900;">dot</span><span style="color:#657b83;">(</span><span>ddx_world_position, world_normal</span><span style="color:#657b83;">) *</span><span> world_normal;
</span><span>    </span><span style="color:#268bd2;">let</span><span> ddy_world_position_s </span><span style="color:#657b83;">=</span><span> ddy_world_position </span><span style="color:#657b83;">- </span><span style="color:#859900;">dot</span><span style="color:#657b83;">(</span><span>ddy_world_position, world_normal</span><span style="color:#657b83;">) *</span><span> world_normal;
</span><span>
</span><span>    </span><span style="color:#586e75;">// Compute the jacobian matrix to leverage the chain rule
</span><span>    </span><span style="color:#268bd2;">let</span><span> jacobian_sign </span><span style="color:#657b83;">= </span><span style="color:#859900;">sign</span><span style="color:#657b83;">(</span><span>ddx_uv.x </span><span style="color:#657b83;">*</span><span> ddy_uv.y </span><span style="color:#657b83;">-</span><span> ddx_uv.y </span><span style="color:#657b83;">*</span><span> ddy_uv.x</span><span style="color:#657b83;">)</span><span>;
</span><span>
</span><span>    var world_tangent </span><span style="color:#657b83;">=</span><span> jacobian_sign </span><span style="color:#657b83;">* (</span><span>ddy_uv.y </span><span style="color:#657b83;">*</span><span> ddx_world_position_s </span><span style="color:#657b83;">-</span><span> ddx_uv.y </span><span style="color:#657b83;">*</span><span> ddy_world_position_s</span><span style="color:#657b83;">)</span><span>;
</span><span>
</span><span>    </span><span style="color:#586e75;">// The sign intrinsic returns 0 if the argument is 0
</span><span>    </span><span style="color:#859900;">if</span><span> jacobian_sign </span><span style="color:#657b83;">!= </span><span style="color:#6c71c4;">0.0 </span><span style="color:#657b83;">{
</span><span>        world_tangent </span><span style="color:#657b83;">= </span><span style="color:#859900;">normalize</span><span style="color:#657b83;">(</span><span>world_tangent</span><span style="color:#657b83;">)</span><span>;
</span><span>    </span><span style="color:#657b83;">}
</span><span>
</span><span>    </span><span style="color:#586e75;">// The second factor here ensures a consistent handedness between
</span><span>    </span><span style="color:#586e75;">// the tangent frame and surface basis w.r.t. screenspace.
</span><span>    </span><span style="color:#268bd2;">let</span><span> w </span><span style="color:#657b83;">=</span><span> jacobian_sign </span><span style="color:#657b83;">* </span><span style="color:#859900;">sign</span><span style="color:#657b83;">(</span><span style="color:#859900;">dot</span><span style="color:#657b83;">(</span><span>ddy_world_position, </span><span style="color:#859900;">cross</span><span style="color:#657b83;">(</span><span>world_normal, ddx_world_position</span><span style="color:#657b83;">)))</span><span>;
</span><span>
</span><span>    </span><span style="color:#859900;">return vec4</span><span style="color:#657b83;">(</span><span>world_tangent, </span><span style="color:#657b83;">-</span><span>w</span><span style="color:#657b83;">)</span><span>; </span><span style="color:#586e75;">// TODO: Unclear why we need to negate this to match mikktspace generated tangents
</span><span style="color:#657b83;">}
</span></code></pre>
<p>At the cost of a few extra calculations in the material shading pass, and some slight inaccuracies compared to explicit tangents (mostly on curved surfaces), we save 16 bytes per vertex, both on disk (although LZ4 compression means we might be saving less in practice), and in memory.</p>
<p>16 bytes might not sound like a lot, but our high-poly meshes have a <em>lot</em> of vertices, so the savings are significant, especially in combination with the next PR.</p>
<table><thead><tr><th>Explicit Tangents (0.14)</th><th>Implicit tangents (0.15)</th></tr></thead><tbody>
<tr><td><img src="https://jms55.github.io/posts/2024-11-14-virtual-geometry-bevy-0-15/explicit_tangents.png" alt="Explicit tangents in Bevy 0.14" /></td><td><img src="https://jms55.github.io/posts/2024-11-14-virtual-geometry-bevy-0-15/implicit_tangents.png" alt="Implicit tangents in bevy 0.15" /></td></tr>
</tbody></table>
<p>Also of note is that while trying to debug the sign issue, I found that The Forge had published an <a rel="nofollow noreferrer" href="https://github.com/ConfettiFX/The-Forge/blob/9d43e69141a9cd0ce2ce2d2db5122234d3a2d5b5/Common_3/Renderer/VisibilityBuffer2/Shaders/FSL/vb_shading_utilities.h.fsl#L90-L150">updated version</a> of their partial derivatives calculations, fixing a small bug. I updated my WGSL port to match.</p>
<h2 id="compressed-per-meshlet-vertex-data">Compressed Per-Meshlet Vertex Data<a class="zola-anchor" href="#compressed-per-meshlet-vertex-data" aria-label="Anchor link for: compressed-per-meshlet-vertex-data" style="visibility: hidden;"></a>
</h2>
<p>PR <a rel="nofollow noreferrer" href="https://github.com/bevyengine/bevy/pull/15643">#15643</a> stores copies of the overall mesh's vertex attribute data per-meshlet, and then heavily compresses it.</p>
<h3 id="motivation-1">Motivation<a class="zola-anchor" href="#motivation-1" aria-label="Anchor link for: motivation-1" style="visibility: hidden;"></a>
</h3>
<p>The whole idea behind virtual geometry is that you only pay (as much as possible, it's of course not perfect) for the geometry currently needed on screen. Zoomed out? You pay the rasterization cost for only a few triangles at a higher LOD, and not for the entire mesh. Part of the mesh occluded? It gets culled. But continuing on with the theme from the last PR, memory usage is also a big cost. We might be able to render a large scene of high poly meshes with clever usage of LODs and culling, but can we afford to <em>store</em> all that mesh data to begin with in our GPU's measily 8-12gb of VRAM? (not even accounting for space taken up by material textures which will reduce our budget even further).</p>
<p>The way we fix this is with streaming. Rather than keep everything in memory all the time, you have the GPU write requests of what data it needs to a buffer, read that back onto the CPU, and then load the requested data from disk into a fixed-size GPU buffer. If the GPU no longer needs a piece of data, you mark that section of the buffer as free space, and can write new data to it as new requests come in.</p>
<p>Typical implementations of mesh streaming stream discrete LOD levels, but our goal is to be much more fine-grained. Keeping with the theme of only paying for the cluster data you need actually need to render the current frame, we want to stream individual meshlets, not whole LOD levels (in practice, Nanite streams fixed-size pages of meshlet data, and not individual meshlets). This presents a problem with our current implementation: since all meshlets reference the same set of vertex data, we have no simple way of unloading or loading vertex data for a single meshlet. While I'm not going to tackle streaming in Bevy 0.15, in this PR I'll be changing the way we store vertex data to solve this problem and unblock streaming in the future.</p>
<p>Up until now, each MeshletMesh has had one set of vertex data shared between all meshlets within the mesh. Each meshlet has a local index buffer, mapping triangles to meshlet-local vertex IDs, and then a global index buffer mapping meshlet-local vetex IDs to actual vertex data from the mesh. E.g. triangle corner X within a meshlet points to vertex ID Y within a meshlet which points to vertex Z within the mesh.</p>
<p>In order to support streaming, we're going to move to a new scheme. We will store a copy of vertex data for each meshlet, concatenated together into one slice. All the vertex data for meshlet 0 will be stored as one contiguous slice, with all the vertex data for meshlet 1 stored contiguously after it, and all the vertex data for meshlet 2 after <em>that</em>, etc.</p>
<p>Each meshlet's local index buffer will point directly into vertices within the meshlet's vertex data slice, stored as an offset relative to the starting index of the meshlet's vertex data slice within the overall buffer. E.g. triangle corner X within a meshlet points to vertex Y within the meshlet directly.</p>
<p>Besides unblocking streaming, this scheme is also much simpler to reason about, uses less dependent memory reads, and works much nicer with our software rasterization pass where each thread in the workgroup is loading a single meshlet vertex into workgroup shared memory.</p>
<p>That was a lot of background and explanation for what's really a rather simple change, so let me finally get to the main topic of this PR: the problem with duplicating vertex data per meshlet is that we've just increased the size of our MeshletMesh asset by a thousandfold.</p>
<p>The solution is quantization and compression.</p>
<h3 id="position-compression">Position Compression<a class="zola-anchor" href="#position-compression" aria-label="Anchor link for: position-compression" style="visibility: hidden;"></a>
</h3>
<p>Meshlets compress pretty well. Starting with vertex positions, there's no reason we need to store a full <code>vec3&lt;f32&gt;</code> per vertex. Most meshlets tend to enclose a fairly small amount of space. Instead of storing vertex positions as coordinates relative to the mesh center origin, we can instead store them in some coordinate space relative to the meshlet bounds.</p>
<p>For each meshlet, we'll iterate over all of its vertex positions, and calculate the min and max value for each of the X/Y/Z axis. Then, we can remap each position relative to those bounds by doing <code>p -= min</code>. The positions initially range from <code>[min, max]</code>, and then range from <code>[0, max - min]</code> after remapping. We can store the <code>min</code> values for each of the X/Y/Z axis (as a full <code>f32</code> each) in the meshlet metadata, and in the shader reverse the remapping by doing <code>p += min</code>.</p>
<p>Our first (albeit small) saving become apparent: at the cost of 12 extra bytes in the meshlet metadata, we save 3 bits per vertex position due to no longer needing a bit for the sign for each of the X/Y/Z values, as <code>[0, max - min]</code> is never going to contain any negative numbers. We technically now only need a hypothetical <code>f31</code> per axis.</p>
<p>However, there's a another trick we can perform. If we take the ceiling of the log2 of a range of floating point values <code>ceil(log2(max - min + 1))</code>, we get the minimum number of bits we need to store any value in that range. Rather than storing meshlet vertex positions as a list of <code>vec3&lt;f32&gt;</code>s, we could instead store them as a packed list of bits (a bitstream).</p>
<p>E.g. if we determine that we need 4/7/3 bits for the X/Y/Z ranges of the meshlet, we could store a list of bits where bits 0..4 are for vertex 0 axis X, bits 4..11 are for vertex 0 axis Y, bits 11..14 are for vertex 0 axis Z, bits 14..18 are for vertex 1 axis X, bits 18..25 are for vertex 1 axis Y, etc.</p>
<p>Again we can store the bit size (as a <code>u8</code>) for each of the X/Y/Z axis within the meshlet's metadata, at a cost of 3 extra bytes. We'll use this later in our shaders to figure out how many bits to read from the bistream for each of the meshlet's vertices.</p>
<p>In practice, if you try this out as-is, you're probably going to end up with fairly large bit sizes per axis, and not actually save any space vs using <code>vec3&lt;f32&gt;</code>. This is due to the large amount of precision we have in our vertex positions (a full <code>f32</code>), which leads to a lot of precision needed in the range, and therefore a large bit size.</p>
<p>The final trick up our sleeves is that we don't actually <em>need</em> all this precision. If we know that our meshlet's vertices range from 10.2041313123 to 84.382543538, do we really need to know that a vertex happens to be stored at <em>exactly</em> 57.594392822? We could pick some arbitrary amount of precision to round each of our vertices to, say four decimal places, resulting in 57.5944. Less precision means a less precise range, which means our bit size will be smaller.</p>
<center>
<p><img src="https://jms55.github.io/posts/2024-11-14-virtual-geometry-bevy-0-15/quantize_error.png" alt="Too much quantization" />
<em>Don't quantize too much, or you'll get bugs!</em></p>
</center>
<p>Better yet, lets pick some factor <code>q = 2^p</code>, where <code>p</code> is some arbitrary <code>u8</code> integer. Now, lets snap each vertex to the nearest point on the grid that's a multiple of <code>1/q</code>, and then store the vertex as the number of "steps" of size <code>1/q</code> that we took from the origin to reach the snapped vertex position (a fixed-point representation). E.g. if we say <code>p = 4</code>, then we're quantizing to a grid with a resolution of <code>1/16</code>, so <code>v = 57.594392822</code> would snap to <code>v = 57.625</code> (throwing away some unnecessary precision) and we would store that as <code>v = round(57.594392822 / (1/16)) = i32(57.594392822 * 16 + 0.5) = 922</code>. This is once again easily reversible in our shader so long as we have our factor <code>p</code>: <code>922 / 2^4 = 57.625</code>.</p>
<p>The factor <code>p</code> we choose is not particularly important. I set it to 4 by default (with an additional factor to convert from Bevy's meters to the more appropriate-for-this-use-case unit of centimeters), but users can choose a good value themselves if 4 is too high (unnecessary precision = larger bit sizes and therefore larger asset sizes), or too low (visible mesh deformity from snapping the vertices too-coarsely). Nanite has an automatic heuristic that I assume is based on some kind of triangle surface area to mesh size ratio, but also lets users choose <code>p</code> manually. The important thing to note is that you should <em>not</em> choose <code>p</code> per-meshlet, i.e. <code>p</code> should be the same for every meshlet within the mesh. Otherwise, you'll end up with cracks between meshlets.</p>
<p>Finally, we can combine all three of these tricks. We can quantize our meshlet's vertices, find the per-axis min/max values and remap to a better range, and then store as a packed bitstream using the minimum number of bits for the range. The final code to compress a meshlet's vertex positions is below.</p>
<pre data-lang="rust" style="background-color:#002b36;color:#839496;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#268bd2;">let</span><span> quantization_factor </span><span style="color:#657b83;">=
</span><span>    </span><span style="color:#657b83;">(</span><span style="color:#6c71c4;">1 </span><span style="color:#657b83;">&lt;&lt;</span><span> vertex_position_quantization_factor</span><span style="color:#657b83;">) </span><span style="color:#859900;">as </span><span style="color:#268bd2;">f32 </span><span style="color:#657b83;">* </span><span style="color:#cb4b16;">CENTIMETERS_PER_METER</span><span>;
</span><span>
</span><span style="color:#268bd2;">let </span><span style="color:#93a1a1;">mut</span><span> min_quantized_position_channels </span><span style="color:#657b83;">= </span><span>IVec3::</span><span style="color:#cb4b16;">MAX</span><span>;
</span><span style="color:#268bd2;">let </span><span style="color:#93a1a1;">mut</span><span> max_quantized_position_channels </span><span style="color:#657b83;">= </span><span>IVec3::</span><span style="color:#cb4b16;">MIN</span><span>;
</span><span>
</span><span style="color:#586e75;">// Lossy vertex compression
</span><span style="color:#268bd2;">let </span><span style="color:#93a1a1;">mut</span><span> quantized_positions </span><span style="color:#657b83;">= [</span><span>IVec3::</span><span style="color:#cb4b16;">ZERO</span><span>; </span><span style="color:#6c71c4;">255</span><span style="color:#657b83;">]</span><span>;
</span><span style="color:#859900;">for </span><span style="color:#657b83;">(</span><span>i, vertex_id</span><span style="color:#657b83;">) </span><span style="color:#859900;">in</span><span> meshlet_vertex_ids.</span><span style="color:#859900;">iter</span><span style="color:#657b83;">()</span><span>.</span><span style="color:#859900;">enumerate</span><span style="color:#657b83;">() {
</span><span>    </span><span style="color:#268bd2;">let</span><span> position </span><span style="color:#657b83;">= </span><span style="color:#859900;">...</span><span>;
</span><span>
</span><span>    </span><span style="color:#586e75;">// Quantize position to a fixed-point IVec3
</span><span>    </span><span style="color:#268bd2;">let</span><span> quantized_position </span><span style="color:#657b83;">= (</span><span>position </span><span style="color:#657b83;">*</span><span> quantization_factor </span><span style="color:#657b83;">+ </span><span style="color:#6c71c4;">0.5</span><span style="color:#657b83;">)</span><span>.</span><span style="color:#859900;">as_ivec3</span><span style="color:#657b83;">()</span><span>;
</span><span>    quantized_positions</span><span style="color:#657b83;">[</span><span>i</span><span style="color:#657b83;">] =</span><span> quantized_position;
</span><span>
</span><span>    </span><span style="color:#586e75;">// Compute per X/Y/Z-channel quantized position min/max for this meshlet
</span><span>    min_quantized_position_channels </span><span style="color:#657b83;">=</span><span> min_quantized_position_channels.</span><span style="color:#859900;">min</span><span style="color:#657b83;">(</span><span>quantized_position</span><span style="color:#657b83;">)</span><span>;
</span><span>    max_quantized_position_channels </span><span style="color:#657b83;">=</span><span> max_quantized_position_channels.</span><span style="color:#859900;">max</span><span style="color:#657b83;">(</span><span>quantized_position</span><span style="color:#657b83;">)</span><span>;
</span><span style="color:#657b83;">}
</span><span>
</span><span style="color:#586e75;">// Calculate bits needed to encode each quantized vertex position channel based on the range of each channel
</span><span style="color:#268bd2;">let</span><span> range </span><span style="color:#657b83;">=</span><span> max_quantized_position_channels </span><span style="color:#657b83;">-</span><span> min_quantized_position_channels </span><span style="color:#657b83;">+ </span><span style="color:#6c71c4;">1</span><span>;
</span><span style="color:#268bd2;">let</span><span> bits_per_vertex_position_channel_x </span><span style="color:#657b83;">= </span><span style="color:#859900;">log2</span><span style="color:#657b83;">(</span><span>range.x </span><span style="color:#859900;">as </span><span style="color:#268bd2;">f32</span><span style="color:#657b83;">)</span><span>.</span><span style="color:#859900;">ceil</span><span style="color:#657b83;">() </span><span style="color:#859900;">as </span><span style="color:#268bd2;">u8</span><span>;
</span><span style="color:#268bd2;">let</span><span> bits_per_vertex_position_channel_y </span><span style="color:#657b83;">= </span><span style="color:#859900;">log2</span><span style="color:#657b83;">(</span><span>range.y </span><span style="color:#859900;">as </span><span style="color:#268bd2;">f32</span><span style="color:#657b83;">)</span><span>.</span><span style="color:#859900;">ceil</span><span style="color:#657b83;">() </span><span style="color:#859900;">as </span><span style="color:#268bd2;">u8</span><span>;
</span><span style="color:#268bd2;">let</span><span> bits_per_vertex_position_channel_z </span><span style="color:#657b83;">= </span><span style="color:#859900;">log2</span><span style="color:#657b83;">(</span><span>range.z </span><span style="color:#859900;">as </span><span style="color:#268bd2;">f32</span><span style="color:#657b83;">)</span><span>.</span><span style="color:#859900;">ceil</span><span style="color:#657b83;">() </span><span style="color:#859900;">as </span><span style="color:#268bd2;">u8</span><span>;
</span><span>
</span><span style="color:#586e75;">// Lossless encoding of vertex positions in the minimum number of bits per channel
</span><span style="color:#859900;">for</span><span> quantized_position </span><span style="color:#859900;">in</span><span> quantized_positions.</span><span style="color:#859900;">iter</span><span style="color:#657b83;">()</span><span>.</span><span style="color:#859900;">take</span><span style="color:#657b83;">(</span><span>meshlet_vertex_ids.</span><span style="color:#859900;">len</span><span style="color:#657b83;">()) {
</span><span>    </span><span style="color:#586e75;">// Remap [range_min, range_max] IVec3 to [0, range_max - range_min] UVec3
</span><span>    </span><span style="color:#268bd2;">let</span><span> position </span><span style="color:#657b83;">= (</span><span>quantized_position </span><span style="color:#657b83;">-</span><span> min_quantized_position_channels</span><span style="color:#657b83;">)</span><span>.</span><span style="color:#859900;">as_uvec3</span><span style="color:#657b83;">()</span><span>;
</span><span>
</span><span>    </span><span style="color:#586e75;">// Store as a packed bitstream
</span><span>    vertex_positions.</span><span style="color:#859900;">extend_from_bitslice</span><span style="color:#657b83;">(
</span><span>        </span><span style="color:#859900;">&amp;</span><span>position.x.view_bits::&lt;Lsb0&gt;</span><span style="color:#657b83;">()[</span><span style="color:#859900;">..</span><span>bits_per_vertex_position_channel_x </span><span style="color:#859900;">as </span><span style="color:#268bd2;">usize</span><span style="color:#657b83;">]</span><span>,
</span><span>    </span><span style="color:#657b83;">)</span><span>;
</span><span>    vertex_positions.</span><span style="color:#859900;">extend_from_bitslice</span><span style="color:#657b83;">(
</span><span>        </span><span style="color:#859900;">&amp;</span><span>position.y.view_bits::&lt;Lsb0&gt;</span><span style="color:#657b83;">()[</span><span style="color:#859900;">..</span><span>bits_per_vertex_position_channel_y </span><span style="color:#859900;">as </span><span style="color:#268bd2;">usize</span><span style="color:#657b83;">]</span><span>,
</span><span>    </span><span style="color:#657b83;">)</span><span>;
</span><span>    vertex_positions.</span><span style="color:#859900;">extend_from_bitslice</span><span style="color:#657b83;">(
</span><span>        </span><span style="color:#859900;">&amp;</span><span>position.z.view_bits::&lt;Lsb0&gt;</span><span style="color:#657b83;">()[</span><span style="color:#859900;">..</span><span>bits_per_vertex_position_channel_z </span><span style="color:#859900;">as </span><span style="color:#268bd2;">usize</span><span style="color:#657b83;">]</span><span>,
</span><span>    </span><span style="color:#657b83;">)</span><span>;
</span><span style="color:#657b83;">}
</span></code></pre>
<h3 id="position-decoding">Position Decoding<a class="zola-anchor" href="#position-decoding" aria-label="Anchor link for: position-decoding" style="visibility: hidden;"></a>
</h3>
<p>Before this PR, our meshlet metadata was this 16-byte type:</p>
<pre data-lang="rust" style="background-color:#002b36;color:#839496;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#93a1a1;">pub </span><span style="color:#268bd2;">struct </span><span style="color:#b58900;">Meshlet </span><span style="color:#657b83;">{
</span><span>    </span><span style="color:#586e75;">/// The offset within the parent mesh&#39;s [`MeshletMesh::vertex_ids`] buffer where the indices for this meshlet begin.
</span><span>    </span><span style="color:#93a1a1;">pub </span><span style="color:#268bd2;">start_vertex_id</span><span>: </span><span style="color:#268bd2;">u32</span><span>,
</span><span>    </span><span style="color:#586e75;">/// The offset within the parent mesh&#39;s [`MeshletMesh::indices`] buffer where the indices for this meshlet begin.
</span><span>    </span><span style="color:#93a1a1;">pub </span><span style="color:#268bd2;">start_index_id</span><span>: </span><span style="color:#268bd2;">u32</span><span>,
</span><span>    </span><span style="color:#586e75;">/// The amount of vertices in this meshlet.
</span><span>    </span><span style="color:#93a1a1;">pub </span><span style="color:#268bd2;">vertex_count</span><span>: </span><span style="color:#268bd2;">u32</span><span>,
</span><span>    </span><span style="color:#586e75;">/// The amount of triangles in this meshlet.
</span><span>    </span><span style="color:#93a1a1;">pub </span><span style="color:#268bd2;">triangle_count</span><span>: </span><span style="color:#268bd2;">u32</span><span>,
</span><span style="color:#657b83;">}
</span></code></pre>
<p>With all the custom compression, we need to store some more info, giving us this carefully-packed 32-byte type (a little bit bigger, but reducing size for vertices is much more important than reducing the size of the meshlet metadata):</p>
<pre data-lang="rust" style="background-color:#002b36;color:#839496;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#93a1a1;">pub </span><span style="color:#268bd2;">struct </span><span style="color:#b58900;">Meshlet </span><span style="color:#657b83;">{
</span><span>    </span><span style="color:#586e75;">/// The bit offset within the parent mesh&#39;s [`MeshletMesh::vertex_positions`] buffer where the vertex positions for this meshlet begin.
</span><span>    </span><span style="color:#93a1a1;">pub </span><span style="color:#268bd2;">start_vertex_position_bit</span><span>: </span><span style="color:#268bd2;">u32</span><span>,
</span><span>    </span><span style="color:#586e75;">/// The offset within the parent mesh&#39;s [`MeshletMesh::vertex_normals`] and [`MeshletMesh::vertex_uvs`] buffers
</span><span>    </span><span style="color:#586e75;">/// where non-position vertex attributes for this meshlet begin.
</span><span>    </span><span style="color:#93a1a1;">pub </span><span style="color:#268bd2;">start_vertex_attribute_id</span><span>: </span><span style="color:#268bd2;">u32</span><span>,
</span><span>    </span><span style="color:#586e75;">/// The offset within the parent mesh&#39;s [`MeshletMesh::indices`] buffer where the indices for this meshlet begin.
</span><span>    </span><span style="color:#93a1a1;">pub </span><span style="color:#268bd2;">start_index_id</span><span>: </span><span style="color:#268bd2;">u32</span><span>,
</span><span>    </span><span style="color:#586e75;">/// The amount of vertices in this meshlet.
</span><span>    </span><span style="color:#93a1a1;">pub </span><span style="color:#268bd2;">vertex_count</span><span>: </span><span style="color:#268bd2;">u8</span><span>,
</span><span>    </span><span style="color:#586e75;">/// The amount of triangles in this meshlet.
</span><span>    </span><span style="color:#93a1a1;">pub </span><span style="color:#268bd2;">triangle_count</span><span>: </span><span style="color:#268bd2;">u8</span><span>,
</span><span>    </span><span style="color:#586e75;">/// Unused (needed to satisfy alignment rules).
</span><span>    </span><span style="color:#93a1a1;">pub </span><span style="color:#268bd2;">padding</span><span>: </span><span style="color:#268bd2;">u16</span><span>,
</span><span>    </span><span style="color:#586e75;">/// Number of bits used to to store the X channel of vertex positions within this meshlet.
</span><span>    </span><span style="color:#93a1a1;">pub </span><span style="color:#268bd2;">bits_per_vertex_position_channel_x</span><span>: </span><span style="color:#268bd2;">u8</span><span>,
</span><span>    </span><span style="color:#586e75;">/// Number of bits used to to store the Y channel of vertex positions within this meshlet.
</span><span>    </span><span style="color:#93a1a1;">pub </span><span style="color:#268bd2;">bits_per_vertex_position_channel_y</span><span>: </span><span style="color:#268bd2;">u8</span><span>,
</span><span>    </span><span style="color:#586e75;">/// Number of bits used to to store the Z channel of vertex positions within this meshlet.
</span><span>    </span><span style="color:#93a1a1;">pub </span><span style="color:#268bd2;">bits_per_vertex_position_channel_z</span><span>: </span><span style="color:#268bd2;">u8</span><span>,
</span><span>    </span><span style="color:#586e75;">/// Power of 2 factor used to quantize vertex positions within this meshlet.
</span><span>    </span><span style="color:#93a1a1;">pub </span><span style="color:#268bd2;">vertex_position_quantization_factor</span><span>: </span><span style="color:#268bd2;">u8</span><span>,
</span><span>    </span><span style="color:#586e75;">/// Minimum quantized X channel value of vertex positions within this meshlet.
</span><span>    </span><span style="color:#93a1a1;">pub </span><span style="color:#268bd2;">min_vertex_position_channel_x</span><span>: </span><span style="color:#268bd2;">f32</span><span>,
</span><span>    </span><span style="color:#586e75;">/// Minimum quantized Y channel value of vertex positions within this meshlet.
</span><span>    </span><span style="color:#93a1a1;">pub </span><span style="color:#268bd2;">min_vertex_position_channel_y</span><span>: </span><span style="color:#268bd2;">f32</span><span>,
</span><span>    </span><span style="color:#586e75;">/// Minimum quantized Z channel value of vertex positions within this meshlet.
</span><span>    </span><span style="color:#93a1a1;">pub </span><span style="color:#268bd2;">min_vertex_position_channel_z</span><span>: </span><span style="color:#268bd2;">f32</span><span>,
</span><span style="color:#657b83;">}
</span></code></pre>
<p>To fetch a single vertex from the bitstream (we we bind as an array of <code>u32</code>s), we can use this function:</p>
<pre data-lang="rust" style="background-color:#002b36;color:#839496;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#268bd2;">fn </span><span style="color:#b58900;">get_meshlet_vertex_position</span><span style="color:#657b83;">(</span><span style="color:#268bd2;">meshlet</span><span>: ptr&lt;function, Meshlet&gt;, </span><span style="color:#268bd2;">vertex_id</span><span>: </span><span style="color:#268bd2;">u32</span><span style="color:#657b83;">) </span><span>-&gt; vec3&lt;</span><span style="color:#268bd2;">f32</span><span>&gt; </span><span style="color:#657b83;">{
</span><span>    </span><span style="color:#586e75;">// Get bitstream start for the vertex
</span><span>    </span><span style="color:#268bd2;">let</span><span> unpacked </span><span style="color:#657b83;">=</span><span> unpack4xU8</span><span style="color:#657b83;">((*</span><span>meshlet</span><span style="color:#657b83;">)</span><span>.packed_b</span><span style="color:#657b83;">)</span><span>;
</span><span>    </span><span style="color:#268bd2;">let</span><span> bits_per_channel </span><span style="color:#657b83;">=</span><span> unpacked.xyz;
</span><span>    </span><span style="color:#268bd2;">let</span><span> bits_per_vertex </span><span style="color:#657b83;">=</span><span> bits_per_channel.x </span><span style="color:#657b83;">+</span><span> bits_per_channel.y </span><span style="color:#657b83;">+</span><span> bits_per_channel.z;
</span><span>    var start_bit </span><span style="color:#657b83;">= (*</span><span>meshlet</span><span style="color:#657b83;">)</span><span>.start_vertex_position_bit </span><span style="color:#657b83;">+ (</span><span>vertex_id </span><span style="color:#657b83;">*</span><span> bits_per_vertex</span><span style="color:#657b83;">)</span><span>;
</span><span>
</span><span>    </span><span style="color:#586e75;">// Read each vertex channel from the bitstream
</span><span>    var vertex_position_packed </span><span style="color:#657b83;">= </span><span style="color:#859900;">vec3</span><span style="color:#657b83;">(</span><span>0u</span><span style="color:#657b83;">)</span><span>;
</span><span>    </span><span style="color:#859900;">for </span><span style="color:#657b83;">(</span><span>var i </span><span style="color:#657b83;">=</span><span> 0u; i </span><span style="color:#657b83;">&lt;</span><span> 3u; i</span><span style="color:#657b83;">++) {
</span><span>        </span><span style="color:#268bd2;">let</span><span> lower_word_index </span><span style="color:#657b83;">=</span><span> start_bit </span><span style="color:#657b83;">/</span><span> 32u;
</span><span>        </span><span style="color:#268bd2;">let</span><span> lower_word_bit_offset </span><span style="color:#657b83;">=</span><span> start_bit </span><span style="color:#859900;">&amp;</span><span> 31u;
</span><span>        var next_32_bits </span><span style="color:#657b83;">=</span><span> meshlet_vertex_positions</span><span style="color:#657b83;">[</span><span>lower_word_index</span><span style="color:#657b83;">] &gt;&gt;</span><span> lower_word_bit_offset;
</span><span>        </span><span style="color:#859900;">if</span><span> lower_word_bit_offset </span><span style="color:#657b83;">+</span><span> bits_per_channel</span><span style="color:#657b83;">[</span><span>i</span><span style="color:#657b83;">] &gt;</span><span> 32u </span><span style="color:#657b83;">{
</span><span>            next_32_bits </span><span style="color:#657b83;">|=</span><span> meshlet_vertex_positions</span><span style="color:#657b83;">[</span><span>lower_word_index </span><span style="color:#657b83;">+</span><span> 1u</span><span style="color:#657b83;">] &lt;&lt; (</span><span>32u </span><span style="color:#657b83;">-</span><span> lower_word_bit_offset</span><span style="color:#657b83;">)</span><span>;
</span><span>        </span><span style="color:#657b83;">}
</span><span>        vertex_position_packed</span><span style="color:#657b83;">[</span><span>i</span><span style="color:#657b83;">] =</span><span> extractBits</span><span style="color:#657b83;">(</span><span>next_32_bits, 0u, bits_per_channel</span><span style="color:#657b83;">[</span><span>i</span><span style="color:#657b83;">])</span><span>;
</span><span>        start_bit </span><span style="color:#657b83;">+=</span><span> bits_per_channel</span><span style="color:#657b83;">[</span><span>i</span><span style="color:#657b83;">]</span><span>;
</span><span>    </span><span style="color:#657b83;">}
</span><span>
</span><span>    </span><span style="color:#586e75;">// Remap [0, range_max - range_min] vec3&lt;u32&gt; to [range_min, range_max] vec3&lt;f32&gt;
</span><span>    var vertex_position </span><span style="color:#657b83;">= </span><span>vec3&lt;</span><span style="color:#268bd2;">f32</span><span>&gt;</span><span style="color:#657b83;">(</span><span>vertex_position_packed</span><span style="color:#657b83;">) + </span><span style="color:#859900;">vec3</span><span style="color:#657b83;">(
</span><span>        </span><span style="color:#657b83;">(*</span><span>meshlet</span><span style="color:#657b83;">)</span><span>.min_vertex_position_channel_x,
</span><span>        </span><span style="color:#657b83;">(*</span><span>meshlet</span><span style="color:#657b83;">)</span><span>.min_vertex_position_channel_y,
</span><span>        </span><span style="color:#657b83;">(*</span><span>meshlet</span><span style="color:#657b83;">)</span><span>.min_vertex_position_channel_z,
</span><span>    </span><span style="color:#657b83;">)</span><span>;
</span><span>
</span><span>    </span><span style="color:#586e75;">// Reverse vertex quantization
</span><span>    </span><span style="color:#268bd2;">let</span><span> vertex_position_quantization_factor </span><span style="color:#657b83;">=</span><span> unpacked.w;
</span><span>    vertex_position </span><span style="color:#657b83;">/= </span><span style="color:#268bd2;">f32</span><span style="color:#657b83;">(</span><span>1u </span><span style="color:#657b83;">&lt;&lt;</span><span> vertex_position_quantization_factor</span><span style="color:#657b83;">) * </span><span style="color:#cb4b16;">CENTIMETERS_PER_METER</span><span>;
</span><span>
</span><span>    </span><span style="color:#859900;">return</span><span> vertex_position;
</span><span style="color:#657b83;">}
</span></code></pre>
<p>This could probably be written better - right now we're doing a minimum of 3 <code>u32</code> reads (1 per channel), but there's a good chance that a single <code>u32</code> read will contain the data for all 3 channels of the vertex. Something to optimize in the future.</p>
<h3 id="other-attributes">Other Attributes<a class="zola-anchor" href="#other-attributes" aria-label="Anchor link for: other-attributes" style="visibility: hidden;"></a>
</h3>
<p>Now that we've done positions, lets talk about how to handle other vertex attributes.</p>
<p>Tangents we already removed in the last PR.</p>
<p>For UVs, I currently store them uncompressed. I could have maybe used half-precision floating point values, but I am wary of artifacts resulting from the reduced precision, so for right now it's a full <code>vec2&lt;f32&gt;</code>. This is a big opportunity for future improvement.</p>
<p>Normals are a bit more interesting. They start as <code>vec3&lt;f32&gt;</code>. I first perform an octahedral encoding on them, bringing them down to a <code>vec2&lt;f32&gt;</code> near-losessly. I then give up some precision to reduce the size even further by using <code>pack2x16snorm()</code>, bringing it down to a <code>vec2&lt;f16&gt;</code>, or a packed <code>u32</code>. These operations are easily reversed in the shader using the built-in <code>unpack2x16snorm()</code> function, and then the simple octahedral decode step.</p>
<p>I <em>did</em> try a bitstream encoding similiar to what I did for positions, but couldn't get any smaller sizes than a simple <code>pack2x16snorm()</code>. I think with more time and motivation (I was getting burnt out by the end of this), I could have probably figured out a good variable-size octahedral encoding for normals as well. Something else to investigate in the future.</p>
<h3 id="results">Results<a class="zola-anchor" href="#results" aria-label="Anchor link for: results" style="visibility: hidden;"></a>
</h3>
<p>After all this, how much memory savings did we get?</p>
<p>Disk space is practically unchanged (maybe 2% smaller at best), but memory savings on a test mesh went from <code>110 MB</code> before this PR (without duplicating the vertex data per-meshlet at all), to <code>64 MB</code> after this PR (copying and compressing vertex data per-meshlet). This is a huge savings (<code>42%</code> smaller), with room for future improvements! I'll definitely be coming back to this at some point in the future.</p>
<p>Additional references:</p>
<ul>
<li><a rel="nofollow noreferrer" href="https://advances.realtimerendering.com/s2021/Karis_Nanite_SIGGRAPH_Advances_2021_final.pdf#page=128">https://advances.realtimerendering.com/s2021/Karis_Nanite_SIGGRAPH_Advances_2021_final.pdf#page=128</a></li>
<li><a rel="nofollow noreferrer" href="https://arxiv.org/abs/2404.06359">https://arxiv.org/abs/2404.06359</a> (also compresses the index buffer, not just vertices!)</li>
<li><a rel="nofollow noreferrer" href="https://daniilvinn.github.io/2024/05/04/omniforce-vertex-quantization.html">https://daniilvinn.github.io/2024/05/04/omniforce-vertex-quantization.html</a></li>
<li><a rel="nofollow noreferrer" href="https://gpuopen.com/download/publications/DGF.pdf">https://gpuopen.com/download/publications/DGF.pdf</a> (more focused on raytracing than rasterization)</li>
</ul>
<h2 id="improved-lod-selection-heuristic">Improved LOD Selection Heuristic<a class="zola-anchor" href="#improved-lod-selection-heuristic" aria-label="Anchor link for: improved-lod-selection-heuristic" style="visibility: hidden;"></a>
</h2>
<p>PR <a rel="nofollow noreferrer" href="https://github.com/bevyengine/bevy/pull/15846">#15846</a> changes how we select the LOD cut.</p>
<p>Previously, I was building a bounding sphere around each group with radius based on the group error, and then projecting that to screen space to get the visible error in pixels.</p>
<p>That method worked, but isn't entirely watertight. Where you place the bounding sphere center in the group is kind of arbitrary, right? And how do you ensure that the error projection is perfectly monotonic, if you have these random bounding spheres in each group?</p>
<p>Arseny Kapoulkine once again helped me out here. As part of meshoptimizer, they started experimenting with their <a rel="nofollow noreferrer" href="https://github.com/zeux/meshoptimizer/blob/d93419ced5956307f41333c500c8037c8b861d59/demo/nanite.cpp">nanite.cpp</a> demo. In this PR, I copied his code for LOD cut selection.</p>
<p>To determine the group bounding sphere, you simply build a new bounding sphere enclosing all of the group's childrens' bounding spheres. The first group you build out of LOD 0 uses the LOD 0 culling bounding spheres around each meshlet. This way, you ensure that both the error (using the existing method of taking the max error among the group and group children), <em>and</em> the bounding sphere are monotonic. Error is no longer stored in the radius of the bounding sphere, and is instead stored as a seperate f16 (lets us pack both group and parent group error into a single u32, and the lost precision is irrelevant). This also gave me the opportunity to clean up the code now that I understand the theory better, and clarify the difference between meshlets and meshlet groups better.</p>
<p>For projecting the error at runtime, we now use the below function. I can't claim to understand how it works that well (and it's been a few weeks since I last looked at it), but it does work. The end result is that we get more seamless LOD changes, and our mesh to meshlet mesh converter is more robust (it used to crash on larger meshes, due to a limitation in the code for how I calculated group bounding spheres).</p>
<pre data-lang="rust" style="background-color:#002b36;color:#839496;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#586e75;">// https://github.com/zeux/meshoptimizer/blob/1e48e96c7e8059321de492865165e9ef071bffba/demo/nanite.cpp#L115
</span><span style="color:#268bd2;">fn </span><span style="color:#b58900;">lod_error_is_imperceptible</span><span style="color:#657b83;">(</span><span style="color:#268bd2;">lod_sphere</span><span>: MeshletBoundingSphere, </span><span style="color:#268bd2;">simplification_error</span><span>: </span><span style="color:#268bd2;">f32</span><span>, </span><span style="color:#268bd2;">world_from_local</span><span>: mat4x4&lt;</span><span style="color:#268bd2;">f32</span><span>&gt;, </span><span style="color:#268bd2;">world_scale</span><span>: </span><span style="color:#268bd2;">f32</span><span style="color:#657b83;">) </span><span>-&gt; </span><span style="color:#268bd2;">bool </span><span style="color:#657b83;">{
</span><span>    </span><span style="color:#268bd2;">let</span><span> sphere_world_space </span><span style="color:#657b83;">= (</span><span>world_from_local </span><span style="color:#657b83;">* </span><span style="color:#859900;">vec4</span><span style="color:#657b83;">(</span><span>lod_sphere.center, </span><span style="color:#6c71c4;">1.0</span><span style="color:#657b83;">))</span><span>.xyz;
</span><span>    </span><span style="color:#268bd2;">let</span><span> radius_world_space </span><span style="color:#657b83;">=</span><span> world_scale </span><span style="color:#657b83;">*</span><span> lod_sphere.radius;
</span><span>    </span><span style="color:#268bd2;">let</span><span> error_world_space </span><span style="color:#657b83;">=</span><span> world_scale </span><span style="color:#657b83;">*</span><span> simplification_error;
</span><span>
</span><span>    var projected_error </span><span style="color:#657b83;">=</span><span> error_world_space;
</span><span>    </span><span style="color:#859900;">if</span><span> view.clip_from_view</span><span style="color:#657b83;">[</span><span style="color:#6c71c4;">3</span><span style="color:#657b83;">][</span><span style="color:#6c71c4;">3</span><span style="color:#657b83;">] != </span><span style="color:#6c71c4;">1.0 </span><span style="color:#657b83;">{
</span><span>        </span><span style="color:#586e75;">// Perspective
</span><span>        </span><span style="color:#268bd2;">let</span><span> distance_to_closest_point_on_sphere </span><span style="color:#657b83;">= </span><span style="color:#859900;">distance</span><span style="color:#657b83;">(</span><span>sphere_world_space, view.world_position</span><span style="color:#657b83;">) -</span><span> radius_world_space;
</span><span>        </span><span style="color:#268bd2;">let</span><span> distance_to_closest_point_on_sphere_clamped_to_znear </span><span style="color:#657b83;">= </span><span style="color:#859900;">max</span><span style="color:#657b83;">(</span><span>distance_to_closest_point_on_sphere, view.clip_from_view</span><span style="color:#657b83;">[</span><span style="color:#6c71c4;">3</span><span style="color:#657b83;">][</span><span style="color:#6c71c4;">2</span><span style="color:#657b83;">])</span><span>;
</span><span>        projected_error </span><span style="color:#657b83;">/=</span><span> distance_to_closest_point_on_sphere_clamped_to_znear;
</span><span>    </span><span style="color:#657b83;">}
</span><span>    projected_error </span><span style="color:#657b83;">*=</span><span> view.clip_from_view</span><span style="color:#657b83;">[</span><span style="color:#6c71c4;">1</span><span style="color:#657b83;">][</span><span style="color:#6c71c4;">1</span><span style="color:#657b83;">] * </span><span style="color:#6c71c4;">0.5</span><span>;
</span><span>    projected_error </span><span style="color:#657b83;">*=</span><span> view.viewport.w;
</span><span>
</span><span>    </span><span style="color:#859900;">return</span><span> projected_error </span><span style="color:#657b83;">&lt; </span><span style="color:#6c71c4;">1.0</span><span>;
</span><span style="color:#657b83;">}
</span></code></pre>
<p>An interesting side note, finding the minimal bounding sphere around a set of other bounding sphere turns out to be a very difficult problem. Kaspar Fischer's thesis <a rel="nofollow noreferrer" href="https://citeseerx.ist.psu.edu/document?repid=rep1&amp;type=pdf&amp;doi=f7688a9174e880437e2f467add73905245f4c88c">"The smallest enclosing balls of balls"</a> covers the math, and it's very complex. I copied Kapoulkine's approximate, much simpler method.</p>
<h2 id="improved-mesh-to-meshletmesh-conversion">Improved Mesh to MeshletMesh Conversion<a class="zola-anchor" href="#improved-mesh-to-meshletmesh-conversion" aria-label="Anchor link for: improved-mesh-to-meshletmesh-conversion" style="visibility: hidden;"></a>
</h2>
<p>PR <a rel="nofollow noreferrer" href="https://github.com/bevyengine/bevy/pull/15886">#15886</a> brings more improvements to the mesh to meshlet mesh converter.</p>
<p>Following on from the last PR, I again took a bunch of improvements from the meshoptimizer nanite.cpp demo:</p>
<ul>
<li>Consider only the vertex position (and ignore things like UV seams) when determining meshlet groups</li>
<li>Add back stuck meshlets that either failed to simplify, or failed to group, to the processing queue to try again at a later LOD. Dosen't seem to be much of an improvement though.</li>
<li>Provide a seed to METIS to make the meshlet mesh conversion fully deterministic. I didn't realize METIS even had options before now.</li>
<li>Target groups of 8 meshlets instead of 4. This improved simplification quality a lot! Nanite does groups of size 8-32, probably based on some kind of heuristic, which is probably worth experimenting with in the future.</li>
<li>Manually lock only vertices belonging to meshlet group borders, instead of the full toplogical group border that meshoptimizer's <code>LOCK_BORDER</code> flag does.</li>
</ul>
<p>With all of these changes combined, we can finally reliably get down to a single meshlet (or at least 1-3 meshlets for larger meshes) at the highest LOD!</p>
<p>The last item on the list in particular is a <em>huge</em> improvement. With meshoptimizer's <code>LOCK_BORDER</code> flag, the entire edge of the mesh will be locked. That means that at the most simplified LOD level, the entire border of the original mesh will be preserved. You will pretty much never be able to reduce down to 1 meshlet with this constraint. Using manual vertex locks to only lock vertices belonging to shared edges between meshlets (regardless of whether or not they're on the original mesh border) fixes this issue.</p>
<h2 id="faster-fill-cluster-buffers-pass">Faster Fill Cluster Buffers Pass<a class="zola-anchor" href="#faster-fill-cluster-buffers-pass" aria-label="Anchor link for: faster-fill-cluster-buffers-pass" style="visibility: hidden;"></a>
</h2>
<p>PR <a rel="nofollow noreferrer" href="https://github.com/bevyengine/bevy/pull/15955">#15955</a> improves the speed of the fill cluster buffers pass.</p>
<h3 id="speeding-up">Speeding Up<a class="zola-anchor" href="#speeding-up" aria-label="Anchor link for: speeding-up" style="visibility: hidden;"></a>
</h3>
<p>At this point, I improved rasterization performance, meshlet mesh building, and asset storage and loading. The Bevy 0.15 release was coming up, people were winding down features in favor of testing the release candidates, and I wasn't going to have the time (or, the motivation) to do another huge PR.</p>
<p>While looking at some small things I could improve, I ended up talking with Kirill Bazhenov about how he manages per-instance (entity) GPU data in his <a rel="nofollow noreferrer" href="https://www.youtube.com/watch?v=8gwPw1fySMU">Esoterica</a> renderer.</p>
<p>To recap the problem we had in the last post, uploading 8 bytes (instance ID + meshlet ID) per cluster to the GPU was way too expensive. The solution I came up with was to dispatch a compute shader thread per cluster, have it perform a binary search on an array of per-instance data to find the instance and meshlet it belongs to, and then write out the instance and meshlet IDs. This way, we only had to upload 8 bytes per <em>instance</em> to the GPU, and then the cluster -&gt; instance ID + meshlet ID write outs would be VRAM -&gt; VRAM writes, which are much faster than RAM -&gt; VRAM uploads. This was the fill cluster buffers pass in Bevy 0.14.</p>
<p>It's not <em>super</em> fast, but it's also not the bottleneck, and so for a while I was fine leaving it as-is. Kirill, however, showed me a much better way.</p>
<p>Instead of having our compute shader operate on a list of clusters, and write out the two IDs per cluster, we can turn the scheme on its head. We can instead have the shader operate on a list of <em>instances</em>, and write out the two IDs for each cluster within the instance. After all, each instance already has the list of meshlets it has, so writing out the cluster (an instance of a meshlet) is easy!</p>
<p>Instead of dispatching one thread per cluster, now we're going to dispatch one workgroup per instance, with each workgroup having 1024 threads (the maximum allowed). Instead of uploading a prefix-sum of meshlet counts per instance, now we're going to upload just a straight count of meshlets per instance (we're still only uploading 8 bytes per instance total).</p>
<p>In the shader, each workgroup can load the 8 bytes of data we uploaded for the instance it's processing.</p>
<pre data-lang="rust" style="background-color:#002b36;color:#839496;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#268bd2;">let</span><span> instance_id </span><span style="color:#657b83;">=</span><span> workgroup_id.x;
</span><span style="color:#268bd2;">let</span><span> instance_meshlet_count </span><span style="color:#657b83;">=</span><span> meshlet_instance_meshlet_counts</span><span style="color:#657b83;">[</span><span>instance_id</span><span style="color:#657b83;">]</span><span>;
</span><span style="color:#268bd2;">let</span><span> instance_meshlet_slice_start </span><span style="color:#657b83;">=</span><span> meshlet_instance_meshlet_slice_starts</span><span style="color:#657b83;">[</span><span>instance_id</span><span style="color:#657b83;">]</span><span>;
</span></code></pre>
<p>Then, the first thread in each workgroup can reserve space in the output buffers for its instance's clusters via an atomic counter, and broadcast the start index to the rest of the workgroup.</p>
<pre data-lang="rust" style="background-color:#002b36;color:#839496;" class="language-rust "><code class="language-rust" data-lang="rust"><span>var&lt;workgroup&gt; cluster_slice_start_workgroup: </span><span style="color:#268bd2;">u32</span><span>;
</span><span>
</span><span style="color:#586e75;">// Reserve cluster slots for the instance and broadcast to the workgroup
</span><span style="color:#859900;">if</span><span> local_invocation_index </span><span style="color:#657b83;">==</span><span> 0u </span><span style="color:#657b83;">{
</span><span>    cluster_slice_start_workgroup </span><span style="color:#657b83;">=</span><span> atomicAdd</span><span style="color:#657b83;">(</span><span style="color:#859900;">&amp;</span><span>meshlet_global_cluster_count, instance_meshlet_count</span><span style="color:#657b83;">)</span><span>;
</span><span style="color:#657b83;">}
</span><span style="color:#268bd2;">let</span><span> cluster_slice_start </span><span style="color:#657b83;">=</span><span> workgroupUniformLoad</span><span style="color:#657b83;">(</span><span style="color:#859900;">&amp;</span><span>cluster_slice_start_workgroup</span><span style="color:#657b83;">)</span><span>;
</span></code></pre>
<p>Finally, we can have the workgroup loop over its instance's clusters, and for each one, write out its instance ID (which we already have, since it's just the workgroup ID) and meshlet ID (the instance's first meshlet ID, plus the loop counter). Each thread will handle 1 cluster, and the workgroup as a whole will loop enough times to write out all of the instance's clusters.</p>
<pre data-lang="rust" style="background-color:#002b36;color:#839496;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#586e75;">// Loop enough times to write out all the meshlets for the instance given that each thread writes 1 meshlet in each iteration
</span><span style="color:#859900;">for </span><span style="color:#657b83;">(</span><span>var clusters_written </span><span style="color:#657b83;">=</span><span> 0u; clusters_written </span><span style="color:#657b83;">&lt;</span><span> instance_meshlet_count; clusters_written </span><span style="color:#657b83;">+=</span><span> 1024u</span><span style="color:#657b83;">) {
</span><span>    </span><span style="color:#586e75;">// Calculate meshlet ID within this instance&#39;s MeshletMesh to process for this thread
</span><span>    </span><span style="color:#268bd2;">let</span><span> meshlet_id_local </span><span style="color:#657b83;">=</span><span> clusters_written </span><span style="color:#657b83;">+</span><span> local_invocation_index;
</span><span>    </span><span style="color:#859900;">if</span><span> meshlet_id_local </span><span style="color:#657b83;">&gt;=</span><span> instance_meshlet_count </span><span style="color:#657b83;">{ </span><span style="color:#859900;">return</span><span>; </span><span style="color:#657b83;">}
</span><span>
</span><span>    </span><span style="color:#586e75;">// Find the overall cluster ID in the global cluster buffer
</span><span>    </span><span style="color:#268bd2;">let</span><span> cluster_id </span><span style="color:#657b83;">=</span><span> cluster_slice_start </span><span style="color:#657b83;">+</span><span> meshlet_id_local;
</span><span>
</span><span>    </span><span style="color:#586e75;">// Find the overall meshlet ID in the global meshlet buffer
</span><span>    </span><span style="color:#268bd2;">let</span><span> meshlet_id </span><span style="color:#657b83;">=</span><span> instance_meshlet_slice_start </span><span style="color:#657b83;">+</span><span> meshlet_id_local;
</span><span>
</span><span>    </span><span style="color:#586e75;">// Write results to buffers
</span><span>    meshlet_cluster_instance_ids</span><span style="color:#657b83;">[</span><span>cluster_id</span><span style="color:#657b83;">] =</span><span> instance_id;
</span><span>    meshlet_cluster_meshlet_ids</span><span style="color:#657b83;">[</span><span>cluster_id</span><span style="color:#657b83;">] =</span><span> meshlet_id;
</span><span style="color:#657b83;">}
</span></code></pre>
<p>The shader is now very efficient - the workgroup as a whole, once it reserves space for its clusters, is just repeatedly performing contiguous reads from and writes to global GPU memory.</p>
<p>Overall, in a test scene with 1041 instances with 32217 meshlets per instance, we went from 0.55ms to 0.40ms, a small 0.15ms savings. NSight now shows that we're at 95% VRAM throughput, and that we're bound by global memory operations. The speed of this pass is now basically dependent on our GPU's bandwidth - there's not much I could do better, short of reading and writing less data entirely.</p>
<h3 id="hitting-a-bump">Hitting a Bump<a class="zola-anchor" href="#hitting-a-bump" aria-label="Anchor link for: hitting-a-bump" style="visibility: hidden;"></a>
</h3>
<p>In the process of testing this PR, I ran into a rather confusing bug. The new fill cluster buffers pass worked on some smaller test scenes, but spawning 1042 instances with 32217 meshlets per instance (cliff mesh) lead to the below glitch. It was really puzzling - only some instances would be affected (concentrated in the same region of space), and the clusters themselves appeared to be glitching and changing each frame.</p>
<p><img src="https://jms55.github.io/posts/2024-11-14-virtual-geometry-bevy-0-15/cluster_limit.png" alt="Glitched mesh" /></p>
<p>Debugging the issue was complicated by the fact that the rewritten fill cluster buffers code is no longer deterministic. Clusters get written in different orders depending on how the scheduler schedules workgroups, and the order of the atomic writes. That meant that every time I clicked on a pass in RenderDoc to check it's output, the output order would completely change as RenderDoc replayed the entire command stream up until that point.</p>
<p>Since using a debugger wasn't stable enough to be useful, I tried to think the logic through. My first thought was that my rewritten code was subtly broken, but testing on mainline showed something alarming - the issue persisted. Testing several old PRs showed that it went back for several PRs. It couldn't have been due to any recent code changes.</p>
<p>It took me a week or so of trial and error, and debugging on mainline (which did have a stable output order since it used the old fill cluster buffers shader), but I eventually made the following observations:</p>
<ul>
<li>1041 cliffs: rendered correctly</li>
<li>1042 cliffs: did <em>not</em> render correctly, with 1 glitched instance</li>
<li>1041 + N cliffs: the last N being spawned glitched out</li>
<li>1042+ instances of a different mesh with much less meshlets than the cliff: <em>did</em> render correctly</li>
<li>1042+ cliffs on the PR before I increased meshlet size to 255v/128t: rendered correctly</li>
</ul>
<p>The issue turned out to be overflow of cluster ID. The output of the culling pass, and the data we store in the visbuffer, is cluster ID + triangle ID packed together in a single u32. After increasing the meshlet size, it was 25 bits for the cluster ID, and 7 bits for the triangle ID (2^7 = 128 triangles max).</p>
<p>Doing the math, 1042 instances * 32217 meshlets = 33570114 clusters. 2^25 - 33570114 = -15682. We had overflowed the cluster limit by 15682 clusters. This meant that the cluster IDs we were passing around were garbage values, leading to glitchy rendering on any instances we spawned after the first 1041.</p>
<p>Obviously this is a problem - the whole point of virtual geometry is to make rendering independent of scene complexity, yet now we have a rather low limit of 2^25 clusters in the scene.</p>
<p>The solution is to never store data per cluster in the scene, and only store data per <em>visible</em> cluster in the scene, i.e. clusters post LOD selection and culling. Not necessarily visible on screen, but visible in the sense that we're going to rasterize them. Doing so would require a large amount of architectural changes, however, and is not going to be a simple and easy fix. For now, I've documented the limitation, and merged this PR confident that it's not a regression.</p>
<h2 id="software-rasterization-bugfixes">Software Rasterization Bugfixes<a class="zola-anchor" href="#software-rasterization-bugfixes" aria-label="Anchor link for: software-rasterization-bugfixes" style="visibility: hidden;"></a>
</h2>
<p>PR <a rel="nofollow noreferrer" href="https://github.com/bevyengine/bevy/pull/16049">#16049</a> fixes some glitches in the software rasterizer.</p>
<p>While testing out some scenes to prepare for the release, I discovered some previously-missed bugs with software rasterization. When zooming in to the scene, sometimes triangles would randomly glitch and cover the whole screen, leading to massive slowdowns (remember the software rasterizer is meant to operate on small triangles only). Similarly, when zooming out, sometimes there would be single stray pixels rendered that didn't belong. These issues didn't occur with only hardware rasterization enabled.</p>
<center>
<p><img src="https://jms55.github.io/posts/2024-11-14-virtual-geometry-bevy-0-15/stray_pixels.png" alt="Stray pixels glitch" />
<em>Stray pixels on the tops of the pawns and king.</em></p>
</center>
<p>The stray pixels turned out to be due to two issues. The first bug is in how I calculated the bounding box around each triangle. I wasn't properly accounting for triangles that would be partially on-screen, and partially off-screen. I changed my bounding box calculations to stick to floating point, and clamped negative bounds to 0 to fix. The second bug is that I didn't perform any backface culling in the software rasterizer, and ignoring it does not lead to valid results. If you want a double-sided mesh, then you need to explicitly check for backfacing triangles and invert them. If you want backface culling (I do), then you need to reject the triangle if it's backfacing. Ignoring it turned out to not be an option - skipping backface culling earlier turned out to have bitten me :).</p>
<center>
<p><img src="https://jms55.github.io/posts/2024-11-14-virtual-geometry-bevy-0-15/fullscreen_triangle.png" alt="Fullscreen triangle glitch" />
<em>The large green and orange triangles aren't supposed to be there.</em></p>
</center>
<p>The fullscreen triangles was trickier to figure out, but I ended up narrowing it down to near plane clipping. Rasterization math, specifically the homogenous divide, has a <a rel="nofollow noreferrer" href="https://en.wikipedia.org/wiki/Singularity_(mathematics)">singularity</a> when z = 0. Normally, the way you solve this is by clipping to the near plane, which is a frustum plane positioned slightly in front of z = 0. As long as you provide the plane, GPU rasterizers handle near plane clipping for you automatically. In my software rasterizer, however, I had of course not accounted for near plane clipping. That meant that we were getting Nan/Infinity vertex positions due to the singularity during the homogenous divide, which led to the garbage triangles we were seeing.</p>
<p>Proper near plane clipping is somewhat complicated (slow), and should not be needed for most clusters. Rather than have our software rasterizer handle near plane clipping, we're instead going to have the culling pass detect which clusters intersect the near plane, and put them in the hardware rasterization queue regardless of size. The fix for this is just two extra lines.</p>
<pre data-lang="rust" style="background-color:#002b36;color:#839496;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#586e75;">// Before
</span><span style="color:#859900;">if</span><span> cluster_is_small </span><span style="color:#657b83;">{
</span><span>    </span><span style="color:#586e75;">// Software raster
</span><span style="color:#657b83;">} </span><span style="color:#859900;">else </span><span style="color:#657b83;">{
</span><span>    </span><span style="color:#586e75;">// Hardware raster
</span><span style="color:#657b83;">}
</span><span>
</span><span style="color:#586e75;">// After
</span><span style="color:#268bd2;">let</span><span> not_intersects_near_plane </span><span style="color:#657b83;">= </span><span style="color:#859900;">dot</span><span style="color:#657b83;">(</span><span>view.frustum</span><span style="color:#657b83;">[</span><span>4u</span><span style="color:#657b83;">]</span><span>, culling_bounding_sphere_center</span><span style="color:#657b83;">) &gt;</span><span> culling_bounding_sphere_radius;
</span><span style="color:#859900;">if</span><span> cluster_is_small </span><span style="color:#859900;">&amp;&amp;</span><span> not_intersects_near_plane </span><span style="color:#657b83;">{
</span><span>    </span><span style="color:#586e75;">// Software raster
</span><span> </span><span style="color:#657b83;">} </span><span style="color:#859900;">else </span><span style="color:#657b83;">{
</span><span>    </span><span style="color:#586e75;">// Hardware raster
</span><span style="color:#657b83;">}
</span></code></pre>
<p>With these changes, software raster is now visibly bug-free.</p>
<h2 id="normal-aware-lod-selection">Normal-aware LOD Selection<a class="zola-anchor" href="#normal-aware-lod-selection" aria-label="Anchor link for: normal-aware-lod-selection" style="visibility: hidden;"></a>
</h2>
<p>PR <a rel="nofollow noreferrer" href="https://github.com/bevyengine/bevy/pull/16111">#16111</a> improves how we calculate the LOD cut to account for vertex normals.</p>
<p>At the end of the Bevy 0.15's development cycle, meshoptimizer 0.22 was released, bringing some simplification improvements. Crucially, it greatly improves <code>meshopt_simplifyWithAttributes()</code>.</p>
<p>I now use this function to pass vertex normals into the simplifier, meaning that the deformation error the simplifier outputs (which we feed directly into the LOD cut selection shader) accounts for not only position deformation, but also normal deformation.</p>
<p>Without this change, before this PR, visualizing the pixel positions was near-seamless as the LOD cut changed when you zoomed in or out. Pixel normals, however, had visible differences between LOD cuts. After this PR, normals are now near-seamless too.</p>
<p>There's still work to be done in this area - I'm not currently accounting for UV coordinate deformation, and the weights I chose for position vs normal influence are completely arbitrary. The Nanite presentation talks about this problem a lot - pre-calculating an error amount that perfectly accounts for every aspect of human perception, for meshes with arbitrary materials, is a <em>really</em> hard problem. The best we can do is spend time tweaking heuristics, which I'll leave for a future PR.</p>
<h2 id="results-bevy-0-14-vs-0-15">Results: Bevy 0.14 vs 0.15<a class="zola-anchor" href="#results-bevy-0-14-vs-0-15" aria-label="Anchor link for: results-bevy-0-14-vs-0-15" style="visibility: hidden;"></a>
</h2>
<p>Finally, I'd like to compare Bevy v0.14 to (what will soon release as) v0.15.</p>
<p>The test scene we'll be comparing is 3375 instances of the Stanford bunny mesh arranged in a 15x15x15 cube, running at a resolution of 2240x1260 on an RTX 3080 locked to base clocks.</p>
<p>As an additional test scene, we'll also be looking at 847 instances of the <a rel="nofollow noreferrer" href="https://www.fab.com/listings/e16b2143-5512-4460-bd0c-9270c4c6df51">Huge Icelandic Lava Cliff</a> quixel megascan asset arranged in an 11x11x7 rectangular prism. This asset was too big to process in Bevy v0.14, so for this scene we'll only be looking at data from Bevy v0.15.</p>
<center style="display: flex; flex-direction: column;">
<p><img src="https://jms55.github.io/posts/2024-11-14-virtual-geometry-bevy-0-15/0.14.png" alt="Bunny scene screenshot v0.14" />
<em>Bunny scene in Bevy v0.14.</em>
<img src="https://jms55.github.io/posts/2024-11-14-virtual-geometry-bevy-0-15/0.15.png" alt="Bunny scene screenshot v0.15" />
<em>Bunny scene in Bevy v0.15.</em>
<img src="https://jms55.github.io/posts/2024-11-14-virtual-geometry-bevy-0-15/cliffs.png" alt="Cliff scene screenshot v0.15" />
<em>Cliff scene in Bevy v0.15.</em></p>
<h3 id="gpu-timings">GPU Timings<a class="zola-anchor" href="#gpu-timings" aria-label="Anchor link for: gpu-timings" style="visibility: hidden;"></a>
</h3>
<p>GPU timings to render the visbuffer (so excluding shading, and any CPU work)</p>
<table style="border-collapse:collapse;border-color:#ccc;border-spacing:0;border:none" class="tg"><thead>
<tr><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:large;font-weight:normal;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="font-weight:bold;color:#333;background-color:#F0F0F0">Pass</span></th><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:large;font-weight:normal;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="font-weight:bold;color:#333;background-color:#F0F0F0">Bunny v0.14</span></th>
<th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:large;font-weight:normal;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="font-weight:bold;color:#333;background-color:#F0F0F0">Bunny v0.15</span></th><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:large;font-weight:normal;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="font-weight:bold;color:#333;background-color:#F0F0F0">Cliff v0.15</span></th></tr>
</thead>
<tbody>
<tr><td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">Fill Cluster Buffers</span></td><td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">0.30</span></td><td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">0.12</span></td>
<td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">0.31</span></td></tr>
<tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">Culling First</span></td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">0.99</span></td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">0.19</span></td>
<td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">1.27</span></td></tr>
<tr><td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">Software Raster First</span></td><td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">N/A</span></td><td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">0.42</span></td>
<td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">0.34</span></td></tr>
<tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">Hardware Raster First</span></td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">3.44</span></td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">&lt; 0.01</span></td>
<td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">0.02</span></td></tr>
<tr><td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">Downsample Depth</span></td><td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">0.03</span></td><td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">0.03</span></td>
<td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">0.05</span></td></tr>
<tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">Culling Second</span></td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">0.14</span></td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">0.06</span></td>
<td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">0.19</span></td></tr>
<tr><td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">Software Raster Second</span></td><td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">N/A</span></td><td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">&lt; 0.01</span></td>
<td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">&lt; 0.01</span></td></tr>
<tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">Hardware Raster Second</span></td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">&lt; 0.01</span></td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">&lt; 0.01</span></td>
<td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">&lt; 0.01</span></td></tr>
<tr><td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">Resolve Depth</span></td><td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">N/A</span></td><td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">0.04</span></td>
<td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">0.05</span></td></tr>
<tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">Resolve Material Depth</span></td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">0.04</span></td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">0.04</span></td>
<td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">0.04</span></td></tr>
<tr><td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">Downsample Depth</span></td><td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">0.03</span></td><td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">0.03</span></td>
<td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">0.05</span></td></tr>
<tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="font-weight:bold;color:#333;background-color:#FFF">Total</span></td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="font-weight:bold;color:#333;background-color:#FFF">4.97 ms</span></td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="font-weight:bold;color:#333;background-color:#FFF">0.93 ms</span></td>
<td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="font-weight:bold;color:#333;background-color:#FFF">2.32 ms</span></td></tr>
</tbody></table>
<h3 id="dag-layout">DAG Layout<a class="zola-anchor" href="#dag-layout" aria-label="Anchor link for: dag-layout" style="visibility: hidden;"></a>
</h3>
<table style="border-collapse:collapse;border-color:#ccc;border-spacing:0;border:none" class="tg"><thead>
<tr><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:large;font-weight:normal;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal" colspan="3"><span style="font-weight:bold;color:#333;background-color:#F0F0F0">Bunny v0.14</span></th><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:large;font-weight:normal;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal" colspan="3"><span style="font-weight:bold;color:#333;background-color:#F0F0F0">Bunny v0.15</span></th>
<th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:large;font-weight:normal;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal" colspan="3"><span style="font-weight:bold;color:#333;background-color:#F0F0F0">Cliff v0.15</span></th></tr>
</thead>
<tbody>
<tr><td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="font-weight:bold;color:#333;background-color:#F9F9F9">LOD Level</span></td><td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="font-weight:bold;color:#333;background-color:#F9F9F9">Meshlets</span></td><td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="font-weight:bold;color:#333;background-color:#F9F9F9">Meshlets With 64 Triangles (full)</span></td>
<td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="font-weight:bold;color:#333;background-color:#F9F9F9">LOD Level</span></td><td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="font-weight:bold;color:#333;background-color:#F9F9F9">Meshlets</span></td><td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="font-weight:bold;color:#333;background-color:#F9F9F9">Meshlets With 128 Triangles (full)</span></td>
<td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="font-weight:bold;color:#333;background-color:#F9F9F9">LOD Level</span></td><td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="font-weight:bold;color:#333;background-color:#F9F9F9">Meshlets</span></td><td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="font-weight:bold;color:#333;background-color:#F9F9F9">Meshlets With 128 Triangles (full)</span></td></tr>
<tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">0</span></td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">2251</span></td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">2250</span></td>
<td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">0</span></td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">1126</span></td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">1125</span></td>
<td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">0</span></td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">15616</span></td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">15615</span></td></tr>
<tr><td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">1</span></td><td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">1320</span></td><td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">931</span></td>
<td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">1</span></td><td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">608</span></td><td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">517</span></td>
<td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">1</span></td><td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">7944</span></td><td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">7610</span></td></tr>
<tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">2</span></td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">672</span></td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">383</span></td>
<td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">2</span></td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">310</span></td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">251</span></td>
<td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">2</span></td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">4306</span></td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">3535</span></td></tr>
<tr><td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">3</span></td><td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">373</span></td><td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">172</span></td>
<td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">3</span></td><td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">162</span></td><td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">129</span></td>
<td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">3</span></td><td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">2200</span></td><td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">1728</span></td></tr>
<tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">4</span></td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">173</span></td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">47</span></td>
<td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">4</span></td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">80</span></td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">61</span></td>
<td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">4</span></td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">1109</span></td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">844</span></td></tr>
<tr><td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">5</span></td><td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">74</span></td><td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">15</span></td>
<td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">5</span></td><td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">38</span></td><td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">29</span></td>
<td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">5</span></td><td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">552</span></td><td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">425</span></td></tr>
<tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">6</span></td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">19</span></td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">4</span></td>
<td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">6</span></td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">20</span></td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">15</span></td>
<td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">6</span></td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">282</span></td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">214</span></td></tr>
<tr><td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"></td><td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"></td><td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"></td>
<td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">7</span></td><td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">10</span></td><td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">7</span></td>
<td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">7</span></td><td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">139</span></td><td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">105</span></td></tr>
<tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"></td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"></td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"></td>
<td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">8</span></td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">5</span></td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">3</span></td>
<td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">8</span></td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">69</span></td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">51</span></td></tr>
<tr><td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"></td><td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"></td><td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"></td>
<td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">9</span></td><td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">3</span></td><td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">2</span></td>
<td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">9</span></td><td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">35</span></td><td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">26</span></td></tr>
<tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"></td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"></td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"></td>
<td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">10</span></td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">2</span></td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">1</span></td>
<td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">10</span></td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">18</span></td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">13</span></td></tr>
<tr><td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"></td><td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"></td><td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"></td>
<td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">11</span></td><td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">1</span></td><td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">1</span></td>
<td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">11</span></td><td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">9</span></td><td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">6</span></td></tr>
<tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"></td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"></td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"></td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"></td>
<td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"></td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"></td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">12</span></td>
<td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">5</span></td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">3</span></td></tr>
<tr><td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"></td><td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"></td><td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"></td><td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"></td>
<td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"></td><td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"></td><td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">13</span></td>
<td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">2</span></td><td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">1</span></td></tr>
<tr><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"></td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"></td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"></td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"></td>
<td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"></td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"></td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">14</span></td>
<td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">2</span></td><td style="background-color:#fff;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">1</span></td></tr>
</tbody></table>
<h3 id="disk-usage">Disk Usage<a class="zola-anchor" href="#disk-usage" aria-label="Anchor link for: disk-usage" style="visibility: hidden;"></a>
</h3>
<table style="border-collapse:collapse;border-color:#ccc;border-spacing:0;border:none" class="tg"><thead>
<tr><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:large;font-weight:normal;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="font-weight:bold;color:#333;background-color:#F0F0F0">Bunny v0.14</span></th><th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:large;font-weight:normal;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="font-weight:bold;color:#333;background-color:#F0F0F0">Bunny v0.15</span></th>
<th style="background-color:#f0f0f0;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:large;font-weight:normal;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="font-weight:bold;color:#333;background-color:#F0F0F0">Cliff v0.15</span></th></tr>
</thead>
<tbody><tr><td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">5.05 MB</span></td><td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">3.61 MB</span></td><td style="background-color:#f9f9f9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">49.83 MB</span></td></tr></tbody></table>
<h3 id="memory-usage">Memory Usage<a class="zola-anchor" href="#memory-usage" aria-label="Anchor link for: memory-usage" style="visibility: hidden;"></a>
</h3>
<table style="border-collapse:collapse;border-color:#ccc;border-spacing:0;border:none" class="tg"><thead><tr><th style="background-color:#F0F0F0;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:large;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal" colspan="2"><span style="font-weight:bold">Bunny v0.14</span></th><th style="background-color:#F0F0F0;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:large;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal" colspan="2"><span style="font-weight:bold">Bunny v0.15</span></th><th style="background-color:#F0F0F0;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:large;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal" colspan="2"><span style="font-weight:bold">Cliff v0.15</span></th></tr></thead>
<tbody>
<tr><td style="background-color:#F9F9F9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="font-weight:bold">Data Type</span></td><td style="background-color:#F9F9F9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="font-weight:bold">Size (bytes)</span></td><td style="background-color:#F9F9F9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="font-weight:bold">Data Type</span></td>
<td style="background-color:#F9F9F9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="font-weight:bold">Size (bytes)</span></td><td style="background-color:#F9F9F9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="font-weight:bold">Data Type</span></td><td style="background-color:#F9F9F9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="font-weight:bold">Size (bytes)</span></td></tr>
<tr><td style="background-color:#FFF;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">Vertex Data</span></td><td style="background-color:#FFF;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">3505296</span></td><td style="background-color:#FFF;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">Vertex Positions</span></td>
<td style="background-color:#FFF;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">590132</span></td><td style="background-color:#FFF;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">Vertex Positions</span></td><td style="background-color:#FFF;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">8537220</span></td></tr>
<tr><td style="background-color:#F9F9F9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">Vertex IDs</span></td><td style="background-color:#F9F9F9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">3651840</span></td><td style="background-color:#F9F9F9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">Vertex Normals</span></td>
<td style="background-color:#F9F9F9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">788476</span></td><td style="background-color:#F9F9F9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">Vertex Normals</span></td><td style="background-color:#F9F9F9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">10851996</span></td></tr>
<tr><td style="background-color:#FFF;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"></td><td style="background-color:#FFF;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"></td><td style="background-color:#FFF;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">Vertex UVs</span></td>
<td style="background-color:#FFF;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">1576952</span></td><td style="background-color:#FFF;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">Vertex UVs</span></td><td style="background-color:#FFF;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">21703992</span></td></tr>
<tr><td style="background-color:#F9F9F9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">Indices</span></td><td style="background-color:#F9F9F9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">2738880</span></td><td style="background-color:#F9F9F9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">Indices</span></td>
<td style="background-color:#F9F9F9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">1374336</span></td><td style="background-color:#F9F9F9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">Indices</span></td><td style="background-color:#F9F9F9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">19245696</span></td></tr>
<tr><td style="background-color:#FFF;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">Meshlets</span></td><td style="background-color:#FFF;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">16 * 4882 = 78112</span></td><td style="background-color:#FFF;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">Meshlets</span></td>
<td style="background-color:#FFF;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">32 * 2365 = 75680</span></td><td style="background-color:#FFF;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">Meshlets</span></td><td style="background-color:#FFF;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">32 * 32288 = 1033216</span></td></tr>
<tr><td style="background-color:#F9F9F9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">Bounding Spheres</span></td><td style="background-color:#F9F9F9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">234336</span></td><td style="background-color:#F9F9F9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">Bounding Spheres</span></td>
<td style="background-color:#F9F9F9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">113520</span></td><td style="background-color:#F9F9F9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">Bounding Spheres</span></td><td style="background-color:#F9F9F9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#F9F9F9">1549824</span></td></tr>
<tr><td style="background-color:#FFF;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"></td><td style="background-color:#FFF;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"></td><td style="background-color:#FFF;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">Simplification Errors</span></td>
<td style="background-color:#FFF;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">9460</span></td><td style="background-color:#FFF;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">Simplification Errors</span></td><td style="background-color:#FFF;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="color:#333;background-color:#FFF">129152</span></td></tr>
<tr><td style="background-color:#F9F9F9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="font-weight:bold">Total</span></td><td style="background-color:#F9F9F9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="font-weight:bold">10.2 MB</span></td><td style="background-color:#F9F9F9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="font-weight:bold">Total</span></td>
<td style="background-color:#F9F9F9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="font-weight:bold">4.5 MB</span></td><td style="background-color:#F9F9F9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="font-weight:bold">Total</span></td><td style="background-color:#F9F9F9;border-color:#ccc;border-style:solid;border-width:0px;color:#333;font-family:Arial, sans-serif;font-size:14px;font-weight:bold;overflow:hidden;padding:10px 5px;text-align:center;vertical-align:top;word-break:normal"><span style="font-weight:bold">63.0 MB</span></td></tr>
</tbody></table>
</center>
<h3 id="discussion-asset">Discussion - Asset<a class="zola-anchor" href="#discussion-asset" aria-label="Anchor link for: discussion-asset" style="visibility: hidden;"></a>
</h3>
<p>First, lets compare the DAG layout between the Stanford bunny in Bevy 0.14 and 0.15. In Bevy 0.14, with 64 triangles max per meshlet, we start with 2250 meshlets at LOD 0. In Bevy 0.15, with 128 triangles max per meshlet, we have exactly half as many at 1125.</p>
<p>In Bevy 0.14, the DAG has 7 levels, ending with 19 meshlets. In Bevy 0.15, the DAG has 12 levels, ending at a single meshlet! For an ideal DAG, we want half as many meshlets at each LOD level, resulting in half as many triangles at each level. That means that with 1125 meshlets at LOD level 0, we want <code>ceil(log2(1125)) = 11</code> additional levels, for 12 total. In Bevy 0.15, we have 12! Meanwhile in Bevy 0.14, we also want 12 levels, but fall short at only 7 levels. We clearly improved the DAG structure compared to the previous version.</p>
<p>Comparing meshlet fill rate (percentage of meshlets with the maximum number of triangles), both versions have an almost 100% fill rate at LOD 0 (the mesh is probably not a perfect multiple of the max triangle count). Meshoptimizer does a great job of equally partitioning triangles for the initial mesh.</p>
<p>However, looking at further LOD levels, Bevy 0.14 performs very badly, going down to an abysmal 20% fill rate at the lowest. Bevy 0.15 is a lot better, with the worst fill rate being 76%, and the variance being a lot lower. It's still not perfect - a lot of the time we still have to deal with stuck triangles that never get simplified when processing complex meshes - but it's good progress!</p>
<p>Memory and disk size are also much lower in Bevy 0.15 than Bevy 0.14, although a lot of this (but not all) comes down to the ~half as many overall meshlets in the DAG, meaning that there's less data to store in the first place. Still, adding up the vertex info for Bevy 0.14 (vertex data + vertex IDs = <code>7.16 MB</code>) and for Bevy 0.15 (vertex positions + normals + UVs = <code>2.956 MB</code>) shows a clear reduction in memory usage for the same amount of triangles in the original mesh.</p>
<h3 id="discussion-performance">Discussion - Performance<a class="zola-anchor" href="#discussion-performance" aria-label="Anchor link for: discussion-performance" style="visibility: hidden;"></a>
</h3>
<p>Of course, asset size dosen't matter if performance is worse. After all, we could skip the additional LOD levels entirely to save on the cost of storing them, but we would get much worse runtime performance.</p>
<p>The good news is that comparing the bunny scene in Bevy 0.14 to Bevy 0.15, rendering got almost 5x faster!</p>
<p>Rasterization is the big immediate win. We were spending 3.44 ms on it in Bevy 0.14, and now only 0.42 ms on it in Bevy 0.15! Some of this comes down to software raster being faster than our non-mesh shader hardware raster, but a lot of it comes down to our improved DAG creation and LOD selection code. DAG building is really, really important - a huge chunk of your runtime performance comes down to building a good DAG, before you even start rendering!</p>
<p>Culling (which is also LOD selection) got a little bit faster as well, going from 0.99 ms to 0.19 ms in the first pass, and 0.14 to 0.06 ms in the second pass. The culling pass no longer has to write out a list of triangles for visible clusters - now it's just writing a single cluster ID for each visible cluster, which is much faster.</p>
<p>The other big win for culling is that with ~half as many meshlets to process, we only have to do half the work, as evidenced by the second pass performing a little over twice as well (the second pass here is basically just measuring overhead from spawning threads per cluster, since it's doing a single read + early-out for every single cluster as occlusion culling is near-perfect in  static scene like this).</p>
<p>Looking at the cliff scene with a much larger amount of meshlets and triangles, concentrated into much fewer instances, we can see some interesting results. Rasterization is actually <em>faster</em> in this scene than the bunny scene by 0.08 ms, but the first culling pass takes a whopping 1.27 ms, up from only 0.19 ms. Ouch. We ideally want similiar timings no matter the type of scene, so that artists don't have to care about things like number of triangles per mesh, but we're not quite there yet. Culling is the clear bottleneck.</p>
<p>Finally, fill cluster buffers got a little bit faster as well, going down from 0.30 ms to 0.12 ms, with a good chunk of the performance again coming from having half as many total clusters in the scene.</p>
<h2 id="roadmap">Roadmap<a class="zola-anchor" href="#roadmap" aria-label="Anchor link for: roadmap" style="visibility: hidden;"></a>
</h2>
<p>I got a lot done in Bevy 0.15, but there's still a <em>ton</em> left to do for Bevy 0.16 and beyond.</p>
<p>The major, immediate priority (once I'm rested and ready to work on virtual geometry again) will be improving the culling/LOD selection pass. While cluster selection (I should rename the pass to that, that's a good name now that I think of it) is an <a rel="nofollow noreferrer" href="https://en.wikipedia.org/wiki/Embarrassingly_parallel">embarrassingly parallel</a> problem in theory, in practice, having to dispatch a thread per cluster in the scene is an enormous waste of time. There can be million of clusters in the scene, and divergence and register usage on top of the sheer number of threads needed means that this pass is currently the biggest bottleneck.</p>
<p>The fix is to (like Nanite does) traverse a BVH (tree) of clusters, where we only need to process clusters up until they would be the wrong LOD, and then can immediately stop processing their children. Doing tree traversal on a GPU is very tricky, and doing it maximally efficient depends on <a rel="nofollow noreferrer" href="https://arxiv.org/pdf/2109.06132v1">undefined behavior</a> of GPU schedulers that not all GPUs have, so I expect to spend a lot of time tweaking this once I get something working.</p>
<p>The second major priority is getting rid of the need for the fill cluster buffers pass entirely. Besides letting us reclaim some more performance, the big win is that we could do away with the need to allocate buffers to hold instance ID + cluster ID per cluster in the scene, instead letting us store this data per <em>visible</em> (post LOD selection/culling) cluster in the scene. Besides the obvious memory savings, it also saves us from running into the cluster ID limit issue that was limiting our scene size before. We would no longer need a unique ID for each cluster in the scene - just a unique ID for visible clusters only, post culling and LOD selection, which is a much smaller amount.</p>
<p>Besides cluster selection improvements, and improving on existing stuff, other big areas I could work on include:</p>
<ul>
<li>Streaming of meshlet vertex data (memory savings)</li>
<li>Disk-oriented asset compression (disk and load time savings)</li>
<li>Rendering clusters for all views at once (performance savings for shadow views)</li>
<li>Material shader optimizations (I haven't spent any time at all on this yet)</li>
<li>Occlusion culling fixes (I plan to port Hans-Kristian Arntzen's Granite renderer's <a rel="nofollow noreferrer" href="https://github.com/Themaister/Granite/blob/7543863d2a101faf45f897d164b72037ae98ff74/assets/shaders/post/hiz.comp">HiZ shader</a> to WGSL)</li>
<li>Tooling to make working with MeshletMeshes easier</li>
<li>Testing and improving CPU performance for large amounts of instances</li>
</ul>
<p>With any luck, in another few months I'll be writing about some of these topics in the post for Bevy 0.16. See you then!</p>
<h2 id="appendix">Appendix<a class="zola-anchor" href="#appendix" aria-label="Anchor link for: appendix" style="visibility: hidden;"></a>
</h2>
<p>Further resources on Nanite-style virtual geometry:</p>
<ul>
<li><a rel="nofollow noreferrer" href="https://advances.realtimerendering.com/s2021/Karis_Nanite_SIGGRAPH_Advances_2021_final.pdf">https://advances.realtimerendering.com/s2021/Karis_Nanite_SIGGRAPH_Advances_2021_final.pdf</a></li>
<li><a rel="nofollow noreferrer" href="https://github.com/jglrxavpok/Carrot">https://github.com/jglrxavpok/Carrot</a></li>
<li><a rel="nofollow noreferrer" href="https://github.com/LVSTRI/IrisVk">https://github.com/LVSTRI/IrisVk</a></li>
<li><a rel="nofollow noreferrer" href="https://github.com/pettett/multires">https://github.com/pettett/multires</a></li>
<li><a rel="nofollow noreferrer" href="https://github.com/Scthe/nanite-webgpu">https://github.com/Scthe/nanite-webgpu</a></li>
<li><a rel="nofollow noreferrer" href="https://github.com/ShawnTSH1229/SimNanite">https://github.com/ShawnTSH1229/SimNanite</a></li>
<li><a rel="nofollow noreferrer" href="https://github.com/SparkyPotato/radiance">https://github.com/SparkyPotato/radiance</a></li>
<li><a rel="nofollow noreferrer" href="https://github.com/zeux/meshoptimizer/blob/master/demo/nanite.cpp">https://github.com/zeux/meshoptimizer/blob/master/demo/nanite.cpp</a></li>
</ul>

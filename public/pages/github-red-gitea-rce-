<blockquote>
<p>本文首发于跳跳糖 <a href="https://tttang.com/archive/1607/">https://tttang.com/archive/1607/</a></p></blockquote>
<p>今年过年放假的时候，我就在挖 Go 相关开源项目的 Security Bounty。通过整理分析现有 Go 开源项目的历史 CVE，我大致摸索出了 Go 项目易出现漏洞的一些地方，以及开发人员经常会疏忽的问题。
前后提交的几个漏洞让我有了好几个 CVE，并且小赚了一笔，换算成人民币应该接近六位数了。😈
具体可以阅读我的上一篇文章：<a href="https://github.red/security-bounty-thought/">聊聊最近挖 Security Bounty 的感受</a></p>
<h2 id="gogs-被-rce-了那-gitea-呢">Gogs 被 RCE 了，那 Gitea 呢？</h2>
<p>在上面的文章中，我提到自己挖掘到了一枚 Gogs 中因为未对用户可控的目录路径进行检测，从而导致后续路径拼接可以导致目录穿越，从而使得攻击者能上传覆盖环境中的任意文件。
在能覆盖任意文件后，我使用的是之前 CVE-2019-11229 中提到的方法，覆盖一个 Git 仓库中 <code>.git/config</code> 文件，设置 <code>core.sshCommand</code> 参数从而达到远程任意命令执行。</p>
<p>一直以来我都十分欣赏这个漏洞，因为它给人畜无害的 Git 传入了恶意的配置，就能导致命令执行。类似的还有 <code>curl</code>，前阵子做到过一道 CTF 题，在环境变量可控的情况下，可以使用 <code>curl</code> 来覆盖文件，同样也十分精彩。</p>
<p>那么，既然 Gogs 被我们 RCE 了，那基于 Gogs 代码分叉出去的 Gitea，是否也存在调用 Git 时，传入恶意参数导致命令执行的问题呢？这，就是这篇文章要讲述的。</p>
<h2 id="寻找攻击点">寻找攻击点</h2>
<p>Gitea 是一个前后端不分离的项目，很多操作还是通过 POST 表单提交。我刚开始审计 Gitea 项目时，打算先集中看一遍它的输入，因此选择先从 Gitea API 入手。通过点击 Gitea 页面右下角的 「API」即可看到一个用 Swagger 搭建的 API 文档。网页上通过表单提交的操作，在这里基本可以找到与之对应的 RESTful API。</p>
<p>第一个 <code>admin</code> 是管理员的操作，肯定有个中间件鉴权，纵使后面有洞也会被前面的中间件给拦了，优先级靠后，先跳过。第二个 <code>miscellaneous</code> 是一对杂项功能，基本不涉及啥复杂的交互，也先跳过&hellip;&hellip; 之后一连串的看下去，都是些简单的 CRUD 操作，寻思也写不出啥洞，我也懒得去看。😅
而后当点开 <code>repository</code> 选项卡，第一个接口是：</p>
<blockquote>
<p>POST <code>/repos/migrate</code> Migrate a remote git repository</p></blockquote>
<p>诶~ 这个好像有点意思，迁移远端的仓库过来，那肯定是要请求给定的远端仓库 URL，说不定保底就是个 SSRF。展开看接口传入的 JSON 内容，其中包含远端仓库的 URL、是否迁移 Issues、Pull Request、Releases、LFS 等数据。联想到我之前挖的 Gitea 任意文件删除漏洞就是在处理 LFS 文件这里，说不定这里从远端迁移 LFS 文件也会存在类似路径穿越的问题？
带着这个猜想，我去看了 Gitea Migration 部分的代码，不看不知道，一看才发现这功能是个筛子。</p>
<h2 id="gitea-migration">Gitea Migration</h2>
<p>Gitea 的 Migration 迁移功能由两部分组成，<code>Downloader</code> 与 <code>Uploader</code>，对应到代码中分别是 <code>migration.Downloader</code> 与 <code>migration.Uploader</code> 两个接口。前者负责从远端的仓库服务下载仓库信息，后者负责将信息打入到 Gitea 中。
目前 <code>Downloader</code> 支持从 GitHub、Gitlab、GitBucket、Gogs、Gitea 等服务导入代码，你可以在 <code>services/migrations</code> 目录下看到对这些平台的 <code>Downloader</code> 接口实现。一般都是调这些服务的 API 来获取托管在其上面仓库的 Issue、Pull Request、Releases 等信息。而 <code>Uploader</code> 的实现只有一个，那就是 Gitea，因为我们最终只会将远端仓库迁移至本 Gitea 实例中。</p>
<p>在 <code>services/migrations/migrate.go#migrateRepository</code> 是迁移一个远端仓库所要进行的步骤。在给函数传入了对应的 <code>Downloader</code> 和 <code>Uploader</code> 后，它将依次做如下操作：</p>
<table>
<thead>
<tr>
<th>调用的接口方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>downloader.GetRepoInfo</code></td>
<td>获取远端仓库基本信息</td>
</tr>
<tr>
<td><code>downloader.FormatCloneURL</code></td>
<td>获取远端仓库 Git Clone 地址</td>
</tr>
<tr>
<td><code>uploader.CreateRepo</code></td>
<td>创建本地仓库</td>
</tr>
<tr>
<td><code>downloader.GetTopics</code> <code>uploader.CreateTopics</code></td>
<td>获取远端仓库 Topic + 创建本地仓库 Topic</td>
</tr>
<tr>
<td><code>downloader.GetMilestones</code> <code>uploader.CreateMilestones</code></td>
<td>获取远端仓库里程碑 + 创建本地仓库里程碑</td>
</tr>
<tr>
<td><code>downloader.GetLabels</code> <code>uploader.CreateLabels</code></td>
<td>获取远端仓库标签 + 创建本地仓库标签</td>
</tr>
<tr>
<td><code>downloader.GetReleases</code> <code>uploader.CreateReleases</code></td>
<td>获取远端仓库 Release 版本 + 创建本地仓库 Release 版本</td>
</tr>
<tr>
<td><code>downloader.GetIssues</code> <code>uploader.CreateIssues</code></td>
<td>获取远端仓库 Issue + 创建本地仓库 Issue</td>
</tr>
<tr>
<td><code>downloader.GetComments</code> <code>uploader.CreateComments</code></td>
<td>获取远端仓库评论 + 创建本地仓库评论</td>
</tr>
<tr>
<td><code>downloader.GetPullRequests</code> <code>uploader.CreatePullRequests</code></td>
<td>获取远端仓库 Pull Request + 创建本地仓库 Pull Request</td>
</tr>
<tr>
<td><code>downloader.GetReviews</code> <code>uploader.CreateReviews</code></td>
<td>获取远端仓库 Code Review + 创建本地仓库 Code Review</td>
</tr>
</tbody>
</table>
<p>可以看到，仓库迁移的操作就是把信息使用 <code>Downloader</code> 下载回来，然后 <code>Uploader</code> 给存储到本地，这样成对的一来一回。
由于 GitHub、Gitlab、GitBucket 这些属于第三方的 SaaS，我们对其 API 返回的内容并是完全不可控的，因此我将目光瞄准了从 Gogs 和 Gitea 迁移。而 Gitea 的 <code>Downloader</code> 的功能相比 Gogs 的多，当 Gitea 要从另一个 Gitea 实例迁移仓库时，它将请求远端 Gitea 实例的 API，来得知该仓库的名称、Issue、Pull Request、Releases 文件等。
我们试想是否可以伪造一个 Gitea 实例，说白了就是伪造这么一套 Gitea API，让当前 Gitea 实例在迁移仓库时去请求我们伪造的 Gitea API 服务，从中传入一些恶意参数看看能不能搞事情。</p>
<p>经过一个通宵的审计加 @Li4n0 的协助，我们终于发现了一枚远程命令执行漏洞。它从恶意的 Gitea 实例读取精心构造的参数后，拼接进正常的 Git 命令，从而导致了远程命令执行。我们形象地将其称之为：Git 投毒（Git Poison）。</p>
<h2 id="git-投毒">Git 投毒</h2>
<p>漏洞点出现在对 Pull Request 的数据迁移上，调用链如下：</p>
<ul>
<li><code>services/migrations/migrate.go:L376#uploader.CreatePullRequests</code></li>
<li><code>services/migrations/gitea_uploader.go:L466#g.newPullRequest</code></li>
<li><code>services/migrations/gitea_uploader.go:L602#g.updateGitForPullRequest</code></li>
</ul>
<p>出现漏洞的代码块在 <code>services/migrations/gitea_uploader.go:L531-L567</code> 处，精简后的代码如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#ff7b72">if</span> pr.<span style="color:#d2a8ff;font-weight:bold">IsForkPullRequest</span>() <span style="color:#ff7b72;font-weight:bold">&amp;&amp;</span> pr.State <span style="color:#ff7b72;font-weight:bold">!=</span> <span style="color:#a5d6ff">&#34;closed&#34;</span> {
</span></span><span style="display:flex;"><span> <span style="color:#ff7b72">if</span> pr.Head.OwnerName <span style="color:#ff7b72;font-weight:bold">!=</span> <span style="color:#a5d6ff">&#34;&#34;</span> {
</span></span><span style="display:flex;"><span> remote <span style="color:#ff7b72;font-weight:bold">:=</span> pr.Head.OwnerName
</span></span><span style="display:flex;"><span> _, ok <span style="color:#ff7b72;font-weight:bold">:=</span> g.prHeadCache[remote]
</span></span><span style="display:flex;"><span> <span style="color:#ff7b72">if</span> !ok {
</span></span><span style="display:flex;"><span> err <span style="color:#ff7b72;font-weight:bold">:=</span> g.gitRepo.<span style="color:#d2a8ff;font-weight:bold">AddRemote</span>(remote, pr.Head.CloneURL, <span style="color:#79c0ff">true</span>)
</span></span><span style="display:flex;"><span> <span style="color:#ff7b72">if</span> err <span style="color:#ff7b72;font-weight:bold">!=</span> <span style="color:#79c0ff">nil</span> {
</span></span><span style="display:flex;"><span> <span style="color:#ff7b72;font-weight:bold">...</span>
</span></span><span style="display:flex;"><span> } <span style="color:#ff7b72">else</span> {
</span></span><span style="display:flex;"><span> ok = <span style="color:#79c0ff">true</span>
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#ff7b72">if</span> ok {
</span></span><span style="display:flex;"><span> _, err = git.<span style="color:#d2a8ff;font-weight:bold">NewCommand</span>(g.ctx, <span style="color:#a5d6ff">&#34;fetch&#34;</span>, remote, pr.Head.Ref).<span style="color:#d2a8ff;font-weight:bold">RunInDir</span>(g.repo.<span style="color:#d2a8ff;font-weight:bold">RepoPath</span>())
</span></span><span style="display:flex;"><span> <span style="color:#ff7b72;font-weight:bold">...</span>
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>当远端存在来自 Fork 仓库提交的 Pull Request 请求，且该 PR 状态不为 Close 时，会进入该分支。
这里有一个 Map <code>g.prHeadCache</code> 作为临时缓存。第一次进入时该缓存为空，检测到 <code>remote</code> 的值不在 <code>g.prHeadCache</code> 中，调用 <code>g.gitRepo.AddRemote</code> 方法，该方法执行命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git remote add -f &lt;remote&gt; &lt;pr.Head.CloneURL&gt;
</span></span></code></pre></div><p>该命令正常执行，无错误抛出后，便将<code>ok</code> 设置成 <code>true</code>。到下方执行命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git fetch &lt;remote&gt; &lt;pr.Head.Ref&gt;
</span></span></code></pre></div><p>当我们选择从远端 Gitea 实例执行迁移时，上述 <code>remote</code> <code>pr.Head.CloneURL</code> <code>pr.Head.Ref</code> 参数<strong>均取自远端 Gitea Web API 响应中</strong>，均是可控的。因此只需要构造一个 HTTP 服务模拟 Gitea Web API 返回响应，以上的三个参数将从响应中获取。</p>
<h3 id="git---upload-pack-参数">Git <code>--upload-pack</code> 参数</h3>
<p>虽然上述两个命令中的三个参数都可控，但情况并不乐观：</p>
<ol>
<li>两条指令分别是 <code>git remote add</code> 和 <code>git fetch</code>，我们仅能控制其参数。</li>
<li>第二条命令执行的条件是需要保证第一条命令执行成功。</li>
</ol>
<p>第一个限制，也是这个漏洞的难点所在。在翻阅了 Git 文档后，Li4n0 发现 Git 的 <code>fetch</code> 子命令中存在 <code>--upload-pack</code> 这个参数。根据官方文档，当 <code>--upload-pack</code> 被指定时，其仓库拉取操作将使用 <code>git fetch-pack --exec=&lt;upload-pack&gt;</code> 替代。而 <code>git fetch-pack</code> 中的 <code>--exec</code> 参数同 <code>--upload-pack</code> 参数，用于指定<strong>远端</strong> <code>git-upload-pack</code> 命令执行的路径。</p>
<p>而如果我们设置远端 Git 仓库的路径为<strong>一个本地的仓库</strong>，则对于这个仓库来说，客户端是当前 Gitea 实例，远端服务端也是当前 Gitea 实例机器上的一个目录。因此便会在<strong>当前</strong> Gitea 实例所在的机器上执行命令。</p>
<p>因此， <code>git remote add</code> 中<code>&lt;pr.Head.CloneURL&gt;</code> 需填入一个本地的 Git 仓库地址。根据 Git 官方文档的描述，Git 支持 <code>file</code> <code>ssh</code> <code>http</code> 三种协议来获取 Git 仓库，本地仓库选择 <code>file</code> 协议。经过测试，如果使用 <code>file://&lt;path&gt;</code> 这种方式，需传入仓库完整的绝对路径。而我们无法得知线上 Gitea 实例的部署情况，自然不知道其绝对路径。同样在查看 Git 官方文档并测试后，我们发现这里不使用 <code>file</code> 协议头，<strong>直接输入仓库的相对路径也是可行的</strong>。当前两条<code>git</code>命令就是在一个 Git 仓库下执行的，因此直接传入<code>./</code> 即可。（也可以使用 <code>file</code> 协议头传入绝对路径 <code>/proc/self/cwd/</code> 来软链接指向当前 Git 命令的运行目录）</p>
<p>对于第二个限制，可以注意到两行命令均用到了 <code>&lt;remote&gt;</code> 变量。 若将 <code>&lt;remote&gt; </code> 变量设置成 <code>--upload-pack</code> 参数，因为 <code>git remote</code> 命令中无该参数，第一条命令会执行失败，第二条命令便不再会被执行。因此要将第二行命令中的 <code>&lt;pr.Head.Ref&gt;</code> 设置成 <code>--upload-pack</code> 参数，<code>&lt;remote&gt;</code> 设置成任意合法的名称，如 <code>origin</code>。</p>
<p>即最终执行的两条命令就是：</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>git remote add -f origin ./
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>git fetch origin --upload-pack<span style="color:#ff7b72;font-weight:bold">=</span>bash -c <span style="color:#a5d6ff">&#39;&lt;cmd&gt;&#39;</span>
</span></span></code></pre></div><p>综上，搭建一个 HTTP 服务并配置以下路由，来伪装成一个 Gitea 实例，响应体可以从一个正常 Gitea 的 API 中截取。</p>
<pre tabindex="0"><code>/api/v1/version
/api/v1/settings/api
/api/v1/repos/&lt;owner&gt;/&lt;repo&gt;/
/api/v1/repos/&lt;owner&gt;/&lt;repo&gt;/topics
/api/v1/repos/&lt;owner&gt;/&lt;repo&gt;/pulls
/api/v1/repos/&lt;owner&gt;/&lt;repo&gt;/issues/1/reactions
/api/v1/repos/&lt;owner&gt;/&lt;repo&gt;/pulls/2/reviews
</code></pre><p>在 <code>/api/v1/repos/&lt;owner&gt;/&lt;repo&gt;/pulls/2/reviews</code> 路由的响应 JSON 中，修改对应字段控制上文提到了三个字段的值，其中 <code>&lt;cmd&gt;</code> 为执行的命令：</p>
<pre tabindex="0"><code>[0].head.ref: --upload-pack=bash -c &#39;&lt;cmd&gt;&#39;
[0].head.repo.clone_url: ./
[0].head.owner.login: &lt;username&gt;
</code></pre><p>登录 Gitea 实例，右上角点击「+」-&gt; 「迁移外部仓库」-&gt;「Gitea」，在 「从 URL 迁移/克隆」 中填入上文搭建的伪装 Gitea 实例地址，执行迁移操作，代码便会被执行。</p>
<h2 id="最后聊几句">最后聊几句</h2>
<p>其实上面提到的这个只是 Gitea Migration 里杀伤力最大的一个漏洞，比这影响范围小的漏洞还有几个。比如同步 Git 仓库时输入本地目录可以越权查看已知仓库名的私有仓库，同步 Releases 发版信息时 HTTP GET 请求远端文件的 SSRF 等。这些大家可以自己去发掘下。
这个漏洞也正是我在文章开头提到的，给我们日常使用的程序传入恶意的配置或子命令，从而导致任意命令执行。如果开发人员不了解相关的 Trick，那么在调用第三方程序时就会很容易写出类似的漏洞，可谓防不胜防。</p>
<h2 id="时间线">时间线</h2>
<ul>
<li>2022-04-16 发现漏洞</li>
<li>2022-04-18 完成 Exploit 编写</li>
<li>2022-04-25 向 Gitea 官方上报漏洞信息</li>
<li>2022-04-26 Gitea 官方回复漏洞已确认，将在 v1.16.7 版本中修复</li>
<li>2022-05-02 Gitea 发布 v1.16.7 版本，漏洞被修复</li>
<li>2022-05-16 下发 CVE 编号：CVE-2022-30781</li>
</ul>
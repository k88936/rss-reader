<p>We <a href="https://www.reddit.com/r/singularity/comments/122ilav/why_is_maths_so_hard_for_llms/">keep trying to get LLMs to do math</a>. We want them <a href="https://community.openai.com/t/incorrect-count-of-r-characters-in-the-word-strawberry/829618">to count the number of &ldquo;rs&rdquo; in strawberry</a>, to perform <a href="https://arxiv.org/abs/2303.05398">algebraic reasoning</a>, <a href="https://news.ycombinator.com/item?id=30309302">do multiplication</a>, and <a href="https://mathstodon.xyz/@tao/113132502735585408">to solve math theorems.</a></p>
<figure><img src="https://veekaybee.github.io/images/llm_calc.png" width="400">
</figure>

<p>A <a href="https://x.com/yuntiandeng/status/1836114401213989366">recent experiment particularly</a> piqued my interest. Researchers used OpenAI&rsquo;s new <a href="https://openai.com/index/hello-gpt-4o/">4o model</a> to solve multiplication problems by using the prompt:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>Calculate the product of x and y. Please provide the final answer in the format: 
</span></span><span style="display:flex;"><span>Final Answer: <span style="color:#f92672">[</span>result<span style="color:#f92672">]</span>
</span></span></code></pre></div><figure><img src="https://veekaybee.github.io/images/72f1f906-20b6-4d5d-880a-da1065e15f39.png" width="400">
</figure>

<p>These models are generally <a href="https://arxiv.org/abs/2204.07705">trained for natural language tasks</a>, particularly text completions and chat.</p>
<figure><img src="https://veekaybee.github.io/images/1ef1bc9d-408d-40ea-b2ec-073120785ac6.png" width="400">
</figure>

<p>So why are we trying to get these enormous models, good for natural text completion tasks like summarization, translation, and writing poems, to multiply three-digit numbers and, what&rsquo;s more, attempt to return the results as a number?</p>
<p>Two reasons:</p>
<ol>
<li>Humans always try to use any new software/hardware we invent to do calculation</li>
<li>We don&rsquo;t actually want them to do math for the sake of replacing calculators, we want to understand if they can reason their way to AGI.</li>
</ol>
<h1 id="computers-and-counting-in-history">Computers and counting in history</h1>
<p>In the history of human relationships with computers, we&rsquo;ve always wanted to count large groups of things because <a href="https://en.wikipedia.org/wiki/The_Magical_Number_Seven,_Plus_or_Minus_Two">we&rsquo;re terrible at it</a>. Initially we used our hands - or others&rsquo; - in the Roman empire, administrators known as <em>calculatores</em> and slaves known as <a href="https://kartsci.org/kocomu/computer-history/history-abacus-ancient-computing/">calculones</a> performed household accounting manually.</p>
<figure><img src="https://veekaybee.github.io/images/bbe7a45f-86a5-40f3-abba-ec635ce7c93f.png" width="400">
</figure>

<p>Then, we started inventing calculation lookup tables. After the French Revolution, the French Republican government switched to the metric system in order to collect property taxes. In order to perform these calculations, it hired human computers to do the conversions by creating large tables of logarithms for decimal division of angles, <a href="https://inria.hal.science/inria-00543946/document">Tables du Cadastre</a>. This system was never completed and eventually scrapped, but it inspired Charles Babbage to do his work on machiens for calculation along with Ada Lovelace, which in turn kicked off the modern era of computing.</p>
<p>UNIVAC, one of the first modern computers, was used by the Census Bureau in <a href="https://www.census.gov/about/history/bureau-history/census-innovations/technology/univac-i.html">population counting.</a></p>
<p>The nascent field of artificial intelligence developed jointly in line with the expectation that machines should be able to replace humans in computation through historical developments like the Turing Test and <a href="https://en.wikipedia.org/wiki/Turochamp">Turing&rsquo;s chess program</a>, the <a href="https://spectrum.ieee.org/dartmouth-ai-workshop">Dartmouth Artificial Intelligence Conference</a> and <a href="https://www.ibm.com/history/early-games">Arthur Samuel&rsquo;s checkers demo</a>.Â </p>
<p>Humans have been inventing machines to mostly do math for milennia, and it&rsquo;s only recently that computing tasks have moved up the stack from calculations to higher human endeavors like writing, searching for information, and shitposting. So naturally, we want to use LLMs to do the thing we&rsquo;ve been doing with computers and software all these years.</p>
<h1 id="making-computers-think">Making computers think</h1>
<p>Second, we want to understand if LLMs can &ldquo;think.&rdquo; There is no one definition of what &ldquo;thinking&rdquo; means, but for these models in particular, <a href="https://arxiv.org/abs/2212.10403">we are interested to see</a> if they can work through a chain of steps to come to an answer about logical things that are easy for humans, as an example:</p>
<blockquote>
<p>all whales are mammals, all mammals have kidneys; therefore, all whales have kidneys</p>
</blockquote>
<p>One way humans reason is through performing different kinds of math: arithmetic, solving proofs, and reasoning through symbolic logic. The underlying question in artificial intelligence is whether machines can reason outside of the original task we gave them. For large language models, the ask is whether they can move from summarizing first a book if they were trained for books, to a movie script plot, to finally, summarizing what you did all day if you pass it a bunch of documents about your activity. So, it stands to reason that if LLMs can &ldquo;solve&rdquo; math problems, they can achieve AGI.</p>
<p>There are approximately seven hundred million benchmarks to see if LLMs can reason. <a href="https://www.llm-reasoning-benchmark.com/">Here&rsquo;s an example</a>, and <a href="https://arxiv.org/abs/2307.13692">here&rsquo;s another one</a>. Even since I started this draft yesterday, <a href="https://epochai.org/frontiermath/the-benchmark">a new one came out.</a></p>
<p>Since it&rsquo;s hard to define what &ldquo;reasoning&rdquo; or &ldquo;thinking&rdquo; means, the benchmarks try to proxy to see if models can answer the same questions we give to humans in settings such as university tests and compare the answers between human annotators generating ground truth and inference run on the model.</p>
<p>These types of tasks make up a <a href="https://huggingface.co/spaces/open-llm-leaderboard/open_llm_leaderboard">large number of LLM benchmarks that are popular on LLM leaderboards.</a></p>
<h1 id="how-calculators-work">How calculators work</h1>
<p>However, evaluating how good LLMs are at calculation doesn&rsquo;t take into account a critical component: the way that calculators arrive at their answer is radically different from how these models work. A calculator records the button you pressed and converts it to a binary representation of those digits. Then, it stores those number in memory registers until you press an operation key. For basic hardware calculators, the machine has built-in operations that perform variations of addition on the binary representation of the number stored in-memory:</p>
<pre><code> + addition is addition, 
 + subtraction is performed via two's complement operations, 
 + multiplication is just addition, and 
 + division is subtraction
</code></pre>
<p>In software calculators, <a href="https://www.bloomberg.com/graphics/2015-paul-ford-what-is-code/">the software takes user keyboard input</a>, generates a scan code for that key press, encodes the signal, converts it to character data, and uses an encoding standard to convert the key press to a binary representation. That binary representation is sent to the application level, which now starts to work with the variable in the programming language the calculator uses, and performs operations on those variables based on <a href="https://gitlab.gnome.org/GNOME/gnome-calculator/-/blob/main/lib/number.vala?ref_type=heads#L587">internally-defined methods for addition, subtraction, multiplication, and division.</a></p>
<p>Software calculators can grow to be fairly complicated with the addition of graphing operations and calculus, but usually have a standard collected set of methods to follow to perform the actual calcuation. As a fun aside, <a href="https://www.pcalc.com/mac/thirty.html">here&rsquo;s a great piece</a> on what it was like to build a calculator app Back In The Day.</p>
<p>The hardest part of the calculator is writing the logic for representing numbers correctly and creating manual classes of operations that cover all of math&rsquo;s weird corner cases.</p>
<p>However, to get an LLM to add &ldquo;2+2&rdquo;, we have a much more complex level of operations. Instead of a binary calculation machine that uses small, simple math business logic to derive an answer based on addition, we create an enormous model of the entire universe of human public thought and try to reason our way into the correct mathematical answer based on how many times the model has &ldquo;seen&rdquo; or been exposed to the text &ldquo;2+2&rdquo; in written form.</p>
<p>We first train a large language model to answer questions.</p>
<p><img src="https://veekaybee.github.io/images/87e4ee63-7270-4fcf-89da-45769b7aba53.jpg" alt="d8e7f5ec-c333-4890-8430-7f73fe9e89fa_1588x386"></p>
<p><a href="https://magazine.sebastianraschka.com/p/new-llm-pre-training-and-post-training">Source</a></p>
<p>This includes:</p>
<ol>
<li><a href="https://magazine.sebastianraschka.com/p/new-llm-pre-training-and-post-training">Gathering and deduplicating</a> an enormous amount of large-scale, clean internet text</li>
<li>We then train the model by feeding it the data and asking it, at a very simplified level, to predict the next word in a given sentence. We then compare that prediction to the baseline sentence and adjust a loss function. An attention mechanism helps guide the prediction by keeping a context map of all the words of our vocabulary (our large-scale clean internet text.)</li>
<li>Once the model is trained initially to perform the task of text completion, we perform <a href="https://arxiv.org/abs/2308.10792">instruction fine-tuning</a>, to more closely align the model with the task of performing a summarization task or following instructions.</li>
<li>The model is aligned with human preferences with RLHF. <a href="https://huggingface.co/blog/rlhf">This process</a> involves collecting a set of questions with human responses, and having human annotators rank the response of the model, and then feeding those ranks back into the model for tuning.</li>
<li>Finally, we stand up that artifact (or have it accessable as a service.) The artifact is <a href="https://vickiboykis.com/2024/02/28/gguf-the-long-way-around/">a file or a collection of files</a> that contain the model architecture and weights and biases of the model generated from steps 2 and 3.</li>
</ol>
<p>Then, when we&rsquo;re ready to query our model. This is the step that most people take to get an answer from an LLM when they hit a service or run a local model, equivalent to opening up the calculator app.</p>
<ol>
<li>We write &ldquo;What&rsquo;s 2 + 2&rdquo; into the text box.</li>
<li>This natural-language query <a href="https://cybernetist.com/2024/10/21/you-should-probably-pay-attention-to-tokenizers/">is tokenized</a>. Tokenization is the process of first converting our query into a string of words that the model uses as the first step in performing numerical lookups.</li>
<li>That text is then embedded in the context of the model&rsquo;s vocabulary by converting each word to an embedding and then creating an embedding vector of the input query.</li>
<li>We then passing the vector to the model&rsquo;s encoder, which stores the relative position of embeddings to each other in the model&rsquo;s vocabulary</li>
<li>Passing those results to the attention mechanism for lookup, which compares the similarity using various metrics of each token and position with every other token in the reference text (the model). This happens many times in multi-head attention architectures.</li>
<li>Getting results back from the decoder. A <a href="https://huggingface.co/docs/transformers/en/llm_tutorial">set of tokens and the probability of those tokens is returned from the decoder.</a> We need to generate the first token that all the other tokens are conditioned upon. However, afterwards, <a href="https://huggingface.co/blog/how-to-generate">returning probablities takes many forms</a>: namely search strategies like greedy search and and sampling, most frequently top-k sampling, the method originally used by GPT-2. Depending on which strategy you pick and what tradeoffs you&rsquo;d like to make, you will get <a href="https://gist.github.com/kalomaze/4473f3f975ff5e5fade06e632498f73e">slightly different answers of resulting tokens selected from the model&rsquo;s vocabulary.</a></li>
</ol>
<p>Finally, even after this part, to ensure that what the model outputs is an actual number, we could do a number of different guided generation strategies to ensure we get ints or longs as output from <a href="https://dottxt-ai.github.io/outlines/latest/welcome/">multiplication, addition, etc.</a></p>
<p>So this entire process, in order to add &ldquo;what is 2+2&rdquo;, we do a non-deterministic a lookup from an enormous hashtable that contains the sum of public human knowledge we&rsquo;ve seen fit to collect for our dataset, then we squeeze it through the tiny, nondeterministic funnels of decoding strategies and guided generation to get to an answer from a sampled probability distribution.</p>
<p>These steps include a large amount of actual humans in the loop guiding the model throughout its various stages.</p>
<figure><img src="https://veekaybee.github.io/images/8bd85044-8583-48dd-b620-f8f13a134d18.png" width="700">
</figure>

<p>And, all of this, only to get an answer that&rsquo;s right only some percent of the time, not consistent across all model architectures and platforms and in many cases has to be coaxed out of the model using techniques like chain of thought.</p>
<p>As an example, here&rsquo;s an aswer I&rsquo;ve tried on OpenAI, Claude, Gemini, and locally using Mistral via llamafile and ollama:</p>
<p><figure><img src="https://veekaybee.github.io/images/7be40c7f-8f7b-48db-9ad9-80c421e3c05c.png" width="400">
</figure>

Claude Sonnet 3.5</p>
<p><figure><img src="https://veekaybee.github.io/images/ec024d0d-3d58-4bab-9052-a31c91a0bc62.png" width="400">
</figure>

Gemini 1.5 Flash</p>
<p><figure><img src="https://veekaybee.github.io/images/ecd53bb1-063a-477d-9969-877cfa3eb35c.png" width="400">
</figure>

OpenAI ChatGPT GPT-4 Turbo</p>
<p><figure><img src="https://veekaybee.github.io/images/3fd6bdaf-dc08-4208-959f-46df356bc4d9.png" width="400">
</figure>

Llamafile Mistral 7-B Instruct 2</p>
<p><figure><img src="https://veekaybee.github.io/images/986371b3-6703-41a9-bdf8-ea74680149ed.png" width="400">
</figure>

Ollama Mistral</p>
<p>If you ask any given calculator what 2+2 is, you&rsquo;ll always get 4. This doesn&rsquo;t work with LLMs, even when it&rsquo;s variations of the same model, much less different models hosted across different service providers and in different levels of quantization, different sampling strategies, mix of input data, and more.</p>
<h2 id="why-are-we-even-doing-this">Why are we even doing this?</h2>
<p>From a user perspective, this is absolutely a disastrous violation of Jakob&rsquo;s Law of UX, which states that people <a href="https://vickiboykis.com/2024/05/06/weve-been-put-in-the-vibe-space/">expect the same kind of output</a> from the same kind of interface.</p>
<p>However, when you realize that the goal is, as <a href="https://mathstodon.xyz/@tao/113132502735585408">Terrence Tao notes</a>, to get models to solve mathematical theorems, it makes more sense, although all these models are still very far from actual reasoning.</p>
<p>I&rsquo;d love to see us spend time more understanding and working on the practical uses <a href="https://unlocked.microsoft.com/ai-anthology/terence-tao/">he discusses</a>: drafts of documents, as ways to check understanding of a codebase, and of course, <a href="https://vickiboykis.com/2023/02/26/what-should-you-use-chatgpt-for/">generating boilerplate Pydantic models for me personally</a>.</p>
<p>But, this is the core tradeoff between practicality and research: do we spend time on Pydantic now because it&rsquo;s what&rsquo;s useful to us at the moment, or do we try to get the model to write the code itself to the point where we don&rsquo;t even need Pydantic, or Python, or programming languages, and can write natural language code, backed by mathematical reasoning?</p>
<p>If we didn&rsquo;t spend time on the second, we never would have gotten even to GPT-2, but the question is, how much further can we get? I&rsquo;m not sure, but I personally am still not using LLMs for tasks that can&rsquo;t be verified or for reasoning, or for counting Rs.</p>
<hr>
<p>Further Reading:</p>
<ul>
<li><a href="https://mitpress.mit.edu/9780262549349/artificial-general-intelligence/">Artificial General Intelligence by Julian Togelius</a></li>
<li><a href="https://wwnorton.com/books/9780393882148">Empire of the Sum: The Rise and Reign of the Pocket Calculator by Keith Houston</a></li>
<li><a href="http://jmc.stanford.edu/articles/dartmouth/dartmouth.pdf">Dartmouth AI Workshop Original Proposal</a></li>
</ul>
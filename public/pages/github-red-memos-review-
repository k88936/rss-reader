<p>一直想要有一个平台，能够发些碎碎念之类，记录一下在食堂吃到的新菜式，或者分享一下有意思的事情。如果在 QQ 空间动态发，未免有些扰民了；如果在 Telegram 发，因为网络问题不是很方便；在知识星球发，很不幸我的知识星球账号莫名其妙地被停用了。</p>
<p>之前刷推特时偶然发现了 <a href="https://github.com/usememos/memos">memos</a> 这个项目，定位是一个 Self-hosted 的笔记应用，但看页面很像是一个精简版的 Twitter。memos 的功能很简单，令我感到惊讶的是，它的 Repo 居然有 36000+ 的 Stars 数，确实厉害。</p>
<p>碰巧 memos 也是用 Go 写，功能又这么简单，我便抽空阅读了下它的源码，也还算是小有收获，用这篇文章分享下我的心得体会。文中提到的内容可能你很早以前就知道了，还请多多包涵。</p>
<p>本文使用 commit <a href="https://github.com/usememos/memos/tree/edc3f1d9d9f8a7b075e0f53f22dd0480cc26451e"><code>edc3f1d</code> </a> 的代码进行演示。</p>
<h2 id="语义化版本">语义化版本</h2>
<p>语义化版本（Semantic Versioning）在 Go 里面应该是用得很多了。几年前参加 GopherChina 的时候，就有人专门分享了这个。</p>
<p>memos 在 <a href="https://github.com/usememos/memos/blob/edc3f1d9d9f8a7b075e0f53f22dd0480cc26451e/server/version/version.go"><code>server/version/version.go</code></a> 下记录了当前的版本号，并为使用 <code>golang.org/x/mod/semver</code> 实现了排序逻辑。值得注意的是，这里的版本号会被用于在数据库迁移（migration）中。每一个版本的数据库迁移 SQL 文件会被放置在以版本号命名的文件夹中，当执行数据库迁移时，会将这些版本号文件名进行排序，并与当前的版本号进行对比，从而选择要执行的迁移脚本。</p>
<h2 id="打死都不用-orm">打死都不用 ORM</h2>
<p>memos 支持 MySQL、Postgres、SQLite 三种数据库。遇到这种需要支持多种数据库的场景，我们往往会使用 ORM，就算对 ORM 存在的副作用不信任，也会选择 SQL 查询构造器（SQL Query Builder）的库来辅助我们构造 SQL。但 memos 不知道在坚持什么，硬生生地对着三套数据库后端写了三套代码！他甚至只用 <code>database/sql</code> 和对应数据库的 Driver！他甚至手写 SQL！他甚至还各种拼 SQL 查询条件的字段！</p>
<p>各位可以体会下 <a href="https://github.com/usememos/memos/blob/edc3f1d9d9f8a7b075e0f53f22dd0480cc26451e/store/db/mysql/activity.go#L23-L27">store/db/mysql/activity.go#L23-L27</a></p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>fields <span style="color:#ff7b72;font-weight:bold">:=</span> []<span style="color:#ff7b72">string</span>{<span style="color:#a5d6ff">&#34;`creator_id`&#34;</span>, <span style="color:#a5d6ff">&#34;`type`&#34;</span>, <span style="color:#a5d6ff">&#34;`level`&#34;</span>, <span style="color:#a5d6ff">&#34;`payload`&#34;</span>}
</span></span><span style="display:flex;"><span>placeholder <span style="color:#ff7b72;font-weight:bold">:=</span> []<span style="color:#ff7b72">string</span>{<span style="color:#a5d6ff">&#34;?&#34;</span>, <span style="color:#a5d6ff">&#34;?&#34;</span>, <span style="color:#a5d6ff">&#34;?&#34;</span>, <span style="color:#a5d6ff">&#34;?&#34;</span>}
</span></span><span style="display:flex;"><span>args <span style="color:#ff7b72;font-weight:bold">:=</span> []<span style="color:#ff7b72">any</span>{create.CreatorID, create.Type.<span style="color:#d2a8ff;font-weight:bold">String</span>(), create.Level.<span style="color:#d2a8ff;font-weight:bold">String</span>(), payloadString}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>stmt <span style="color:#ff7b72;font-weight:bold">:=</span> <span style="color:#a5d6ff">&#34;INSERT INTO `activity` (&#34;</span> <span style="color:#ff7b72;font-weight:bold">+</span> strings.<span style="color:#d2a8ff;font-weight:bold">Join</span>(fields, <span style="color:#a5d6ff">&#34;, &#34;</span>) <span style="color:#ff7b72;font-weight:bold">+</span> <span style="color:#a5d6ff">&#34;) VALUES (&#34;</span> <span style="color:#ff7b72;font-weight:bold">+</span> strings.<span style="color:#d2a8ff;font-weight:bold">Join</span>(placeholder, <span style="color:#a5d6ff">&#34;, &#34;</span>) <span style="color:#ff7b72;font-weight:bold">+</span> <span style="color:#a5d6ff">&#34;)&#34;</span>
</span></span></code></pre></div><p>这段 <code>INSERT</code> 真就硬生生地拼字段，硬生生的写死预编译占位符。</p>
<p>当然，有人提了 issue 问为什么不用 ORM，并且推荐了 <code>sqlc</code> 和 <code>sqlbuilders</code> 两个库。作者的回复是前者 <code>looks a little weird</code> （？），后者 <code> pretty much the same as the existing way</code>，综上所属作者认为保持现状啥也不改！😅</p>
<p>FYI：<a href="https://github.com/usememos/memos/issues/2517">https://github.com/usememos/memos/issues/2517</a></p>
<h2 id="玩出花的-grpc">玩出花的 gRPC</h2>
<p>memos 项目中对 gRPC 的写法可谓是教科书级别的。我也算是对着它的代码入门了下 gRPC。说来惭愧，我以前除了拿 Protobuf 写过 Hello World 的 demo，就没有更深入的应用了。</p>
<h3 id="buf">Buf</h3>
<p><a href="https://github.com/bufbuild/buf">Buf</a> 是一个用来辅助使用 Protobuf 的工具。它相当于为 Protobuf 实现了“包管理”的功能，你可以使用 <code>buf.yaml</code> 来定义需要引用的第三方 Proto，还可以配置 Lint 之类的规则。运行 <code>buf generate</code> 后便会自动去帮我们完成运行 <code>protoc-gen-go</code> 等一切操作。memos 中就使用到了 Buf，可以在 <a href="https://github.com/usememos/memos/blob/edc3f1d9d9f8a7b075e0f53f22dd0480cc26451e/proto/buf.yaml"><code>proto/buf.yaml</code></a> 找到。Buf 还会生成一个 <code>buf.lock</code> 文件，也就是包管理中常见的签名文件。</p>
<p>我们可以观察到 Buf 的 <code>dep</code> 依赖形如 <code>buf.build/googleapis/googleapis</code> 这样的 URL，访问便可跳转到 Buf Schema Registry 上对应 Package 的页面。</p>
<p>感觉用 Buf 来处理 Protobuf，操作简便，逼格一下就上去了，学到了。</p>
<h3 id="目录结构">目录结构</h3>
<p>memos 的 <code>/proto</code> 目录下，<code>store</code> 目录与数据库的表结构对应，为每张表对应的实例的 proto 定义。<code>api/v1</code> 目录中则是 <code>service</code> 的定义，这里则对应了 Web API 的路由。</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-protobuf" data-lang="protobuf"><span style="display:flex;"><span><span style="color:#ff7b72">service</span> AuthService {<span style="color:#f85149">
</span></span></span><span style="display:flex;"><span><span style="color:#f85149"></span> <span style="color:#8b949e;font-style:italic">// GetAuthStatus returns the current auth status of the user.
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span> <span style="color:#ff7b72">rpc</span> GetAuthStatus(GetAuthStatusRequest) <span style="color:#ff7b72">returns</span> (User) {<span style="color:#f85149">
</span></span></span><span style="display:flex;"><span><span style="color:#f85149"></span> <span style="color:#ff7b72">option</span> (google.api.http) <span style="color:#ff7b72;font-weight:bold">=</span> {post<span style="color:#ff7b72;font-weight:bold">:</span> <span style="color:#a5d6ff">&#34;/api/v1/auth/status&#34;</span>};<span style="color:#f85149">
</span></span></span><span style="display:flex;"><span><span style="color:#f85149"></span> }<span style="color:#f85149">
</span></span></span><span style="display:flex;"><span><span style="color:#f85149"></span> <span style="color:#8b949e;font-style:italic">// SignIn signs in the user with the given username and password.
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span> <span style="color:#ff7b72">rpc</span> SignIn(SignInRequest) <span style="color:#ff7b72">returns</span> (User) {<span style="color:#f85149">
</span></span></span><span style="display:flex;"><span><span style="color:#f85149"></span> <span style="color:#ff7b72">option</span> (google.api.http) <span style="color:#ff7b72;font-weight:bold">=</span> {post<span style="color:#ff7b72;font-weight:bold">:</span> <span style="color:#a5d6ff">&#34;/api/v1/auth/signin&#34;</span>};<span style="color:#f85149">
</span></span></span><span style="display:flex;"><span><span style="color:#f85149"></span> }<span style="color:#f85149">
</span></span></span><span style="display:flex;"><span><span style="color:#f85149"></span> <span style="color:#8b949e;font-style:italic">// SignInWithSSO signs in the user with the given SSO code.
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span> <span style="color:#ff7b72">rpc</span> SignInWithSSO(SignInWithSSORequest) <span style="color:#ff7b72">returns</span> (User) {<span style="color:#f85149">
</span></span></span><span style="display:flex;"><span><span style="color:#f85149"></span> <span style="color:#ff7b72">option</span> (google.api.http) <span style="color:#ff7b72;font-weight:bold">=</span> {post<span style="color:#ff7b72;font-weight:bold">:</span> <span style="color:#a5d6ff">&#34;/api/v1/auth/signin/sso&#34;</span>};<span style="color:#f85149">
</span></span></span><span style="display:flex;"><span><span style="color:#f85149"></span> }<span style="color:#f85149">
</span></span></span><span style="display:flex;"><span><span style="color:#f85149"></span> <span style="color:#8b949e;font-style:italic">// SignUp signs up the user with the given username and password.
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span> <span style="color:#ff7b72">rpc</span> SignUp(SignUpRequest) <span style="color:#ff7b72">returns</span> (User) {<span style="color:#f85149">
</span></span></span><span style="display:flex;"><span><span style="color:#f85149"></span> <span style="color:#ff7b72">option</span> (google.api.http) <span style="color:#ff7b72;font-weight:bold">=</span> {post<span style="color:#ff7b72;font-weight:bold">:</span> <span style="color:#a5d6ff">&#34;/api/v1/auth/signup&#34;</span>};<span style="color:#f85149">
</span></span></span><span style="display:flex;"><span><span style="color:#f85149"></span> }<span style="color:#f85149">
</span></span></span><span style="display:flex;"><span><span style="color:#f85149"></span> <span style="color:#8b949e;font-style:italic">// SignOut signs out the user.
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span> <span style="color:#ff7b72">rpc</span> SignOut(SignOutRequest) <span style="color:#ff7b72">returns</span> (google.protobuf.Empty) {<span style="color:#f85149">
</span></span></span><span style="display:flex;"><span><span style="color:#f85149"></span> <span style="color:#ff7b72">option</span> (google.api.http) <span style="color:#ff7b72;font-weight:bold">=</span> {post<span style="color:#ff7b72;font-weight:bold">:</span> <span style="color:#a5d6ff">&#34;/api/v1/auth/signout&#34;</span>};<span style="color:#f85149">
</span></span></span><span style="display:flex;"><span><span style="color:#f85149"></span> }<span style="color:#f85149">
</span></span></span><span style="display:flex;"><span><span style="color:#f85149"></span>}<span style="color:#f85149">
</span></span></span></code></pre></div><p>例如上述代码，<code>service</code> 中的每个 <code>rpc</code> 可以看作与一个 API 相对应。</p>
<p>例如 <code>GetAuthStatusRequest</code> 这些是在下面定义的 <code>message</code> ，相当于是接口的入参表单，<code>returns</code> 指定了返回值。没有返回值的接口则使用了 <code>google.protobuf.Empty</code> 。</p>
<p><code>option</code> 指定了 HTTP 下的请求路由和请求方法。</p>
<p>对于动态路由，感觉会有些复杂：</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-protobuf" data-lang="protobuf"><span style="display:flex;"><span><span style="color:#ff7b72">rpc</span> GetMemo(GetMemoRequest) <span style="color:#ff7b72">returns</span> (Memo) {<span style="color:#f85149">
</span></span></span><span style="display:flex;"><span><span style="color:#f85149"></span> <span style="color:#ff7b72">option</span> (google.api.http) <span style="color:#ff7b72;font-weight:bold">=</span> {get<span style="color:#ff7b72;font-weight:bold">:</span> <span style="color:#a5d6ff">&#34;/api/v1/{name=memos/*}&#34;</span>};<span style="color:#f85149">
</span></span></span><span style="display:flex;"><span><span style="color:#f85149"></span> <span style="color:#ff7b72">option</span> (google.api.method_signature) <span style="color:#ff7b72;font-weight:bold">=</span> <span style="color:#a5d6ff">&#34;name&#34;</span>;<span style="color:#f85149">
</span></span></span><span style="display:flex;"><span><span style="color:#f85149"></span>}<span style="color:#f85149">
</span></span></span><span style="display:flex;"><span><span style="color:#f85149">
</span></span></span><span style="display:flex;"><span><span style="color:#f85149"></span><span style="color:#ff7b72">rpc</span> UpdateMemo(UpdateMemoRequest) <span style="color:#ff7b72">returns</span> (Memo) {<span style="color:#f85149">
</span></span></span><span style="display:flex;"><span><span style="color:#f85149"></span> <span style="color:#ff7b72">option</span> (google.api.http) <span style="color:#ff7b72;font-weight:bold">=</span> {<span style="color:#f85149">
</span></span></span><span style="display:flex;"><span><span style="color:#f85149"></span> patch<span style="color:#ff7b72;font-weight:bold">:</span> <span style="color:#a5d6ff">&#34;/api/v1/{memo.name=memos/*}&#34;</span><span style="color:#f85149">
</span></span></span><span style="display:flex;"><span><span style="color:#f85149"></span> body<span style="color:#ff7b72;font-weight:bold">:</span> <span style="color:#a5d6ff">&#34;memo&#34;</span><span style="color:#f85149">
</span></span></span><span style="display:flex;"><span><span style="color:#f85149"></span> };<span style="color:#f85149">
</span></span></span><span style="display:flex;"><span><span style="color:#f85149"></span> <span style="color:#ff7b72">option</span> (google.api.method_signature) <span style="color:#ff7b72;font-weight:bold">=</span> <span style="color:#a5d6ff">&#34;memo,update_mask&#34;</span>;<span style="color:#f85149">
</span></span></span><span style="display:flex;"><span><span style="color:#f85149"></span>}<span style="color:#f85149">
</span></span></span></code></pre></div><p>第一个 <code>GetMemo</code> 中，限制了路由的必须要匹配到 <code>/api/v1/memos/*</code> ，后面的 <code>method_signature</code> 指定了必须要传 <code>name</code> 参数。</p>
<p>第二个 <code>UpdateMemo</code> 中，限制了路由必须匹配 <code>/api/v1/memos/*</code> 。大括号里有个很怪的 <code>memo.name=</code>，因为 proto 里参数都是在 rpc 的入参传入的（即 <code>UpdateMemoRequest</code> ），只是我们在通过 HTTP API 访问时才有 Path、Header、Query、Body 这些传参的方式。因此在 <code>rpc</code> 的定义里，路由中通配符的值来自于 <code>UpdateMemoRequest</code> 中的 <code>memo.name</code> 。而后面的 <code>method_signature</code> 指定了 <code>memo</code> 和 <code>update_mask</code> 为必须要传的参数。</p>
<p>Service 的具体实现上，其实跟正常写 HTTP 接口差不多，Service 结构体实现对应 interface 里定义的方法即可。我注意到方法的错误处理，使用的是 <code>google.golang.org/grpc/status</code> 构造的 <code>error</code>，状态码也是 grpc 包里自带的。</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#ff7b72">func</span> (s <span style="color:#ff7b72;font-weight:bold">*</span>APIV1Service) <span style="color:#d2a8ff;font-weight:bold">GetMemo</span>(ctx context.Context, request <span style="color:#ff7b72;font-weight:bold">*</span>v1pb.GetMemoRequest) (<span style="color:#ff7b72;font-weight:bold">*</span>v1pb.Memo, <span style="color:#ff7b72">error</span>) {
</span></span><span style="display:flex;"><span> <span style="color:#ff7b72;font-weight:bold">...</span>
</span></span><span style="display:flex;"><span> <span style="color:#ff7b72">return</span> <span style="color:#79c0ff">nil</span>, status.<span style="color:#d2a8ff;font-weight:bold">Errorf</span>(codes.PermissionDenied, <span style="color:#a5d6ff">&#34;permission denied&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>codes</code> 包里定义了 17 种状态码，我开始还怀疑就这么点状态码类型真的能给所有的错误分类吗？事实证明还真可以。像 RESTful API 里常常表示的 <code>403</code> 没权限、<code>404</code> 不存在、<code>400</code> 格式不对、<code>5xx</code> 服务寄了 等状态，都可以找到状态码进行对应。</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#ff7b72">var</span> strToCode = <span style="color:#ff7b72">map</span>[<span style="color:#ff7b72">string</span>]Code{
</span></span><span style="display:flex;"><span> <span style="color:#a5d6ff">`&#34;OK&#34;`</span>: OK,
</span></span><span style="display:flex;"><span> <span style="color:#a5d6ff">`&#34;CANCELLED&#34;`</span>:<span style="color:#8b949e;font-style:italic">/* [sic] */</span> Canceled,
</span></span><span style="display:flex;"><span> <span style="color:#a5d6ff">`&#34;UNKNOWN&#34;`</span>: Unknown,
</span></span><span style="display:flex;"><span> <span style="color:#a5d6ff">`&#34;INVALID_ARGUMENT&#34;`</span>: InvalidArgument,
</span></span><span style="display:flex;"><span> <span style="color:#a5d6ff">`&#34;DEADLINE_EXCEEDED&#34;`</span>: DeadlineExceeded,
</span></span><span style="display:flex;"><span> <span style="color:#a5d6ff">`&#34;NOT_FOUND&#34;`</span>: NotFound,
</span></span><span style="display:flex;"><span> <span style="color:#a5d6ff">`&#34;ALREADY_EXISTS&#34;`</span>: AlreadyExists,
</span></span><span style="display:flex;"><span> <span style="color:#a5d6ff">`&#34;PERMISSION_DENIED&#34;`</span>: PermissionDenied,
</span></span><span style="display:flex;"><span> <span style="color:#a5d6ff">`&#34;RESOURCE_EXHAUSTED&#34;`</span>: ResourceExhausted,
</span></span><span style="display:flex;"><span> <span style="color:#a5d6ff">`&#34;FAILED_PRECONDITION&#34;`</span>: FailedPrecondition,
</span></span><span style="display:flex;"><span> <span style="color:#a5d6ff">`&#34;ABORTED&#34;`</span>: Aborted,
</span></span><span style="display:flex;"><span> <span style="color:#a5d6ff">`&#34;OUT_OF_RANGE&#34;`</span>: OutOfRange,
</span></span><span style="display:flex;"><span> <span style="color:#a5d6ff">`&#34;UNIMPLEMENTED&#34;`</span>: Unimplemented,
</span></span><span style="display:flex;"><span> <span style="color:#a5d6ff">`&#34;INTERNAL&#34;`</span>: Internal,
</span></span><span style="display:flex;"><span> <span style="color:#a5d6ff">`&#34;UNAVAILABLE&#34;`</span>: Unavailable,
</span></span><span style="display:flex;"><span> <span style="color:#a5d6ff">`&#34;DATA_LOSS&#34;`</span>: DataLoss,
</span></span><span style="display:flex;"><span> <span style="color:#a5d6ff">`&#34;UNAUTHENTICATED&#34;`</span>: Unauthenticated,
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="grpc-server-和-restful-api-server">gRPC Server 和 RESTful API Server</h3>
<p>memos 的 <code>server/server.go</code> 文件定义了 HTTP 服务。它的 HTTP 服务使用 echo 框架。</p>
<p>重点看下面的代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>grpcServer <span style="color:#ff7b72;font-weight:bold">:=</span> grpc.<span style="color:#d2a8ff;font-weight:bold">NewServer</span>(
</span></span><span style="display:flex;"><span> <span style="color:#8b949e;font-style:italic">// Override the maximum receiving message size to math.MaxInt32 for uploading large resources.</span>
</span></span><span style="display:flex;"><span> grpc.<span style="color:#d2a8ff;font-weight:bold">MaxRecvMsgSize</span>(math.MaxInt32),
</span></span><span style="display:flex;"><span> grpc.<span style="color:#d2a8ff;font-weight:bold">ChainUnaryInterceptor</span>(
</span></span><span style="display:flex;"><span> apiv1.<span style="color:#d2a8ff;font-weight:bold">NewLoggerInterceptor</span>().LoggerInterceptor,
</span></span><span style="display:flex;"><span> grpcrecovery.<span style="color:#d2a8ff;font-weight:bold">UnaryServerInterceptor</span>(),
</span></span><span style="display:flex;"><span> apiv1.<span style="color:#d2a8ff;font-weight:bold">NewGRPCAuthInterceptor</span>(store, secret).AuthenticationInterceptor,
</span></span><span style="display:flex;"><span> ))
</span></span><span style="display:flex;"><span>s.grpcServer = grpcServer
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>apiV1Service <span style="color:#ff7b72;font-weight:bold">:=</span> apiv1.<span style="color:#d2a8ff;font-weight:bold">NewAPIV1Service</span>(s.Secret, profile, store, grpcServer)
</span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// Register gRPC gateway as api v1.</span>
</span></span><span style="display:flex;"><span><span style="color:#ff7b72">if</span> err <span style="color:#ff7b72;font-weight:bold">:=</span> apiV1Service.<span style="color:#d2a8ff;font-weight:bold">RegisterGateway</span>(ctx, echoServer); err <span style="color:#ff7b72;font-weight:bold">!=</span> <span style="color:#79c0ff">nil</span> {
</span></span><span style="display:flex;"><span> <span style="color:#ff7b72">return</span> <span style="color:#79c0ff">nil</span>, errors.<span style="color:#d2a8ff;font-weight:bold">Wrap</span>(err, <span style="color:#a5d6ff">&#34;failed to register gRPC gateway&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这里首先声明了一个 gRPC Server，并加了些常见的 Recover 中间件、Logger 拦截器、ACL 鉴权拦截器等。</p>
<p>后面的 <code>NewAPIV1Service</code> 创建每一块接口的 ServiceServer。跟进去可以看到，它会向上述定义的 gRPC Server 注册所支持的服务。这些注册服务的 <code>v1pb.RegisterXXXServiceServer</code> 就是用 proto 文件自动生成的了。</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#ff7b72">func</span> <span style="color:#d2a8ff;font-weight:bold">NewAPIV1Service</span>(secret <span style="color:#ff7b72">string</span>, profile <span style="color:#ff7b72;font-weight:bold">*</span>profile.Profile, store <span style="color:#ff7b72;font-weight:bold">*</span>store.Store, grpcServer <span style="color:#ff7b72;font-weight:bold">*</span>grpc.Server) <span style="color:#ff7b72;font-weight:bold">*</span>APIV1Service {
</span></span><span style="display:flex;"><span> grpc.EnableTracing = <span style="color:#79c0ff">true</span>
</span></span><span style="display:flex;"><span> apiv1Service <span style="color:#ff7b72;font-weight:bold">:=</span> <span style="color:#ff7b72;font-weight:bold">&amp;</span>APIV1Service{
</span></span><span style="display:flex;"><span> Secret: secret,
</span></span><span style="display:flex;"><span> Profile: profile,
</span></span><span style="display:flex;"><span> Store: store,
</span></span><span style="display:flex;"><span> grpcServer: grpcServer,
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> v1pb.<span style="color:#d2a8ff;font-weight:bold">RegisterWorkspaceServiceServer</span>(grpcServer, apiv1Service)
</span></span><span style="display:flex;"><span> v1pb.<span style="color:#d2a8ff;font-weight:bold">RegisterWorkspaceSettingServiceServer</span>(grpcServer, apiv1Service)
</span></span><span style="display:flex;"><span> v1pb.<span style="color:#d2a8ff;font-weight:bold">RegisterAuthServiceServer</span>(grpcServer, apiv1Service)
</span></span><span style="display:flex;"><span> v1pb.<span style="color:#d2a8ff;font-weight:bold">RegisterUserServiceServer</span>(grpcServer, apiv1Service)
</span></span><span style="display:flex;"><span> v1pb.<span style="color:#d2a8ff;font-weight:bold">RegisterMemoServiceServer</span>(grpcServer, apiv1Service)
</span></span><span style="display:flex;"><span> v1pb.<span style="color:#d2a8ff;font-weight:bold">RegisterResourceServiceServer</span>(grpcServer, apiv1Service)
</span></span><span style="display:flex;"><span> v1pb.<span style="color:#d2a8ff;font-weight:bold">RegisterInboxServiceServer</span>(grpcServer, apiv1Service)
</span></span><span style="display:flex;"><span> v1pb.<span style="color:#d2a8ff;font-weight:bold">RegisterActivityServiceServer</span>(grpcServer, apiv1Service)
</span></span><span style="display:flex;"><span> v1pb.<span style="color:#d2a8ff;font-weight:bold">RegisterWebhookServiceServer</span>(grpcServer, apiv1Service)
</span></span><span style="display:flex;"><span> v1pb.<span style="color:#d2a8ff;font-weight:bold">RegisterMarkdownServiceServer</span>(grpcServer, apiv1Service)
</span></span><span style="display:flex;"><span> v1pb.<span style="color:#d2a8ff;font-weight:bold">RegisterIdentityProviderServiceServer</span>(grpcServer, apiv1Service)
</span></span><span style="display:flex;"><span> reflection.<span style="color:#d2a8ff;font-weight:bold">Register</span>(grpcServer)
</span></span><span style="display:flex;"><span> <span style="color:#ff7b72">return</span> apiv1Service
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>最后的 <code>reflection.Register(grpcServer)</code> 用于注册 gRPC 的反射功能，让客户端在运行时能动态获取 gRPC 服务的相关信息，如服务列表、方法列表、方法的输入输出参数类型等，而不需要事先知道服务的具体定义。</p>
<hr>
<p>向 gRPC Server 注册完服务后，下面是<strong>将 Echo 框架启动的 HTTP Server 作为 Gateway，以实现通过 HTTP 的方式来访问 gRPC Service。</strong>（echoServer 就是 <code>echo.New()</code> 出来的实例）</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// Register gRPC gateway as api v1.</span>
</span></span><span style="display:flex;"><span><span style="color:#ff7b72">if</span> err <span style="color:#ff7b72;font-weight:bold">:=</span> apiV1Service.<span style="color:#d2a8ff;font-weight:bold">RegisterGateway</span>(ctx, echoServer); err <span style="color:#ff7b72;font-weight:bold">!=</span> <span style="color:#79c0ff">nil</span> {
</span></span><span style="display:flex;"><span> <span style="color:#ff7b72">return</span> <span style="color:#79c0ff">nil</span>, errors.<span style="color:#d2a8ff;font-weight:bold">Wrap</span>(err, <span style="color:#a5d6ff">&#34;failed to register gRPC gateway&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>跟进去看定义。这里居然新建了一个 gRPC 的客户端！</p>
<p><code>runtime.NewServeMux()</code> 是 <code>grpc-gateway</code> 下的包，用于返回一个 HTTP Mux，后续就可以交给任意的 Go HTTP 框架去调用。下面自动生成的 <code>v1pb.RegisterXXXServiceHandler</code> 这些路由 Handler，就是来自于上文 proto 文件里的 <code>google.api.http</code> 注解。</p>
<p>最后将这个 HTTP Mux 包起来交给 echo 框架的 handler，放在了 <code>/api/v1/*</code> 路由下。这样我们就实现了 RESTful 风格的 API。</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// RegisterGateway registers the gRPC-Gateway with the given Echo instance.</span>
</span></span><span style="display:flex;"><span><span style="color:#ff7b72">func</span> (s <span style="color:#ff7b72;font-weight:bold">*</span>APIV1Service) <span style="color:#d2a8ff;font-weight:bold">RegisterGateway</span>(ctx context.Context, echoServer <span style="color:#ff7b72;font-weight:bold">*</span>echo.Echo) <span style="color:#ff7b72">error</span> {
</span></span><span style="display:flex;"><span> conn, err <span style="color:#ff7b72;font-weight:bold">:=</span> grpc.<span style="color:#d2a8ff;font-weight:bold">NewClient</span>(
</span></span><span style="display:flex;"><span> fmt.<span style="color:#d2a8ff;font-weight:bold">Sprintf</span>(<span style="color:#a5d6ff">&#34;%s:%d&#34;</span>, s.Profile.Addr, s.Profile.Port),
</span></span><span style="display:flex;"><span> grpc.<span style="color:#d2a8ff;font-weight:bold">WithTransportCredentials</span>(insecure.<span style="color:#d2a8ff;font-weight:bold">NewCredentials</span>()),
</span></span><span style="display:flex;"><span> grpc.<span style="color:#d2a8ff;font-weight:bold">WithDefaultCallOptions</span>(grpc.<span style="color:#d2a8ff;font-weight:bold">MaxCallRecvMsgSize</span>(math.MaxInt32)),
</span></span><span style="display:flex;"><span> )
</span></span><span style="display:flex;"><span> <span style="color:#ff7b72">if</span> err <span style="color:#ff7b72;font-weight:bold">!=</span> <span style="color:#79c0ff">nil</span> {
</span></span><span style="display:flex;"><span> <span style="color:#ff7b72">return</span> err
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> gwMux <span style="color:#ff7b72;font-weight:bold">:=</span> runtime.<span style="color:#d2a8ff;font-weight:bold">NewServeMux</span>()
</span></span><span style="display:flex;"><span> <span style="color:#ff7b72">if</span> err <span style="color:#ff7b72;font-weight:bold">:=</span> v1pb.<span style="color:#d2a8ff;font-weight:bold">RegisterWorkspaceServiceHandler</span>(ctx, gwMux, conn); err <span style="color:#ff7b72;font-weight:bold">!=</span> <span style="color:#79c0ff">nil</span> {
</span></span><span style="display:flex;"><span> <span style="color:#ff7b72">return</span> err
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> <span style="color:#8b949e;font-style:italic">// ...</span>
</span></span><span style="display:flex;"><span> <span style="color:#ff7b72">if</span> err <span style="color:#ff7b72;font-weight:bold">:=</span> v1pb.<span style="color:#d2a8ff;font-weight:bold">RegisterIdentityProviderServiceHandler</span>(ctx, gwMux, conn); err <span style="color:#ff7b72;font-weight:bold">!=</span> <span style="color:#79c0ff">nil</span> {
</span></span><span style="display:flex;"><span> <span style="color:#ff7b72">return</span> err
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> gwGroup <span style="color:#ff7b72;font-weight:bold">:=</span> echoServer.<span style="color:#d2a8ff;font-weight:bold">Group</span>(<span style="color:#a5d6ff">&#34;&#34;</span>)
</span></span><span style="display:flex;"><span> gwGroup.<span style="color:#d2a8ff;font-weight:bold">Use</span>(middleware.<span style="color:#d2a8ff;font-weight:bold">CORS</span>())
</span></span><span style="display:flex;"><span> handler <span style="color:#ff7b72;font-weight:bold">:=</span> echo.<span style="color:#d2a8ff;font-weight:bold">WrapHandler</span>(gwMux)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> gwGroup.<span style="color:#d2a8ff;font-weight:bold">Any</span>(<span style="color:#a5d6ff">&#34;/api/v1/*&#34;</span>, handler)
</span></span><span style="display:flex;"><span> gwGroup.<span style="color:#d2a8ff;font-weight:bold">Any</span>(<span style="color:#a5d6ff">&#34;/file/*&#34;</span>, handler)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#8b949e;font-style:italic">// GRPC web proxy.</span>
</span></span><span style="display:flex;"><span> options <span style="color:#ff7b72;font-weight:bold">:=</span> []grpcweb.Option{
</span></span><span style="display:flex;"><span> grpcweb.<span style="color:#d2a8ff;font-weight:bold">WithCorsForRegisteredEndpointsOnly</span>(<span style="color:#79c0ff">false</span>),
</span></span><span style="display:flex;"><span> grpcweb.<span style="color:#d2a8ff;font-weight:bold">WithOriginFunc</span>(<span style="color:#ff7b72">func</span>(_ <span style="color:#ff7b72">string</span>) <span style="color:#ff7b72">bool</span> {
</span></span><span style="display:flex;"><span> <span style="color:#ff7b72">return</span> <span style="color:#79c0ff">true</span>
</span></span><span style="display:flex;"><span> }),
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> wrappedGrpc <span style="color:#ff7b72;font-weight:bold">:=</span> grpcweb.<span style="color:#d2a8ff;font-weight:bold">WrapServer</span>(s.grpcServer, options<span style="color:#ff7b72;font-weight:bold">...</span>)
</span></span><span style="display:flex;"><span> echoServer.<span style="color:#d2a8ff;font-weight:bold">Any</span>(<span style="color:#a5d6ff">&#34;/memos.api.v1.*&#34;</span>, echo.<span style="color:#d2a8ff;font-weight:bold">WrapHandler</span>(wrappedGrpc))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#ff7b72">return</span> <span style="color:#79c0ff">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>下面还声明了一个 gRPC Web Proxy，这个是用 HTTP 的方式来调 gRPC。使用的 <code>grpcweb</code> 包，调用接口传参并不是用的 Query 或者 Body，而是 protobuf 将参数序列化后再发送那套。跟走纯 TCP 相比，仅仅只是这里走的是 HTTP 请求而已。换句话说，就是让浏览器能跟 gRPC Server 通信了。</p>
<p>而浏览器中调用会有同源跨域的问题，所以可以看到这里的 <code>grpcweb.Option</code> 也是逐重解决 CORS 和 Origin。</p>
<p>希望看到这里你没被绕晕。你会发现，<strong>memos 其实是用 HTTP 实现了两套服务：RESTful API 和 gRPC Server API</strong>。这两套背后的业务逻辑都是一样的，且都是使用 HTTP 协议，不同点在于路由和传参的方式不一样。</p>
<h3 id="端口复用">端口复用</h3>
<p>有个比较抽象的小细节不知道你发现了没有，gRPC Server -&gt; gRPC Server API 只需要用 grpcweb 包一下就行了，但 RESTful API 需要再本地建一个 gRPC Client，然后这个 Client 自己请求本地的 Server。整条链路是 HTTP Mux -&gt; Handler Func -&gt; gRPC Client -&gt; gRPC Server。而这个 gRPC Client 监听的端口，居然与对外的 HTTP 服务的端口是一样的！</p>
<p>换句话说，就是 <strong>gRPC Server 和 echo HTTP Server 复用了同一个端口</strong>。</p>
<p>这里是使用了 <a href="http://github.com/soheilhy/cmux">github.com/soheilhy/cmux</a> 这个库来实现。这个库支持定义 Matcher 条件，哪个匹配上了就走哪个的 Serve。</p>
<p>像 gRPC Server 在通过 HTTP 调用时，通过 Body 发送 Protobuf 报文，<code>Content-Type</code> 为 <code>application/grpc</code>；而 RESTful API 则是常规的 HTTP 请求，除了 <code>PATCH</code> 方法外都会命中。</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>muxServer <span style="color:#ff7b72;font-weight:bold">:=</span> cmux.<span style="color:#d2a8ff;font-weight:bold">New</span>(listener)
</span></span><span style="display:flex;"><span><span style="color:#ff7b72">go</span> <span style="color:#ff7b72">func</span>() {
</span></span><span style="display:flex;"><span> grpcListener <span style="color:#ff7b72;font-weight:bold">:=</span> muxServer.<span style="color:#d2a8ff;font-weight:bold">MatchWithWriters</span>(cmux.<span style="color:#d2a8ff;font-weight:bold">HTTP2MatchHeaderFieldSendSettings</span>(<span style="color:#a5d6ff">&#34;content-type&#34;</span>, <span style="color:#a5d6ff">&#34;application/grpc&#34;</span>))
</span></span><span style="display:flex;"><span> <span style="color:#ff7b72">if</span> err <span style="color:#ff7b72;font-weight:bold">:=</span> s.grpcServer.<span style="color:#d2a8ff;font-weight:bold">Serve</span>(grpcListener); err <span style="color:#ff7b72;font-weight:bold">!=</span> <span style="color:#79c0ff">nil</span> {
</span></span><span style="display:flex;"><span> slog.<span style="color:#d2a8ff;font-weight:bold">Error</span>(<span style="color:#a5d6ff">&#34;failed to serve gRPC&#34;</span>, <span style="color:#a5d6ff">&#34;error&#34;</span>, err)
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span>}()
</span></span><span style="display:flex;"><span><span style="color:#ff7b72">go</span> <span style="color:#ff7b72">func</span>() {
</span></span><span style="display:flex;"><span> httpListener <span style="color:#ff7b72;font-weight:bold">:=</span> muxServer.<span style="color:#d2a8ff;font-weight:bold">Match</span>(cmux.<span style="color:#d2a8ff;font-weight:bold">HTTP1Fast</span>(http.MethodPatch))
</span></span><span style="display:flex;"><span> s.echoServer.Listener = httpListener
</span></span><span style="display:flex;"><span> <span style="color:#ff7b72">if</span> err <span style="color:#ff7b72;font-weight:bold">:=</span> s.echoServer.<span style="color:#d2a8ff;font-weight:bold">Start</span>(address); err <span style="color:#ff7b72;font-weight:bold">!=</span> <span style="color:#79c0ff">nil</span> {
</span></span><span style="display:flex;"><span> slog.<span style="color:#d2a8ff;font-weight:bold">Error</span>(<span style="color:#a5d6ff">&#34;failed to start echo server&#34;</span>, <span style="color:#a5d6ff">&#34;error&#34;</span>, err)
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span>}()
</span></span><span style="display:flex;"><span><span style="color:#ff7b72">go</span> <span style="color:#ff7b72">func</span>() {
</span></span><span style="display:flex;"><span> <span style="color:#ff7b72">if</span> err <span style="color:#ff7b72;font-weight:bold">:=</span> muxServer.<span style="color:#d2a8ff;font-weight:bold">Serve</span>(); err <span style="color:#ff7b72;font-weight:bold">!=</span> <span style="color:#79c0ff">nil</span> {
</span></span><span style="display:flex;"><span> slog.<span style="color:#d2a8ff;font-weight:bold">Error</span>(<span style="color:#a5d6ff">&#34;mux server listen error&#34;</span>, <span style="color:#a5d6ff">&#34;error&#34;</span>, err)
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span>}()
</span></span></code></pre></div><p>这里对 gRPC 的操作属实妙哉！端口复用的操作更是一绝。想起我之前有个 Side Project，既需要跑对外的 Web Server 后端，又需要跑对内的 API Server 后端，当时的做法是监听两个不同端口，现在想来可以用 cmux 来实现端口复用了。</p>
<h3 id="梦开始的地方">梦开始的地方</h3>
<p>那么请问，上述这种教科书级别的 Protobuf 和 gRPC 的用法，是来自于哪里的呢？</p>
<p>我观察到 memos 的作者居然也给 Bytebase 提交过代码，好家伙，老熟人啊。同时，我在 Bytebase 的仓库里，找到了 <a href="https://github.com/bytebase/bytebase/pull/3751">#3751</a> 这个 PR。<del>（万恶之源）</del></p>
<p>在 2022 年 12 月（好像就是 DevJoy 结束后一个月），Bytebase 仓库引入了第一个 proto 文件。从此便一发不可收拾，原先的 Web API 全都变成了 gRPC Server 的写法，同时也开始使用 Buf 来管理 proto 文件。memos 的作者作为后面加入 Bytebase 的员工，也是将 Bytebase 对于 gRPC 的最佳实践，用在了他的 Side Project，也就是 memos 中。</p>
<p>我想大概是这么个故事情节吧。😁</p>
<h2 id="定时任务">定时任务</h2>
<p>memos 内部自行实现了三个很基础的定时任务。为什么说很基础呢，因为就是使用 <code>time.NewTicker</code> 来做的。每个定时任务的 Runner 都会实现 <code>Run()</code> 和 <code>RunOnce()</code> 两个方法，这里可能可以定义成一个接口？</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#ff7b72">func</span> (r <span style="color:#ff7b72;font-weight:bold">*</span>Runner) <span style="color:#d2a8ff;font-weight:bold">Run</span>(ctx context.Context) {
</span></span><span style="display:flex;"><span> ticker <span style="color:#ff7b72;font-weight:bold">:=</span> time.<span style="color:#d2a8ff;font-weight:bold">NewTicker</span>(runnerInterval)
</span></span><span style="display:flex;"><span> <span style="color:#ff7b72">defer</span> ticker.<span style="color:#d2a8ff;font-weight:bold">Stop</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#ff7b72">for</span> {
</span></span><span style="display:flex;"><span> <span style="color:#ff7b72">select</span> {
</span></span><span style="display:flex;"><span> <span style="color:#ff7b72">case</span> <span style="color:#ff7b72;font-weight:bold">&lt;-</span>ticker.C:
</span></span><span style="display:flex;"><span> r.<span style="color:#d2a8ff;font-weight:bold">RunOnce</span>(ctx)
</span></span><span style="display:flex;"><span> <span style="color:#ff7b72">case</span> <span style="color:#ff7b72;font-weight:bold">&lt;-</span>ctx.<span style="color:#d2a8ff;font-weight:bold">Done</span>():
</span></span><span style="display:flex;"><span> <span style="color:#ff7b72">return</span>
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>三个定时任务分别是 <code>s3presign</code> <code>version</code> <code>memopreperty</code> 。</p>
<ul>
<li>
<p><code>s3presign</code> 每 12 个小时遍历一波数据库中存储的上传到 S3 的资源，将临时 URL 有效期不到一天的资源，重新调用 S3 SDK 中的 PreSign 签一个五天的临时 URL。memos 在数据库中存储图片等资源的临时 URL，感觉是为了防止私有笔记中的资源 URL 泄露。使用 PreSign URL 后，即使将公开笔记转为私有，之前的链接在五天后也就过期了。</p>
</li>
<li>
<p><code>version</code> 每 8 个小时请求 memos 自己的 API 获取当前 memos 的最新版本。判断版本落后并且数据库中之前还没有过版本更新提醒的话，就新增一条 <code>Activity</code> 记录，并将该 <code>Activity</code> 加到管理员账号的 Inbox 收件箱中。让管理员收到版本更新的消息。</p>
<p>其中 <code>GetLatestVersion</code> 获取最新版本的函数，解析请求体这里，感觉可以进一步精简成一行。</p>
<p><strong>BEFORE</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>buf <span style="color:#ff7b72;font-weight:bold">:=</span> <span style="color:#ff7b72;font-weight:bold">&amp;</span>bytes.Buffer{}
</span></span><span style="display:flex;"><span>_, err = buf.<span style="color:#d2a8ff;font-weight:bold">ReadFrom</span>(response.Body)
</span></span><span style="display:flex;"><span><span style="color:#ff7b72">if</span> err <span style="color:#ff7b72;font-weight:bold">!=</span> <span style="color:#79c0ff">nil</span> {
</span></span><span style="display:flex;"><span> <span style="color:#ff7b72">return</span> <span style="color:#a5d6ff">&#34;&#34;</span>, errors.<span style="color:#d2a8ff;font-weight:bold">Wrap</span>(err, <span style="color:#a5d6ff">&#34;fail to read response body&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>version <span style="color:#ff7b72;font-weight:bold">:=</span> <span style="color:#a5d6ff">&#34;&#34;</span>
</span></span><span style="display:flex;"><span><span style="color:#ff7b72">if</span> err = json.<span style="color:#d2a8ff;font-weight:bold">Unmarshal</span>(buf.<span style="color:#d2a8ff;font-weight:bold">Bytes</span>(), <span style="color:#ff7b72;font-weight:bold">&amp;</span>version); err <span style="color:#ff7b72;font-weight:bold">!=</span> <span style="color:#79c0ff">nil</span> {
</span></span><span style="display:flex;"><span> <span style="color:#ff7b72">return</span> <span style="color:#a5d6ff">&#34;&#34;</span>, errors.<span style="color:#d2a8ff;font-weight:bold">Wrap</span>(err, <span style="color:#a5d6ff">&#34;fail to unmarshal get version response&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><strong>AFTER</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>json.<span style="color:#d2a8ff;font-weight:bold">NewDecoder</span>(response.Body).<span style="color:#d2a8ff;font-weight:bold">Decode</span>(<span style="color:#ff7b72;font-weight:bold">&amp;</span>version)
</span></span></code></pre></div></li>
<li>
<p><code>memopreperty</code> 每 12 小时遍历一遍所有 Payload 为空的 memos 笔记，从它的内容中解析出 Tag、链接、代码块等属性，保存到 memos 的 Property 中。这个函数在创建、修改、更新 MemoTag 时都会调用。额外加到定时任务中出发，应该是为了兜底。</p>
</li>
</ul>
<h2 id="gomark">gomark</h2>
<p>对于用户每一篇文本笔记，memos 都会使用 <a href="https://github.com/usememos/gomark">github.com/usememos/gomark</a> 库来做结构化的解析。将文本内容解析成不同类型的 Go 结构体块，以实现将 Markdown 格式转纯文本、笔记 Tag 提取等功能。</p>
<p>这里简单拆解一下这个包的结构和原理，本质上又是把文本进行词法分析转换为 Tokens，构建 AST 抽象语法树，然后通过遍历 AST 实现上述提到的功能。gomark 好就好在他功能简单但全面，很适合像我这种从没学过编译原理的菜鸡。</p>
<p><code>parser/tokenizer/tokenizers.go</code> 中定义了各种 Token 的类型，如下划线、星号、井号、空格、换行等，基本上就是在 Markdown 中含有语义成分的字符，都会作为一个 Token 类型。正文内容分为 <code>Number</code> 数字和 <code>Text</code> 文本两种 Token 类型。</p>
<p><code>Tokenize(text string) []*Token</code> 函数就是很标准的传入 <code>text</code> 字符串，挨个字符 switch-case，然后转换为 Token 结构体添加到切片中。</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#ff7b72">var</span> prevToken <span style="color:#ff7b72;font-weight:bold">*</span>Token
</span></span><span style="display:flex;"><span><span style="color:#ff7b72">if</span> len(tokens) &gt; <span style="color:#a5d6ff">0</span> {
</span></span><span style="display:flex;"><span> prevToken = tokens[len(tokens)<span style="color:#ff7b72;font-weight:bold">-</span><span style="color:#a5d6ff">1</span>]
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>isNumber <span style="color:#ff7b72;font-weight:bold">:=</span> c <span style="color:#ff7b72;font-weight:bold">&gt;=</span> <span style="color:#a5d6ff">&#39;0&#39;</span> <span style="color:#ff7b72;font-weight:bold">&amp;&amp;</span> c <span style="color:#ff7b72;font-weight:bold">&lt;=</span> <span style="color:#a5d6ff">&#39;9&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#ff7b72">if</span> prevToken <span style="color:#ff7b72;font-weight:bold">!=</span> <span style="color:#79c0ff">nil</span> {
</span></span><span style="display:flex;"><span> <span style="color:#ff7b72">if</span> (prevToken.Type <span style="color:#ff7b72;font-weight:bold">==</span> Text <span style="color:#ff7b72;font-weight:bold">&amp;&amp;</span> !isNumber) <span style="color:#ff7b72;font-weight:bold">||</span> (prevToken.Type <span style="color:#ff7b72;font-weight:bold">==</span> Number <span style="color:#ff7b72;font-weight:bold">&amp;&amp;</span> isNumber) {
</span></span><span style="display:flex;"><span> prevToken.Value <span style="color:#ff7b72;font-weight:bold">+=</span> string(c)
</span></span><span style="display:flex;"><span> <span style="color:#ff7b72">continue</span>
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff7b72">if</span> isNumber {
</span></span><span style="display:flex;"><span> tokens = append(tokens, <span style="color:#d2a8ff;font-weight:bold">NewToken</span>(Number, string(c)))
</span></span><span style="display:flex;"><span>} <span style="color:#ff7b72">else</span> {
</span></span><span style="display:flex;"><span> tokens = append(tokens, <span style="color:#d2a8ff;font-weight:bold">NewToken</span>(Text, string(c)))
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>对于不在上述 Markdown 语义中的字符，则判断是否为数字 0-9，如果是的话说明是一个 <code>Number</code> 数字 Token，同时还需要看下上一个 Token 是不是也是数字，如果是的话他俩就是挨一起的，共同组成了一个 <code>Number</code> Token。<code>Text</code> 文本 Token 也是一样的逻辑，将挨着的文本字符统一为一个 <code>Text</code> Token。</p>
<p>Token 拆分完后，就开始构建 AST 了。</p>
<p><code>ast</code> 目录下有 <code>inline.go</code> 和 <code>block.go</code> 两个文件。前者定义了单个节点类型，如普通的文本节点、加粗、斜体、链接、井号标签等；后者定义了多个普通节点组成的集合节点，如段落、代码块、标题、有序无需列表、复选框等。</p>
<p><code>parser/parser.go</code> 里定义的 <code>ParseXXX</code> 函数将第一步的 <code>[]*tokenizer.Token</code> 解析成 <code>[]ast.Node</code> 。</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>nodes <span style="color:#ff7b72;font-weight:bold">:=</span> []ast.Node{}
</span></span><span style="display:flex;"><span><span style="color:#ff7b72">for</span> len(tokens) &gt; <span style="color:#a5d6ff">0</span> {
</span></span><span style="display:flex;"><span> <span style="color:#ff7b72">for</span> _, blockParser <span style="color:#ff7b72;font-weight:bold">:=</span> <span style="color:#ff7b72">range</span> blockParsers {
</span></span><span style="display:flex;"><span> node, size <span style="color:#ff7b72;font-weight:bold">:=</span> blockParser.<span style="color:#d2a8ff;font-weight:bold">Match</span>(tokens)
</span></span><span style="display:flex;"><span> <span style="color:#ff7b72">if</span> node <span style="color:#ff7b72;font-weight:bold">!=</span> <span style="color:#79c0ff">nil</span> <span style="color:#ff7b72;font-weight:bold">&amp;&amp;</span> size <span style="color:#ff7b72;font-weight:bold">!=</span> <span style="color:#a5d6ff">0</span> {
</span></span><span style="display:flex;"><span> <span style="color:#8b949e;font-style:italic">// Consume matched tokens.</span>
</span></span><span style="display:flex;"><span> tokens = tokens[size:]
</span></span><span style="display:flex;"><span> nodes = append(nodes, node)
</span></span><span style="display:flex;"><span> <span style="color:#ff7b72">break</span>
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span> }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>本质上也还是将 Tokens 丢给所有的 <code>BlockParser</code> 在 for 循环里过一遍， <code>BlockParser</code> 接口实现 <code>Match()</code> 方法，不同的 Node 会一次性读取不同数量的 Tokens，判断格式是否满足 Node 的要求，来确定这些 Tokens 是否组成了这个 Node。Match 上了则会返回生成的 Node 和匹配上的 Tokens 长度，截去这个 Node 匹配的 Tokens，剩下的 Tokens 继续轮一遍所有的 <code>BlockParser</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#ff7b72">var</span> defaultInlineParsers = []InlineParser{
</span></span><span style="display:flex;"><span> <span style="color:#d2a8ff;font-weight:bold">NewEscapingCharacterParser</span>(),
</span></span><span style="display:flex;"><span> <span style="color:#d2a8ff;font-weight:bold">NewHTMLElementParser</span>(),
</span></span><span style="display:flex;"><span> <span style="color:#d2a8ff;font-weight:bold">NewBoldItalicParser</span>(),
</span></span><span style="display:flex;"><span> <span style="color:#d2a8ff;font-weight:bold">NewImageParser</span>(),
</span></span><span style="display:flex;"><span> <span style="color:#ff7b72;font-weight:bold">...</span>
</span></span><span style="display:flex;"><span> <span style="color:#d2a8ff;font-weight:bold">NewReferencedContentParser</span>(),
</span></span><span style="display:flex;"><span> <span style="color:#d2a8ff;font-weight:bold">NewTagParser</span>(),
</span></span><span style="display:flex;"><span> <span style="color:#d2a8ff;font-weight:bold">NewStrikethroughParser</span>(),
</span></span><span style="display:flex;"><span> <span style="color:#d2a8ff;font-weight:bold">NewLineBreakParser</span>(),
</span></span><span style="display:flex;"><span> <span style="color:#d2a8ff;font-weight:bold">NewTextParser</span>(),
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>值得注意的是，这些 <code>BlockParser</code> 的顺序应该是有讲究的。像最普通的、最容易匹配上的 <code>Text</code> 纯文本类型，应该放在最后。当前面所有的 Parser 都没匹配上时，才说明这个 Token 是文本类型的 Node。如果把 <code>TextParser</code> 放最前面，那估计所有的 Tokens 都会被匹配成文本 Node。</p>
<p>将 Tokens 转换为 AST 上的 Nodes 后，最后还有个 <code>mergeListItemNodes</code> 函数，是用来特殊处理 <code>List</code> 列表节点的。如在列表的最后加上换行符，判断列表项是要拆成两个列表节点还是添加到末尾。</p>
<p><code>renderer</code> 目录则是遍历上述 AST 中的节点，来将 AST 转换成 HTML 或者 String 纯文本。这里就很简单了，不同的节点调不同的函数 <code>WriteString</code> 即可。</p>
<p>综上，<code>gomark</code> 就完成了将 Markdown 格式文本，解析转换成 HTML 或 String 纯文本的工作。</p>
<h2 id="其它的小细节">其它的小细节</h2>
<p>最后再说些自己发现的小细节吧，就不单独分一块了。</p>
<h3 id="前端-embed-indexhtml">前端 embed index.html</h3>
<p>随着 Go Embed 功能加入后，我很喜欢将 Vue 编译后的前端打包进 Go Binary 中。往往是会在 <code>web</code> 或者 <code>frontend</code> 前端代码路径下，保留放编译产物的 <code>dist</code> 目录，在里面放个 gitkeep 文件啥的。</p>
<p>memos 的做法是放置了一个 <code>frontend/dist/index.html</code> 文件：</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-html" data-lang="html"><span style="display:flex;"><span><span style="color:#8b949e;font-weight:bold;font-style:italic">&lt;!DOCTYPE html&gt;</span>
</span></span><span style="display:flex;"><span>&lt;<span style="color:#7ee787">html</span> lang<span style="color:#ff7b72;font-weight:bold">=</span><span style="color:#a5d6ff">&#34;en&#34;</span>&gt;
</span></span><span style="display:flex;"><span> &lt;<span style="color:#7ee787">head</span>&gt;
</span></span><span style="display:flex;"><span> &lt;<span style="color:#7ee787">meta</span> charset<span style="color:#ff7b72;font-weight:bold">=</span><span style="color:#a5d6ff">&#34;UTF-8&#34;</span> /&gt;
</span></span><span style="display:flex;"><span> &lt;<span style="color:#7ee787">meta</span> name<span style="color:#ff7b72;font-weight:bold">=</span><span style="color:#a5d6ff">&#34;viewport&#34;</span> content<span style="color:#ff7b72;font-weight:bold">=</span><span style="color:#a5d6ff">&#34;width=device-width, initial-scale=1.0&#34;</span> /&gt;
</span></span><span style="display:flex;"><span> &lt;<span style="color:#7ee787">title</span>&gt;Memos&lt;/<span style="color:#7ee787">title</span>&gt;
</span></span><span style="display:flex;"><span> &lt;/<span style="color:#7ee787">head</span>&gt;
</span></span><span style="display:flex;"><span> &lt;<span style="color:#7ee787">body</span>&gt;
</span></span><span style="display:flex;"><span> No embeddable frontend found.
</span></span><span style="display:flex;"><span> &lt;/<span style="color:#7ee787">body</span>&gt;
</span></span><span style="display:flex;"><span>&lt;/<span style="color:#7ee787">html</span>&gt;
</span></span></code></pre></div><p>直接在 Body 中写明了前端嵌入文件不存在。这样既可以通过编译，如若用户访问时，前端真没有被打包进来，在 index.html 也会有一个错误提示，比我只放一个不会被读到的 gitkeep 好些。</p>
<h3 id="jwt-token-解析">JWT Token 解析</h3>
<p>memos 使用 JWT Token 鉴权。因此需要解析通过 <code>Authorization</code> 头传进来的形如 <code>Bearer xxxx</code> 内容。问题是用户可能在 <code>Bearer</code> 和 Token 之间传入不定数量的空格，甚至在 <code>Bearer</code> 前或者 <code>xxx</code> 后也会有空格。</p>
<p>要是我的话，可能就先 <code>strings.TrimSpace</code> ，再 <code>strings.Split</code> 按空格分隔，然后再取判断长度，取第一个元素和最后一个元素，即为 <code>Bearer</code> 和 Token。memos 里直接使用了 <code>strings.Fields</code> 包来做到这一点，直接解决了上述可能存在的问题。后面要做的仅仅只有判断切片长度是否为 <code>2</code> 即可。</p>
<h2 id="总结">总结</h2>
<p>以上便是我之前阅读 memos 源码的一些心得体会。由于时间关系，我并没有很仔细的去阅读每一个文件的每一行代码，也没去审是否有潜在的安全漏洞。memos 的前端是使用 React 编写的，由于我平时不怎么写 React，所以前端这块也只是粗略的翻了翻。</p>
<p>memos 还是有很多可圈可点之处的，学到很多。貌似作者其它的开源项目也都有使用 memos 这种黑白动物风格的 Logo，相当于是一套统一的品牌。我对 AI 生成产品 Logo 这方面也挺感兴趣的，因为自己实在设计不来一个好看的 Logo&hellip;&hellip; 之后这块可以多研究下。</p>